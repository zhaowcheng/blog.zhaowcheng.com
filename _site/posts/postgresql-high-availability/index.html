<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="pv-cache-path" content="/pageviews.json"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="PostgreSQL 高可用（high availability)" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="1 简介" /><meta property="og:description" content="1 简介" /><link rel="canonical" href="https://zhaowcheng.com/posts/postgresql-high-availability/" /><meta property="og:url" content="https://zhaowcheng.com/posts/postgresql-high-availability/" /><meta property="og:site_name" content="zhaowcheng" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-03-18T22:40:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="PostgreSQL 高可用（high availability)" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhaowcheng.com/posts/postgresql-high-availability/"},"url":"https://zhaowcheng.com/posts/postgresql-high-availability/","description":"1 简介","dateModified":"2025-04-26T14:28:23+08:00","datePublished":"2025-03-18T22:40:00+08:00","headline":"PostgreSQL 高可用（high availability)","@type":"BlogPosting","@context":"https://schema.org"}</script><title>PostgreSQL 高可用（high availability) | zhaowcheng</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zhaowcheng"><meta name="application-name" content="zhaowcheng"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-512x512.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">zhaowcheng</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/zhaowcheng" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['zhaowcheng','163.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>PostgreSQL 高可用（high availability)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>PostgreSQL 高可用（high availability)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> zhaowcheng </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2025-03-18, 22:40 +0800" >03-18<i class="unloaded">2025-03-18T22:40:00+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2025-04-26, 14:28 +0800" >04-26<i class="unloaded">2025-04-26T14:28:23+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3043 字">16 分钟 阅读</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> 次浏览</div></div><div class="post-content"><h2 id="1-简介">1 简介</h2><p>主节点持续归档/传送 WAL，备节点持续恢复/接收 WAL 并回放（replay），以此实现一个高可用集群，这种方式叫做 <code class="language-plaintext highlighter-rouge">log shipping</code>，这样的备节点也叫做 <code class="language-plaintext highlighter-rouge">warm standby</code>，如果备节点还可以接受 <code class="language-plaintext highlighter-rouge">只读查询</code>，则叫做 <code class="language-plaintext highlighter-rouge">hot standby</code>。</p><p>PostgreSQL 支持 2 种级别的 <code class="language-plaintext highlighter-rouge">log shipping</code>：</p><ol><li><p><strong>文件级（file-based）</strong>：主节点配置 <code class="language-plaintext highlighter-rouge">archive_command</code> 持续归档 WAL 文件，备节点配置 <code class="language-plaintext highlighter-rouge">restore_command</code> 持续恢复 WAL 文件并回放。</p><li><p><strong>记录级（record-based）</strong>： 主节点持续传送 WAL 记录，备节点持续接收 WAL 记录并回放，即 <code class="language-plaintext highlighter-rouge">流复制（streaming replication）</code>。</p></ol><h2 id="2-环境要求">2 环境要求</h2><ul><li><p><strong>硬件</strong>：主备节点之间的 CPU 架构必须相同（不同架构下的数据类型长度可能不同，从而导致存储结构的差异）。</p><li><p><strong>版本</strong>：主备节点之间的 major 版本必须相同（minor 版本可以不同，通常 minor 版本之间的存储结构不发生变化，但是官方不对此做正式保证，所以建议主备之间版本尽量一致；如果需要升级整个集群的 minor 版本，建议先升级备节点，再升级主节点）。</p><li><p><strong>表空间（TABLESPACE）</strong>：主备节点之间必须存在相同的表空间路径。</p></ul><h2 id="3-备节点基本原理">3 备节点基本原理</h2><p>当一个数据库实例的数据目录（datadir）下存在 <code class="language-plaintext highlighter-rouge">standby.signal</code> 文件时，该实例启动时则进入 <code class="language-plaintext highlighter-rouge">备节点模式（standby mode）</code>。</p><p>备节点模式下启动，数据库按照如下顺序读取 WAL 并回放：</p><ol><li><p>如果配置了 <code class="language-plaintext highlighter-rouge">restore_command</code>，则调用 restore_command 从归档中恢复 WAL 并回放直到 restore_command 失败为止。</p><li><p>然后读取 <code class="language-plaintext highlighter-rouge">pg_wal</code> 目录中的所有可用 WAL 并回放直到结束；</p><li><p>然后，如果配置了流复制，则通过流复制从主节点持续接收 WAL 并回放；</p><li><p>如果流复制断开，则重新从第 1 步开始，如此循环往复；</p></ol><p>当备节点执行升主操作（<code class="language-plaintext highlighter-rouge">pg_ctl promote</code> 或调用 <code class="language-plaintext highlighter-rouge">pg_promote()</code> 函数）后，则退出备节点模式，但是在升主前，会把 <code class="language-plaintext highlighter-rouge">归档</code> 和 <code class="language-plaintext highlighter-rouge">pg_wal</code> 中的可用 WAL 都先回放了。</p><h2 id="4-文件级持续归档和恢复">4 文件级（持续归档和恢复）</h2><h3 id="41-主节点配置">4.1 主节点配置</h3><ol><li><p>配置 <code class="language-plaintext highlighter-rouge">archive_mode</code> 参数为 <code class="language-plaintext highlighter-rouge">on</code>。</p><li><p>配置 <code class="language-plaintext highlighter-rouge">archive_command</code> 参数来持续归档 WAL 到一个即使主节点挂掉了，备节点也能访问的地方，可以是第三方节点或者就在备节点上。</p></ol><h3 id="42-备节点配置">4.2 备节点配置</h3><ol><li><p>使用 <code class="language-plaintext highlighter-rouge">pg_basebackup</code> 命令从主节点拉取数据目录，如 <code class="language-plaintext highlighter-rouge">pg_basebackup -P -h &lt;PRIMARY_NODE_IP&gt; -U &lt;REPLICATION_USER&gt; -p &lt;DBPORT&gt; -D &lt;DATADIR&gt;</code>。</p><li><p>配置 <code class="language-plaintext highlighter-rouge">restore_command</code> 参数来从归档持续恢复 WAL 文件并回放。</p><li><p>配置 <code class="language-plaintext highlighter-rouge">archive_mode</code> 和 <code class="language-plaintext highlighter-rouge">archive_command</code> 参数和主节点一样，以备当前备节点提升为主节点后能继续归档（除非 <code class="language-plaintext highlighter-rouge">archive_mode</code> 为 <code class="language-plaintext highlighter-rouge">always</code>，否则备节点模式下不会执行归档命令）。</p><li><p>配置 <code class="language-plaintext highlighter-rouge">recovery_target_timeline</code> 为 <code class="language-plaintext highlighter-rouge">latest</code>（默认值），以此保证当发生切主到其他备节点时，当前备节点能及时跟随新主。</p><li><p>如果只有一主一备，则可以同时在 <code class="language-plaintext highlighter-rouge">archive_cleanup_command</code> 参数中调用 <code class="language-plaintext highlighter-rouge">pg_archivecleanup</code> 命令来自动清理当前备节点已不再需要的 WAL 文件。</p><li><p>在数据目录下创建 <code class="language-plaintext highlighter-rouge">standby.signal</code> 文件并启动数据库。</p></ol><h3 id="43-备节点配置持续归档">4.3 备节点配置持续归档</h3><p>当 <code class="language-plaintext highlighter-rouge">archive_mode</code> 参数配置为 <code class="language-plaintext highlighter-rouge">always</code> 时，备节点模式下仍然会执行 <code class="language-plaintext highlighter-rouge">archive_command</code> 来归档 WAL 文件。这通常用在级联复制的上游（upstream）备节点中，用于给下游（downstream）备节点提供归档。</p><h2 id="5-记录级流复制">5 记录级（流复制）</h2><h3 id="51-主节点配置">5.1 主节点配置</h3><ol><li><p>配置 <code class="language-plaintext highlighter-rouge">listen_addresses</code> 参数为包括备节点 IP 的范围，如 <code class="language-plaintext highlighter-rouge">*</code>。</p><li><p>创建一个带 <code class="language-plaintext highlighter-rouge">REPLICATION</code> 权限的用户，如 <code class="language-plaintext highlighter-rouge">CREATE USER &lt;REPLICATION_USER&gt; PASSWORD '&lt;REPLICATION_PWD&gt;' REPLICATION;</code>。</p><li><p>在 <code class="language-plaintext highlighter-rouge">pg_hba.conf</code> 文件中增加允许备节点访问的配置，如 <code class="language-plaintext highlighter-rouge">host replication &lt;REPLICATION_USER&gt; &lt;STANDBY_NODE_IP&gt;/32 md5</code>（<code class="language-plaintext highlighter-rouge">database</code> 列配置为虚拟数据库名 <code class="language-plaintext highlighter-rouge">replication</code>）。</p><li><p>配置 <code class="language-plaintext highlighter-rouge">max_wal_senders</code> 参数为足够所有备节点使用的值。</p><li><p>为了防止 WAL 文件在备节点接收前被回收，可以配置 <code class="language-plaintext highlighter-rouge">wal_keep_size</code> 参数或 <a href="#53-复制槽">复制槽</a> 来为备节点保留 WAL。</p><li><p>在支持 <code class="language-plaintext highlighter-rouge">socket keepalive</code> 的系统上，可以配置 <code class="language-plaintext highlighter-rouge">tcp_keepalives_idle</code>、<code class="language-plaintext highlighter-rouge">tcp_keepalives_interval</code> 和 <code class="language-plaintext highlighter-rouge">tcp_keepalives_count</code> 这几个参数来帮助主节点及时发现流复制连接断开情况。</p></ol><h3 id="52-备节点配置">5.2 备节点配置</h3><ol><li><p>使用 <code class="language-plaintext highlighter-rouge">pg_basebackup</code> 命令从主节点拉取数据目录，如 <code class="language-plaintext highlighter-rouge">pg_basebackup -P -h &lt;PRIMARY_NODE_IP&gt; -U &lt;REPLICATION_USER&gt; -p &lt;DBPORT&gt; -D &lt;DATADIR&gt;</code>。</p><li><p>配置 <code class="language-plaintext highlighter-rouge">primary_conninfo</code> 参数连接到主节点，如 <code class="language-plaintext highlighter-rouge">primary_conninfo = 'host=&lt;PRIMARY_NODE_IP&gt; port=&lt;DBPORT&gt; user=&lt;REPLICATION_USER&gt; password=&lt;REPLICATION_PWD&gt;'</code>。</p><li><p>在数据目录下创建 <code class="language-plaintext highlighter-rouge">standby.signal</code> 文件并启动数据库。</p><li><p>启动并连接成功后，可以在备节点看到一个 <code class="language-plaintext highlighter-rouge">walreceiver</code> 进程，还可以在主节点看到一个 <code class="language-plaintext highlighter-rouge">walsender</code> 进程。</p></ol><h3 id="53-复制槽">5.3 复制槽</h3><p>如果流复制备节点连接断开后过了较长时间才恢复连接，那么有些还没有被备节点接收的 WAL 文件可能在主节点已经被回收，导致备节点无法追赶（catch-up）上主节点。我们可以通过配置 <code class="language-plaintext highlighter-rouge">wal_keep_size</code> 参数或 <code class="language-plaintext highlighter-rouge">复制槽</code> 来避免该问题。但是配置 <code class="language-plaintext highlighter-rouge">wal_keep_size</code> 的方式需要估计一个比实际需要保存更大的值，这样就会又些冗余文件的方式，而 <code class="language-plaintext highlighter-rouge">复制槽</code> 的方式则更精确，仅保留未被绑定到该复制槽上的备节点们接收的 WAL 文件。</p><p>需要注意的是配置复制槽后，如果备节点长期离线，可能会导致主节点积压过多的 WAL 文件而占用大量空间，为了避免该问题，可以配置 <code class="language-plaintext highlighter-rouge">max_slot_wal_keep_size</code> 参数来限制保留的最大值。</p><p>可以通过 <a href="https://www.postgresql.org/docs/17/protocol-replication.html">流复制协议</a> 或 <a href="https://www.postgresql.org/docs/17/functions-admin.html#FUNCTIONS-REPLICATION">相关 SQL 函数</a> 来创建管理复制槽，比如：</p><div class="language-console highlighter-rouge"><div class="code-header"> <span text-data=" Console "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="gp">postgres=#</span><span class="w"> </span>SELECT <span class="k">*</span> FROM pg_create_physical_replication_slot<span class="o">(</span><span class="s1">'node_a_slot'</span><span class="o">)</span><span class="p">;</span>
<span class="go">  slot_name  | lsn
-------------+-----
 node_a_slot |

</span><span class="gp">postgres=#</span><span class="w"> </span>SELECT slot_name, slot_type, active FROM pg_replication_slots<span class="p">;</span>
<span class="go">  slot_name  | slot_type | active
-------------+-----------+--------
 node_a_slot | physical  | f
(1 row)
</span></pre></table></code></div></div><p>备节点通过配置 <code class="language-plaintext highlighter-rouge">primary_slot_name</code> 参数来绑定复制槽，比如：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>primary_slot_name = 'node_a_slot'
</pre></table></code></div></div><h3 id="54-级联复制">5.4 级联复制</h3><p>备节点可以不连接主节点而连接其他备节点并接收 WAL，这样所组成的多级流复制拓扑就是 <code class="language-plaintext highlighter-rouge">级联复制（cascading replication）</code>，这样可以减少主节点的连接数量以此减少主节点的带宽占用。</p><p>级联复制的层级数量不受限制，更靠近主节点一端备节点被称为 <code class="language-plaintext highlighter-rouge">上游节点（upstream）</code>，离主节点更远一端的节点则被称为 <code class="language-plaintext highlighter-rouge">下游节点（downstream）</code>，一个备节点可以有多个下游，但是只能有一个上游（流复制本身也只能连接到一个发送方，即只能配置一个 primary_conninfo）。</p><p>级联复制中的上游节点不仅发送自己接收到的 WAL，如果配置了持续恢复（restore_command），还会发送恢复出来的 WAL（主节点不会，因为主节点不会执行 restore_command），所以即使上游节点与更上游节点的连接断开，只要有持续恢复出来的新的可用的 WAL，还是会继续向下游节点发送（也就是说上游节点可以是 <code class="language-plaintext highlighter-rouge">file-based</code> 方式的备节点）。</p><p>级联复制中只有 <code class="language-plaintext highlighter-rouge">直接备节点（直连到主节点）</code> 支持同步，其他 <code class="language-plaintext highlighter-rouge">间接备节点</code> 只能是异步的，就算是在主节点 <code class="language-plaintext highlighter-rouge">synchronous_standby_names</code> 参数中指定了级联复制中的间接备节点也不会产生作用。</p><p>如果级联复制备节点中开启了 <code class="language-plaintext highlighter-rouge">hot_standby_feedback</code> 参数，那么该备节点的 <code class="language-plaintext highlighter-rouge">feedback</code> 消息会逐级往上传播直到主节点。</p><p>如果上游节点提升为了主节点，下游节点在配置 <code class="language-plaintext highlighter-rouge">recovery_target_timeline</code> 参数为 <code class="language-plaintext highlighter-rouge">latest</code>（默认值）的情况下，会自动跟随新主。</p><p>要使用级联复制，上游节点除了需要像主节点一样的相关配置（<code class="language-plaintext highlighter-rouge">listen_addresses</code>、<code class="language-plaintext highlighter-rouge">pg_hba.conf</code>、<code class="language-plaintext highlighter-rouge">max_wal_senders</code>、<code class="language-plaintext highlighter-rouge">wal_keep_size</code> 或复制槽）之外，还需要配置 <code class="language-plaintext highlighter-rouge">hot_standby</code> 参数为 <code class="language-plaintext highlighter-rouge">on</code>（也就是设置为热备），因为备节点的流复制连接需要进行一些必要的只读查询。</p><h3 id="55-同步复制synchronous-replication">5.5 同步复制（synchronous replication）</h3><p>流复制默认是 <code class="language-plaintext highlighter-rouge">异步（asynchronous）</code> 的，即一个事物在主节点提交后如果马上去备节点查询，有可能还查询不到，因为 WAL 记录可能还没有传送到备节点或者备节点还没有回放该记录。</p><p>可以把一个或多个备节点指定为 <code class="language-plaintext highlighter-rouge">同步（synchronous）</code> 备节点，配置了同步备节点的流复制集群，在事务提交时需要 <code class="language-plaintext highlighter-rouge">一直等待</code> 直到收到同步备节点回复的 WAL 记录已保存的消息后，才给客户端返回成功。</p><p>以下情况不需要等待同步备节点回复：</p><ul><li>只读事务（read-only transactions）<li>事务回滚（transaction rollbacks）<li>子事务（subtransaction）<li>数据载入（data loading）<li>索引构建（index building）</ul><p>同步备节点可以是 <code class="language-plaintext highlighter-rouge">物理（流）复制备节点（physical/stream replication standby）</code>，也可以是 <code class="language-plaintext highlighter-rouge">逻辑复制订阅者（logical replication subscriber）</code>，也可以是其他一些第三方程序，比如 <code class="language-plaintext highlighter-rouge">pg_receivewal</code> 和 <code class="language-plaintext highlighter-rouge">pg_recvlogical</code> 等。</p><p>发生 <code class="language-plaintext highlighter-rouge">fast shutdown</code> 请求时，数据库会将正在等待的同步备节点的事务提交立即返回给客户端让其停止等待，但是仍然会等到 WAL 都已发送到所有备节点后才关闭（异步情况下也是如此）。</p><p>启用同步复制，需要在发送节点同时配置参数 <a href="/posts/postgresql-configuration/#synchronous_commit-enum">synchronous_commit</a> 和 <a href="/posts/postgresql-configuration/#synchronous_standby_names-string">synchronous_standby_names</a>，配置说明请点击对应参数链接查看。</p><p>如果因为同步备节点故障导致事务提交被阻塞，可以设置 <code class="language-plaintext highlighter-rouge">synchronous_standby_names</code> 参数为空并 <code class="language-plaintext highlighter-rouge">reload</code> 来立即关闭同步模式，从而解决阻塞的问题：</p><pre><code class="language-SQL">ALTER SYSTEM SET synchronous_standby_names TO '';
SELECT pg_reload_conf();
</code></pre><h3 id="56-状态查询">5.6 状态查询</h3><p>查询流复制状态主要通过以下函数和视图：</p><div class="table-wrapper"><table><thead><tr><th>函数/视图<th>说明<th>使用范围/条件<tbody><tr><td><a href="https://www.postgresql.org/docs/17/functions-admin.html#FUNCTIONS-ADMIN-BACKUP">pg_current_wal_flush_lsn()</a><td>已刷盘的最新的 LSN<td>恢复状态下不可用<tr><td><a href="https://www.postgresql.org/docs/17/functions-admin.html#FUNCTIONS-ADMIN-BACKUP">pg_current_wal_lsn()</a><td>已写入文件系统缓存的最新的 LSN<td>恢复状态下不可用<tr><td><a href="https://www.postgresql.org/docs/17/functions-admin.html#FUNCTIONS-ADMIN-BACKUP">pg_current_wal_insert_lsn()</a><td>已插入 WAL 缓存的最新的 LSN<td>恢复状态下不可用<tr><td><a href="https://www.postgresql.org/docs/17/functions-admin.html#FUNCTIONS-RECOVERY-CONTROL">pg_last_wal_receive_lsn()</a><td>已收到并且已刷盘的最新的 LSN<td>没有 receiver 进程则返回 NULL<tr><td><a href="https://www.postgresql.org/docs/17/functions-admin.html#FUNCTIONS-RECOVERY-CONTROL">pg_last_wal_replay_lsn()</a><td>恢复状态下已回放的最新的 LSN<td>非恢复状态下则返回 NULL<tr><td><a href="https://www.postgresql.org/docs/17/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW">pg_stat_replication</a><td>每个 sender 进程对应流复制的状态信息<td>N/A<tr><td><a href="https://www.postgresql.org/docs/17/monitoring-stats.html#MONITORING-PG-STAT-WAL-RECEIVER-VIEW">pg_stat_wal_receiver</a><td>receiver 进程对应的流复制状态信息<td>N/A</table></div><blockquote><p>注：一个数据库实例最多只能有一个 receiver。</p></blockquote><h2 id="6-文件级--记录级">6 文件级 + 记录级</h2><p>同时配置文件级和记录级的 <code class="language-plaintext highlighter-rouge">log shipping</code> 可以达到更佳的效果，例如当备节点长时间离线后重新回归时，主节点上有些 WAL 可能已经被回收，但是备节点可以通过持续恢复从归档中获取 WAL，避免了 WAL 缺失导致的备节点回归失败。</p><h2 id="7-热备hot-standby">7 热备（hot standby）</h2><p>当数据库 <code class="language-plaintext highlighter-rouge">hot_standby</code> 参数配置为 <code class="language-plaintext highlighter-rouge">on</code> 时，则在恢复状态下仍然可以接受 <code class="language-plaintext highlighter-rouge">只读查询</code>，所以如果备节点开启了该参数，也就可以同时接受只读查询，也就是一个 <code class="language-plaintext highlighter-rouge">热备（hot standby）</code>。</p><h2 id="8-故障转移failover">8 故障转移（failover）</h2><p>当主节点故障时，备节点可以通过执行 <code class="language-plaintext highlighter-rouge">pg_ctl promote</code> 命令或者 <code class="language-plaintext highlighter-rouge">pg_promote()</code> 函数来升级为主节点，以此实现故障转移。</p><p>故障切换后，原主节点故障修复后应该配置为备节点跟随新主节点，如果仍然以主节点启动，将会导致脑裂（即存在多个主节点）。</p><p>可以使用 <a href="https://www.postgresql.org/docs/17/app-pgrewind.html">pg_rewind</a> 帮助原主节点作为备节点快速同步新主节点的数据。</p><h2 id="9-参考资料">9 参考资料</h2><ul><li>[High Availability, Load Balancing, and Replication] : https://www.postgresql.org/docs/17/high-availability.html</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/postgresql/'>PostgreSQL</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/postgresql/" class="post-tag no-text-decoration" >postgresql</a> <a href="/tags/high-availability/" class="post-tag no-text-decoration" >high-availability</a> <a href="/tags/unfinished/" class="post-tag no-text-decoration" >unfinished</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/postgresql-high-availability/">PostgreSQL 高可用（high availability)</a><li><a href="/posts/etcd-tls/">ETCD 配置 TLS</a><li><a href="/posts/classification-of-chinese-os-and-cpu/">国产操作系统和 CPU 分类</a><li><a href="/posts/introduction-to-fpm/">fpm: 一个跨平台且支持多种包格式的打包工具</a><li><a href="/posts/postgresql-version-policy/">PostgreSQL 版本策略（versioning policy)</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/postgresql/">postgresql</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/ssl/">ssl</a> <a class="post-tag" href="/tags/tls/">tls</a> <a class="post-tag" href="/tags/unfinished/">unfinished</a> <a class="post-tag" href="/tags/automation-testing/">automation-testing</a> <a class="post-tag" href="/tags/bridge/">bridge</a> <a class="post-tag" href="/tags/character-set/">character-set</a> <a class="post-tag" href="/tags/codeset/">codeset</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/postgresql-configuration/"><div class="card-body"> <span class="timeago small" >04-02<i class="unloaded">2025-04-02T12:58:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PostgreSQL 配置说明</h3><div class="text-muted small"><p> Preface Write Ahead Log synchronous_commit (enum) 设置事务提交时需要等到 WAL 被保存到何种程度才返回，下表描述了可设置的值及其说明（数据安全程度依次递减）： 值 说明 remote_apply 等到同步备节点回放了 WAL ...</p></div></div></a></div><div class="card"> <a href="/posts/patroni-configuration/"><div class="card-body"> <span class="timeago small" >03-27<i class="unloaded">2025-03-27T18:58:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Patroni 配置说明</h3><div class="text-muted small"><p> 1 配置类型 全局配置（Global Configuration） 作用范围：所有节点。 修改方式：初始化（bootstrap）前，修改配置文件中的 bootstrap.dcs 部分；初始化后，通过 patronictl edit-config 命令或 REST 接口 /config 修改...</p></div></div></a></div><div class="card"> <a href="/posts/postgresql-encoding/"><div class="card-body"> <span class="timeago small" >2024-12-22<i class="unloaded">2024-12-22T10:23:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PostgreSQL 编码支持（character set/encoding)</h3><div class="text-muted small"><p> 编码支持 PostgreSQL 支持的所有编码（包括服务端和客户端）: PostgreSQL Character Sets 客户端支持表中所有编码； 服务端支持表中大部分编码； 在服务端，编码设置必须与 locale 设置 LC_CTYPE 和 LC_COLLATE 兼容： 当 locale 设置为 C 或 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/postgresql-version-policy/" class="btn btn-outline-primary" prompt="上一篇"><p>PostgreSQL 版本策略（versioning policy)</p></a> <a href="/posts/patroni-configuration/" class="btn btn-outline-primary" prompt="下一篇"><p>Patroni 配置说明</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://zhaowcheng.com">zhaowcheng</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span> <a href="https://beian.miit.gov.cn" target="_blank" rel="noopener">蜀ICP备2021030991号-1</a></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/postgresql/">postgresql</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/ssl/">ssl</a> <a class="post-tag" href="/tags/tls/">tls</a> <a class="post-tag" href="/tags/unfinished/">unfinished</a> <a class="post-tag" href="/tags/automation-testing/">automation testing</a> <a class="post-tag" href="/tags/bridge/">bridge</a> <a class="post-tag" href="/tags/character-set/">character set</a> <a class="post-tag" href="/tags/codeset/">codeset</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-PVZNL9JKFB"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-PVZNL9JKFB'); }); </script>
