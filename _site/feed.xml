<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zhaowcheng.com/</id><title>zhaowcheng</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2023-05-17T23:21:49+08:00</updated> <author> <name>zhaowcheng</name> <uri>https://zhaowcheng.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://zhaowcheng.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://zhaowcheng.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2023 zhaowcheng </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Python 杂项 - deepget 和 deepset</title><link href="https://zhaowcheng.com/posts/python-misc-deepget-and-deepset/" rel="alternate" type="text/html" title="Python 杂项 - deepget 和 deepset" /><published>2023-05-17T23:16:00+08:00</published> <updated>2023-05-17T23:16:00+08:00</updated> <id>https://zhaowcheng.com/posts/python-misc-deepget-and-deepset/</id> <content src="https://zhaowcheng.com/posts/python-misc-deepget-and-deepset/" /> <author> <name>zhaowcheng</name> </author> <category term="Python 杂项" /> <summary> 实现类似于 deepcopy 的两个函数 deepget 和 deepset，代码如下： from functools import reduce def parse_deepkey(deepkey: str, sep: str = '/') -&amp;gt; list: """ 深度路径分割 examples: &amp;gt;&amp;gt;&amp;gt; parse_deepkey('a/b1') ['a', 'b1'] &amp;gt;&amp;gt;&amp;gt; parse_deepkey('a/b2[0]') ['a', 'b2', 0] &amp;gt;&amp;gt;&amp;gt; parse_deepkey('a/b2[0]/c2') ['a', 'b2', 0, 'c2'] :param deep... </summary> </entry> <entry><title>date 命令使用示例</title><link href="https://zhaowcheng.com/posts/date-examples/" rel="alternate" type="text/html" title="date 命令使用示例" /><published>2022-11-28T22:24:00+08:00</published> <updated>2022-11-28T22:24:00+08:00</updated> <id>https://zhaowcheng.com/posts/date-examples/</id> <content src="https://zhaowcheng.com/posts/date-examples/" /> <author> <name>zhaowcheng</name> </author> <category term="Linux 命令" /> <summary> 显示 显示当前日期和时间 $ date Mon 28 Nov 2022 10:50:05 PM CST 显示指定格式的当前日期和时间 $ date +"%Y-%m-%d %H:%M:%S" 2022-11-28 22:51:10 $ date +"%y-%m-%d" 22-11-28 $ date +"%s" # seconds since 1970-01-01 00:00:00 UTC 1669647899 显示指定日期和时间 $ date --date="1 day ago" Sun 27 Nov 2022 10:59:30 PM CST $ date --date="1 day" Tue 29 Nov 2022 10:59:33 PM CST # 年 月 日 时 分 秒 -&amp;gt; year month day hour minute second ... </summary> </entry> <entry><title>sed 命令使用示例</title><link href="https://zhaowcheng.com/posts/sed-examples/" rel="alternate" type="text/html" title="sed 命令使用示例" /><published>2022-11-20T17:17:00+08:00</published> <updated>2022-11-20T17:17:00+08:00</updated> <id>https://zhaowcheng.com/posts/sed-examples/</id> <content src="https://zhaowcheng.com/posts/sed-examples/" /> <author> <name>zhaowcheng</name> </author> <category term="Linux 命令" /> <summary> 替换 把 hello 替换为 world $ sed 's/hello/world/g' 把第 2 到 5 行替换为一行 hello world $ sed '2,5c hello world' 插入 在第 2 行前面插入一行 hello world $ sed '2i hello world' 在第 2 行后面插入一行 hello world $ sed '2a hello world' 在包含 hello 行的前面插入一行 world $ sed '/hello/i world' 在包含 hello 行的后面插入一行 world $ sed '/hello/a world' 删除 删除第 2 行 $ sed '2d' 删除第 2 到 5 行 $ sed '2,5d' 删除第 2 到最后行 $ sed '2,$d' 删除包... </summary> </entry> <entry><title>Linux 上 ELF 文件依赖库的查找顺序</title><link href="https://zhaowcheng.com/posts/the-searching-order-of-elf-file-deps/" rel="alternate" type="text/html" title="Linux 上 ELF 文件依赖库的查找顺序" /><published>2022-10-15T13:07:00+08:00</published> <updated>2022-10-15T13:07:00+08:00</updated> <id>https://zhaowcheng.com/posts/the-searching-order-of-elf-file-deps/</id> <content src="https://zhaowcheng.com/posts/the-searching-order-of-elf-file-deps/" /> <author> <name>zhaowcheng</name> </author> <category term="Linux 打包" /> <summary> Linux 上的 2 种 ELF 文件类型：可执行文件（Executable file）和 共享对象文件（Shared object file），它们在执行期间需要通过 动态库链接器（ld.so）来查找其依赖的动态库文件，然而系统中可能在不同的目录下存在相同的动态库文件，那么执行时到底链接到哪个目录下的呢，本文将描述其在不同目录间的查找顺序。 如何识别 ELF 文件类型 Linux 上可通过 file 命令来查询文件类型，以 64 位系统为例，可执行文件 的查询结果中将包含如下内容 ELF 64-bit LSB executable 共享对象文件 的查询结果中将包含以下内容： ELF 64-bit LSB shared object 如何查询依赖库 Linux 上可通过 ldd 命令来查询 可执行文件 或 共享对象文件 的依赖库，例如查询 ls 命令的依赖库： r... </summary> </entry> <entry><title>一个跨平台且支持多种包格式的打包工具 - fpm</title><link href="https://zhaowcheng.com/posts/introduction-to-fpm/" rel="alternate" type="text/html" title="一个跨平台且支持多种包格式的打包工具 - fpm" /><published>2022-09-04T20:42:00+08:00</published> <updated>2022-09-04T20:42:00+08:00</updated> <id>https://zhaowcheng.com/posts/introduction-to-fpm/</id> <content src="https://zhaowcheng.com/posts/introduction-to-fpm/" /> <author> <name>zhaowcheng</name> </author> <category term="Linux 打包" /> <summary> 通过《一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式》和《国产操作系统和 CPU 分类》两篇文章，介绍了一种针对 Linux 上的 C/C++ 程序的简化打包数量的方式，从一次打需要适配的操作系统和 CPU 组合数量的包，简化为 CPU 架构数 * 2 的数量，那么在准备编译环境的时候也就需要准备 CPU 架构数 * 2 个。 现在介绍一个打包工具 fpm ，这是一个 跨平台 且 支持多种包格式 的打包工具，通过它可以在一个系统上同时打出 rpm 和 deb 的包，这样就可以把编译环境的数量从 CPU 架构数 * 2 减少到 CPU 架构数，进一步提高打包效率。 fpm 相比 rpm 和 deb 原生的打包方式更简单，且打包时间更短，下面演示使用 fpm 打包 postgresql： [root@el6-x86_64 fpm_example]# ls pg9 [... </summary> </entry> </feed>
