<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zhaowcheng.com/</id><title>zhaowcheng</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-10-15T16:13:04+08:00</updated> <author> <name>zhaowcheng</name> <uri>https://zhaowcheng.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://zhaowcheng.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://zhaowcheng.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 zhaowcheng </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Linux 上 ELF 文件依赖库的查找顺序</title><link href="https://zhaowcheng.com/posts/the-searching-order-of-elf-file-deps/" rel="alternate" type="text/html" title="Linux 上 ELF 文件依赖库的查找顺序" /><published>2022-10-15T13:07:00+08:00</published> <updated>2022-10-15T13:07:00+08:00</updated> <id>https://zhaowcheng.com/posts/the-searching-order-of-elf-file-deps/</id> <content src="https://zhaowcheng.com/posts/the-searching-order-of-elf-file-deps/" /> <author> <name>zhaowcheng</name> </author> <category term="杂七杂八" /> <summary> Linux 上的 2 种 ELF 文件类型：可执行文件（Executable file）和 共享对象文件（Shared object file），它们在执行期间需要通过 动态库链接器（ld.so）来查找其依赖的动态库文件，然而系统中可能在不同的目录下存在相同的动态库文件，那么执行时到底链接到哪个目录下的呢，本文将描述其在不同目录间的查找顺序。 如何识别 ELF 文件类型 Linux 上可通过 file 命令来查询文件类型，以 64 位系统为例，可执行文件 的查询结果中将包含如下内容 ELF 64-bit LSB executable 共享对象文件 的查询结果中将包含以下内容： ELF 64-bit LSB shared object 如何查询依赖库 Linux 上可通过 ldd 命令来查询 可执行文件 或 共享对象文件 的依赖库，例如查询 ls 命令的依赖库： r... </summary> </entry> <entry><title>一个跨平台且支持多种包格式的打包工具 - fpm</title><link href="https://zhaowcheng.com/posts/introduction-to-fpm/" rel="alternate" type="text/html" title="一个跨平台且支持多种包格式的打包工具 - fpm" /><published>2022-09-04T20:42:00+08:00</published> <updated>2022-09-04T20:42:00+08:00</updated> <id>https://zhaowcheng.com/posts/introduction-to-fpm/</id> <content src="https://zhaowcheng.com/posts/introduction-to-fpm/" /> <author> <name>zhaowcheng</name> </author> <category term="杂七杂八" /> <summary> 通过《一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式》和《国产操作系统和 CPU 分类》两篇文章，介绍了一种针对 Linux 上的 C/C++ 程序的简化打包数量的方式，从一次打需要适配的操作系统和 CPU 组合数量的包，简化为 CPU 架构数 * 2 的数量，那么在准备编译环境的时候也就需要准备 CPU 架构数 * 2 个。 现在介绍一个打包工具 fpm ，这是一个 跨平台 且 支持多种包格式 的打包工具，通过它可以在一个系统上同时打出 rpm 和 deb 的包，这样就可以把编译环境的数量从 CPU 架构数 * 2 减少到 CPU 架构数，进一步提高打包效率。 fpm 相比 rpm 和 deb 原生的打包方式更简单，且打包时间更短，下面演示使用 fpm 打包 postgresql： [root@el6-x86_64 fpm_example]# ls pg9 [... </summary> </entry> <entry><title>国产操作系统和 CPU 分类</title><link href="https://zhaowcheng.com/posts/classification-of-chinese-os-and-cpu/" rel="alternate" type="text/html" title="国产操作系统和 CPU 分类" /><published>2022-09-04T15:32:00+08:00</published> <updated>2022-09-04T15:32:00+08:00</updated> <id>https://zhaowcheng.com/posts/classification-of-chinese-os-and-cpu/</id> <content src="https://zhaowcheng.com/posts/classification-of-chinese-os-and-cpu/" /> <author> <name>zhaowcheng</name> </author> <category term="杂七杂八" /> <summary> 国产 操作系统 和 CPU 厂商数量繁多，令人眼花缭乱，如果你做一款 C/C++ 软件需要适配国产的各种操作系统和 CPU，打包时针对每一种操作系统和 CPU 的组合都要打一个包的话，那么每一次打包的数量可能会多达数十个，光是编译环境的准备都需要耗费大量的时间，这无疑是令人难以接受的。 但是万变不离其宗，如果经过仔细分析的话，会发现这些操作系统和 CPU 都是从现有的体系中衍生出来的，而不是完全新生事物，比如操作系统都是基于 Linux 的，且按照系统自带的包管理软件的不同，可以分为 2 个系列，分别是使用 rpm 的 redhat 系 和使用 dpkg 的 debian 系，适用于它们的安装包格式分别是 rpm 和 deb。CPU 按照指令架构划分，则可以分为 x86_64、aarch64、mips64el、loongarch64、sw_64 这 5 类，由于叫法的不同，有的会把... </summary> </entry> <entry><title>一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式</title><link href="https://zhaowcheng.com/posts/a-packaging-method-with-its-own-deps/" rel="alternate" type="text/html" title="一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式" /><published>2022-09-03T15:34:00+08:00</published> <updated>2022-09-03T15:34:00+08:00</updated> <id>https://zhaowcheng.com/posts/a-packaging-method-with-its-own-deps/</id> <content src="https://zhaowcheng.com/posts/a-packaging-method-with-its-own-deps/" /> <author> <name>zhaowcheng</name> </author> <category term="杂七杂八" /> <summary> Linux 上的 C/C++ 程序编译打包后拿到 同 CPU 架构 的其他 Linux 系统上运行时，通常会由于目标系统上缺少该程序所需的库而无法运行。 这个问题在一个连接上互联网的 Linux 系统上可以很容易的通过 yum 或 apt 安装缺少的依赖库来解决，但是如果是在一个无法使用 yum 和 apt 的内网系统上，则非常麻烦。 本文介绍一种打包方式，让打包后的程序即使在目标系统上没有该程序所需的库时，也能正常运行。 步骤 以下为该方式的详细步骤： 第一步：编译平台的选择 选择一个 libc 版本 小于等于 该程序需要适配的所有系统中 libc 版本最小的系统。 比如该程序需要适配 2 个系统，这两个系统的 libc 版本分别为 2.23 和 2.28，则选择一个 libc 版本 小于等于 2.23 的系统作为编译平台。 第二步：拷贝依赖库 在编译完成后，打包... </summary> </entry> <entry><title>Python 入门 - 12 - 模块和包</title><link href="https://zhaowcheng.com/posts/python-tutorial-12-modules-and-packages/" rel="alternate" type="text/html" title="Python 入门 - 12 - 模块和包" /><published>2022-03-10T15:16:00+08:00</published> <updated>2022-09-10T16:54:55+08:00</updated> <id>https://zhaowcheng.com/posts/python-tutorial-12-modules-and-packages/</id> <content src="https://zhaowcheng.com/posts/python-tutorial-12-modules-and-packages/" /> <author> <name>zhaowcheng</name> </author> <category term="Python 入门" /> <summary> 模块（module） 一个包含 Python 代码的 .py 文件就是一个 模块（module），文件名去除 .py 后缀就是 模块名，模块名也可以通过模块的 __name__ 属性获取。 一个模块可以被 import 引用，也可以当作脚本直接运行，模块中的 定义 和 语句 只在被 import 或直接运行的时候 执行一次。 例如现在有一个名为 fibo.py 的文件，其内容如下： def fib(n): a, b = 0, 1 while b &amp;lt; n: print(b, end=' ') a, b = b, a+b print() def fib2(n): result = [] a, b = 0, 1 while b &amp;lt; n: result.append(b) ... </summary> </entry> </feed>
