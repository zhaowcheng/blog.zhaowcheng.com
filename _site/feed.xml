

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>zhaowcheng</title>
  <subtitle>zhaowcheng's blog.</subtitle>
  <updated>2025-08-21T12:38:14+08:00</updated>
  <author>
    <name>zhaowcheng</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh-CN"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 zhaowcheng </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>GCC 编译过程</title>
    <link href="http://localhost:4000/posts/gcc-compilation-process/" rel="alternate" type="text/html" title="GCC 编译过程" />
    <published>2025-07-17T15:56:00+08:00</published>
  
    <updated>2025-07-17T15:56:00+08:00</updated>
  
    <id>http://localhost:4000/posts/gcc-compilation-process/</id>
    <content type="text/html" src="http://localhost:4000/posts/gcc-compilation-process/" />
    <author>
      <name>zhaowcheng</name>
    </author>

  
    
    <category term="Linux 打包" />
    
  

  <summary>概述  GCC 编译 C/C++ 代码的过程主要分为如下图的 4 个步骤（.i 和 .ii 分别是 .c 和 .cpp 源文件预处理后的中间文件后缀名；.o 和 .obj 分别是 Linux 和 Windows 系统上汇编后的目标文件后缀名；.a 和 .lib 分别是 Linux 和 Windows 系统上静态库文件后缀名；.exe 是 Windows 上可执行文件后缀名，Linux 上可执行文件无后缀名；另外，.so 和 .dll 分别是 Linux 和 Windows 系统上动态库文件后缀名；本文只是借用该图所表示的流程，不讨论 Windows 相关内容）：    后续章节我们将以 main.c, utils.h, utils.c 这几个文件（都在同一目录下）为例，分别对这几个步骤进行详细说明，这几个文件的源码分别如下：  // main.c #include &amp;lt;stdio...</summary>

  </entry>

  
  <entry>
    <title>GLIBC 与 Linux 内核的兼容性</title>
    <link href="http://localhost:4000/posts/compatibility-glibc-and-linux-kernel/" rel="alternate" type="text/html" title="GLIBC 与 Linux 内核的兼容性" />
    <published>2025-07-12T10:19:00+08:00</published>
  
    <updated>2025-07-12T10:19:00+08:00</updated>
  
    <id>http://localhost:4000/posts/compatibility-glibc-and-linux-kernel/</id>
    <content type="text/html" src="http://localhost:4000/posts/compatibility-glibc-and-linux-kernel/" />
    <author>
      <name>zhaowcheng</name>
    </author>

  
    
    <category term="Linux 打包" />
    
  

  <summary>根据 glibc 的 release history 整理出自 2.17 以来的版本与 linux 内核版本的兼容性：                 glibc 版本       兼容的 linux 内核版本                       2.17 ~ 2.19       &amp;gt;= 2.6.16                 2.20 ~ 2.23       &amp;gt;= 2.6.32                 2.24 ~ 2.25       运行时：x86 上要求 &amp;gt;= 2.6.32，其他架构要求 &amp;gt;= 3.2；编译时：所有架构都要求内核头文件版本 &amp;gt;= 3.2                 2.26 ~ 2.41       &amp;gt;= 3.2           glibc 在编译配置时可通过参数 --enable-kerne...</summary>

  </entry>

  
  <entry>
    <title>PostgreSQL 配置说明</title>
    <link href="http://localhost:4000/posts/postgresql-configuration/" rel="alternate" type="text/html" title="PostgreSQL 配置说明" />
    <published>2025-04-02T12:58:00+08:00</published>
  
    <updated>2025-04-02T12:58:00+08:00</updated>
  
    <id>http://localhost:4000/posts/postgresql-configuration/</id>
    <content type="text/html" src="http://localhost:4000/posts/postgresql-configuration/" />
    <author>
      <name>zhaowcheng</name>
    </author>

  
    
    <category term="PostgreSQL" />
    
  

  <summary>Preface  Write Ahead Log  synchronous_commit (enum)  设置事务提交时需要等到 WAL 被保存到何种程度才返回，下表描述了可设置的值及其说明（数据安全程度依次递减）：                 值       说明                       remote_apply       等到同步备节点回放了 WAL                 on       等到同步备节点把 WAL 写入了磁盘                 remote_write       等到同步备节点把 WAL 写入了文件系统缓存                 local       等到主节点把 WAL 写入了磁盘                 off       不等待           主节点会在 WAL 写入自己的磁盘之...</summary>

  </entry>

  
  <entry>
    <title>Patroni 配置说明</title>
    <link href="http://localhost:4000/posts/patroni-configuration/" rel="alternate" type="text/html" title="Patroni 配置说明" />
    <published>2025-03-27T18:58:00+08:00</published>
  
    <updated>2025-03-27T18:58:00+08:00</updated>
  
    <id>http://localhost:4000/posts/patroni-configuration/</id>
    <content type="text/html" src="http://localhost:4000/posts/patroni-configuration/" />
    <author>
      <name>zhaowcheng</name>
    </author>

  
    
    <category term="Patroni" />
    
  

  <summary>1 配置类型          全局配置（Global Configuration）                      作用范围：所有节点。                       修改方式：初始化（bootstrap）前，修改配置文件中的 bootstrap.dcs 部分；初始化后，通过 patronictl edit-config 命令或 REST 接口 /config 修改。                       配置项：https://patroni.readthedocs.io/en/latest/dynamic_configuration.html#dynamic-configuration                       其他说明：Patroni 官方文档中通常叫做 动态配置（dynamic configuration），初始化以后保存在 ...</summary>

  </entry>

  
  <entry>
    <title>PostgreSQL 高可用（high availability)</title>
    <link href="http://localhost:4000/posts/postgresql-high-availability/" rel="alternate" type="text/html" title="PostgreSQL 高可用（high availability)" />
    <published>2025-03-18T22:40:00+08:00</published>
  
    <updated>2025-03-18T22:40:00+08:00</updated>
  
    <id>http://localhost:4000/posts/postgresql-high-availability/</id>
    <content type="text/html" src="http://localhost:4000/posts/postgresql-high-availability/" />
    <author>
      <name>zhaowcheng</name>
    </author>

  
    
    <category term="PostgreSQL" />
    
  

  <summary>1 简介  主节点持续归档/传送 WAL，备节点持续恢复/接收 WAL 并回放（replay），以此实现一个高可用集群，这种方式叫做 log shipping，这样的备节点也叫做 warm standby，如果备节点还可以接受 只读查询，则叫做 hot standby。  PostgreSQL 支持 2 种级别的 log shipping：          文件级（file-based）：主节点配置 archive_command 持续归档 WAL 文件，备节点配置 restore_command 持续恢复 WAL 文件并回放。           记录级（record-based）： 主节点持续传送 WAL 记录，备节点持续接收 WAL 记录并回放，即 流复制（streaming replication）。      2 环境要求          硬件：主备节点之间的 CPU ...</summary>

  </entry>

</feed>


