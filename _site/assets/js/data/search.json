[ { "title": "ETCD 配置 TLS", "url": "/posts/etcd-tls/", "categories": "ETCD", "tags": "etcd, network, ssl, tls", "date": "2025-01-24 15:28:00 +0800", "snippet": "前提知识： SSL/TLS 笔记本文章演示如何在已有 ETCD 集群上同时配置开启 客户端与服务端之间（client-to-server） 和 服务端与服务端之间（server-to-server/peer） 的 TLS。建议在操作前先备份 data 目录和配置文件！已有集群信息如下：$ etcdctl member list -w table+------------------+---------+-------+---------------------------+---------------------------+------------+| ID | STATUS | NAME | PEER ADDRS | CLIENT ADDRS | IS LEARNER |+------------------+---------+-------+---------------------------+---------------------------+------------+| e36d8869dc221ffe | started | node1 | http://192.168.10.11:2380 | http://192.168.10.11:2379 | false || 243fcfa74ec0736a | started | node2 | http://192.168.10.12:2380 | http://192.168.10.12:2379 | false || c8ad351a3ef67e9e | started | node3 | http://192.168.10.13:2380 | http://192.168.10.13:2379 | false |+------------------+---------+-------+---------------------------+---------------------------+------------+生成证书使用 python 生成下面示例中使用的 python 脚本 gen_etcd_certs.py 源码在文章末尾附上。生成 根证书和私钥：$ python gen_etcd_certs.py -c gen_root_cert -s ./certs Saved: ./certs/root.keySaved: ./certs/root.cert生成 客户端证书和私钥：$ python gen_etcd_certs.py -c gen_client_cert -s ./certs -k certs/root.key -t certs/root.certSaved: ./certs/client.keySaved: ./certs/client.cert生成 节点证书和私钥：$ python gen_etcd_certs.py -c gen_server_cert -s ./certs -k certs/root.key -t certs/root.cert -i 192.168.10.11Saved: ./certs/192.168.10.11.keySaved: ./certs/192.168.10.11.cert$ python gen_etcd_certs.py -c gen_server_cert -s ./certs -k certs/root.key -t certs/root.cert -i 192.168.10.12Saved: ./certs/192.168.10.12.keySaved: ./certs/192.168.10.12.cert$ python gen_etcd_certs.py -c gen_server_cert -s ./certs -k certs/root.key -t certs/root.cert -i 192.168.10.13Saved: ./certs/192.168.10.13.keySaved: ./certs/192.168.10.13.cert使用 openssl 生成生成 根证书和私钥：$ openssl genrsa -out root.key 2048Generating RSA private key, 2048 bit long modulus.............................+++........................................+++e is 65537 (0x10001)$ openssl req -new -sha256 -key root.key -out root.csr -subj &quot;/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC/CN=CA&quot;$ openssl x509 -req -days 3650 -sha256 -signkey root.key -in root.csr -out root.certSignature oksubject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC/CN=CAGetting Private key生成 客户端证书和私钥：$ openssl genrsa -out client.key 2048Generating RSA private key, 2048 bit long modulus.........+++......+++e is 65537 (0x10001)$ openssl req -new -sha256 -key client.key -out client.csr -subj &quot;/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC&quot;$ openssl x509 -req -days 3650 -sha256 -CA root.cert -CAkey root.key -CAserial root.srl -CAcreateserial -in client.csr -out client.certSignature oksubject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWCGetting CA Private Key生成 节点证书和私钥：$ openssl genrsa -out 192.168.10.11.key 2048Generating RSA private key, 2048 bit long modulus.......................+++..................................+++e is 65537 (0x10001)$ openssl req -new -sha256 -key 192.168.10.11.key -out 192.168.10.11.csr -subj &quot;/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC&quot;$ echo &quot;subjectAltName = @names\\n[names]\\nIP.1 = 127.0.0.1\\nIP.2 = 192.168.10.11&quot; &amp;gt; 192.168.10.11.ext$ openssl x509 -req -days 3650 -sha256 -CA root.cert -CAkey root.key -CAserial root.srl -CAcreateserial -in 192.168.10.11.csr -out 192.168.10.11.cert -extfile 192.168.10.11.extSignature oksubject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWCGetting CA Private Key$ openssl genrsa -out 192.168.10.12.key 2048Generating RSA private key, 2048 bit long modulus.......................+++..................................+++e is 65537 (0x10001)$ openssl req -new -sha256 -key 192.168.10.12.key -out 192.168.10.12.csr -subj &quot;/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC&quot;$ echo &quot;subjectAltName = @names\\n[names]\\nIP.1 = 127.0.0.1\\nIP.2 = 192.168.10.12&quot; &amp;gt; 192.168.10.12.ext$ openssl x509 -req -days 3650 -sha256 -CA root.cert -CAkey root.key -CAserial root.srl -CAcreateserial -in 192.168.10.12.csr -out 192.168.10.12.cert -extfile 192.168.10.12.extSignature oksubject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWCGetting CA Private Key$ openssl genrsa -out 192.168.10.13.key 2048Generating RSA private key, 2048 bit long modulus.......................+++..................................+++e is 65537 (0x10001)$ openssl req -new -sha256 -key 192.168.10.13.key -out 192.168.10.13.csr -subj &quot;/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC&quot;$ echo &quot;subjectAltName = @names\\n[names]\\nIP.1 = 127.0.0.1\\nIP.2 = 192.168.10.13&quot; &amp;gt; 192.168.10.13.ext$ openssl x509 -req -days 3650 -sha256 -CA root.cert -CAkey root.key -CAserial root.srl -CAcreateserial -in 192.168.10.13.csr -out 192.168.10.13.cert -extfile 192.168.10.13.extSignature oksubject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWCGetting CA Private Key上传证书 节点 需要上传的文件 192.168.10.11 root.cert, root.key, client.cert, client.key, 192.168.10.11.cert, 192.168.10.11.key 192.168.10.12 root.cert, root.key, client.cert, client.key, 192.168.10.12.cert, 192.168.10.12.key 192.168.10.13 root.cert, root.key, client.cert, client.key, 192.168.10.13.cert, 192.168.10.13.key 更新配置节点 192.168.10.11 配置文件需要更新的配置：listen-peer-urls: https://0.0.0.0:2380listen-client-urls: https://0.0.0.0:2379advertise-client-urls: https://192.168.10.11:2379client-transport-security: # 服务端证书，在 TLS 握手过程中提供给客户端。 cert-file: /path/to/192.168.10.11.cert # 服务端私钥，用来解密客户端使用服务端公钥加密发送的数据。 key-file: /path/to/192.168.10.11.key # 是否要求客户端访问时提供客户端证书。 client-cert-auth: true # 受信任的 CA 证书（root 证书/根证书），用来验证客户端证书。 trusted-ca-file: /path/to/root.cert # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。 auto-tls: falsepeer-transport-security: # 本节点证书，在 TLS 握手过程中提供给伙伴节点。 cert-file: /path/to/192.168.10.11.cert # 本节点私钥，用来解密伙伴节点使用本节点公钥加密发送的数据。 key-file: /path/to/192.168.10.11.key # 是否要求伙伴节点访问时提供其证书。 client-cert-auth: true # 受信任的 CA 证书（root 证书/根证书），用来验证伙伴节点证书。 trusted-ca-file: /path/to/root.cert # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。 auto-tls: false节点 192.168.10.12 配置文件需要更新的配置：listen-peer-urls: https://0.0.0.0:2380listen-client-urls: https://0.0.0.0:2379advertise-client-urls: https://192.168.10.12:2379client-transport-security: # 服务端证书，在 TLS 握手过程中提供给客户端。 cert-file: /path/to/192.168.10.12.cert # 服务端私钥，用来解密客户端使用服务端公钥加密发送的数据。 key-file: /path/to/192.168.10.12.key # 是否要求客户端访问时提供客户端证书。 client-cert-auth: true # 受信任的 CA 证书（root 证书/根证书），用来验证客户端证书。 trusted-ca-file: /path/to/root.cert # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。 auto-tls: falsepeer-transport-security: # 本节点证书，在 TLS 握手过程中提供给伙伴节点。 cert-file: /path/to/192.168.10.12.cert # 本节点私钥，用来解密伙伴节点使用本节点公钥加密发送的数据。 key-file: /path/to/192.168.10.12.key # 是否要求伙伴节点访问时提供其证书。 client-cert-auth: true # 受信任的 CA 证书（root 证书/根证书），用来验证伙伴节点证书。 trusted-ca-file: /path/to/root.cert # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。 auto-tls: false节点 192.168.10.13 配置文件需要更新的配置：listen-peer-urls: https://0.0.0.0:2380listen-client-urls: https://0.0.0.0:2379advertise-client-urls: https://192.168.10.13:2379client-transport-security: # 服务端证书，在 TLS 握手过程中提供给客户端。 cert-file: /path/to/192.168.10.13.cert # 服务端私钥，用来解密客户端使用服务端公钥加密发送的数据。 key-file: /path/to/192.168.10.13.key # 是否要求客户端访问时提供客户端证书。 client-cert-auth: true # 受信任的 CA 证书（root 证书/根证书），用来验证客户端证书。 trusted-ca-file: /path/to/root.cert # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。 auto-tls: falsepeer-transport-security: # 本节点证书，在 TLS 握手过程中提供给伙伴节点。 cert-file: /path/to/192.168.10.13.cert # 本节点私钥，用来解密伙伴节点使用本节点公钥加密发送的数据。 key-file: /path/to/192.168.10.13.key # 是否要求伙伴节点访问时提供其证书。 client-cert-auth: true # 受信任的 CA 证书（root 证书/根证书），用来验证伙伴节点证书。 trusted-ca-file: /path/to/root.cert # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。 auto-tls: false使用 etcdclt 命令更新所有节点的 peer-urls 为 https（更新时保证所有节点都在线，如果有其他节点是不在线的，更新后这些节点需要作为新节点重新加入）：$ etcdctl member update e36d8869dc221ffe --peer-urls=&quot;https://192.168.10.11:2380&quot;Member e36d8869dc221ffe updated in cluster 77feb499f2ffa1c8$ etcdctl member update 243fcfa74ec0736a --peer-urls=&quot;https://192.168.10.12:2380&quot;Member 243fcfa74ec0736a updated in cluster 77feb499f2ffa1c8$ etcdctl member update c8ad351a3ef67e9e --peer-urls=&quot;https://192.168.10.13:2380&quot;Member c8ad351a3ef67e9e updated in cluster 77feb499f2ffa1c8重启集群先依次停止所有节点服务，然后再依次启动所有节点服务（在启动第一个节点时会一直等待第二个节点的加入，这时可以直接去启动第二个节点让其加入后，第一个节点也就启动成功了，接着继续去启动第三个节点即可），启动完成后重新查看集群信息如下：$ etcdctl --key=&quot;/path/to/client.key&quot; --cert=&quot;/path/to/client.cert&quot; --cacert=&quot;/path/to/root.cert&quot; member list -w table+------------------+---------+-------+----------------------------+----------------------------+------------+| ID | STATUS | NAME | PEER ADDRS | CLIENT ADDRS | IS LEARNER |+------------------+---------+-------+----------------------------+----------------------------+------------+| e36d8869dc221ffe | started | node1 | https://192.168.10.11:2380 | https://192.168.10.11:2379 | false || 243fcfa74ec0736a | started | node2 | https://192.168.10.12:2380 | https://192.168.10.12:2379 | false || c8ad351a3ef67e9e | started | node3 | https://192.168.10.13:2380 | https://192.168.10.13:2379 | false |+------------------+---------+-------+----------------------------+----------------------------+------------+TLS 与鉴权TLS 与鉴权（Authentication）是两个不同的功能，互不影响，不能混为一谈，已知的相互间有关联的情况只有一种：当鉴权和 client-transport-security 都开启的情况下，一个客户端使用设置了 CN 的证书 client.cert 访问服务端，且未提供用户密码时，CN 的值则被当作用户名进行鉴权，但是如果访问时提供了用户密码，则使用提供的用户进行鉴权。gen_etcd_certs.py 源码&quot;&quot;&quot;ETCD 证书生成脚本。@requirements: cryptography; python_version &amp;gt;= &#39;3.6&#39;@author: zhaowcheng@163.com@changelog: 2025-01-25(v0.1.0): 初版&quot;&quot;&quot;import osimport sysimport argparseimport datetimeimport ipaddressfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.serialization import (Encoding, PrivateFormat, NoEncryption, load_pem_private_key)from cryptography.x509 import (Name, NameAttribute, SubjectAlternativeName, CertificateBuilder, Certificate, BasicConstraints, IPAddress, load_pem_x509_certificate)from cryptography.x509.oid import NameOIDfrom cryptography.x509 import random_serial_numberVERSION = &#39;0.1.0&#39;NAMEATTRS = [ NameAttribute(NameOID.COUNTRY_NAME, &quot;CN&quot;), NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, &quot;CQ&quot;), NameAttribute(NameOID.LOCALITY_NAME, &quot;YB&quot;), NameAttribute(NameOID.ORGANIZATION_NAME, &quot;BC&quot;), NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, &quot;ZWC&quot;)]def printerr_and_exit(msg: str, rc: int = 1) -&amp;gt; None: &quot;&quot;&quot; 打印错误消息并退出。 :param msg: 消息 :param rc: 退出码。 &quot;&quot;&quot; print(f&#39;ERROR: {msg}&#39;, file=sys.stderr) exit(rc)def save_key(key: rsa.RSAPrivateKey, path: str) -&amp;gt; None: &quot;&quot;&quot; 保存私钥。 :param key: 私钥。 :param path: 保存路径。 &quot;&quot;&quot; with open(path, &#39;wb&#39;) as f: f.write(key.private_bytes( encoding=Encoding.PEM, format=PrivateFormat.TraditionalOpenSSL, encryption_algorithm=NoEncryption() )) print(f&#39;Saved: {path}&#39;)def save_cert(cert: Certificate, path: str) -&amp;gt; None: &quot;&quot;&quot; 保存证书。 :param cert: 证书。 :param path: 保存路径。 &quot;&quot;&quot; with open(path, &#39;wb&#39;) as f: f.write(cert.public_bytes(Encoding.PEM)) print(f&#39;Saved: {path}&#39;)def gen_root_cert(savedir: str, days: int) -&amp;gt; None: &quot;&quot;&quot; 生成根证书。 :param savedir: 保存目录。 :param days: 有效期（天）。 &quot;&quot;&quot; # 生成根私钥 root_private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048 ) # 生成根证书的公钥 root_public_key = root_private_key.public_key() # 生成根证书的主题 subject = issuer = Name(NAMEATTRS + [NameAttribute(NameOID.COMMON_NAME, &quot;CA&quot;)]) # 生成根证书 root_cert = CertificateBuilder( ).subject_name( subject ).issuer_name( issuer ).public_key( root_public_key ).serial_number( random_serial_number() ).not_valid_before( datetime.datetime.now(datetime.timezone.utc) ).not_valid_after( datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=days) ).add_extension( BasicConstraints(ca=True, path_length=None), critical=True ).sign(root_private_key, hashes.SHA256()) # 保存 save_key(root_private_key, os.path.join(savedir, &#39;root.key&#39;)) save_cert(root_cert, os.path.join(savedir, &#39;root.cert&#39;))def gen_client_cert( rootkey: str, rootcert: str, savedir: str, days: int, cn: str = &#39;&#39;) -&amp;gt; None: &quot;&quot;&quot; 生成客户端证书。 :param rootkey: 根私钥。 :param rootcert: 根证书。 :param savedir: 保存目录。 :param days: 有效期（天）。 :param cn: 用户名。 &quot;&quot;&quot; # 加载根私钥和证书 with open(rootkey, &#39;rb&#39;) as f: root_private_key = load_pem_private_key(f.read(), None) with open(rootcert, &#39;rb&#39;) as f: root_cert = load_pem_x509_certificate(f.read()) # 生成客户端私钥 client_private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048 ) # 生成客户端证书的公钥 client_public_key = client_private_key.public_key() # 生成客户端证书的主题 if cn: subject = Name(NAMEATTRS + [NameAttribute(NameOID.COMMON_NAME, cn)]) else: subject = Name(NAMEATTRS) # 生成客户端证书 client_cert = CertificateBuilder().subject_name( subject ).issuer_name( root_cert.subject ).public_key( client_public_key ).serial_number( random_serial_number() ).not_valid_before( datetime.datetime.now(datetime.timezone.utc) ).not_valid_after( datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=days) ).sign(root_private_key, hashes.SHA256()) # 保存 save_key(client_private_key, os.path.join(savedir, &#39;client.key&#39;)) save_cert(client_cert, os.path.join(savedir, &#39;client.cert&#39;))def gen_server_cert( rootkey: str, rootcert: str, savedir: str, days: int, ip: str) -&amp;gt; None: &quot;&quot;&quot; 生成服务端证书。 :param rootkey: 根私钥。 :param rootcert: 根证书。 :param savedir: 保存目录。 :param days: 有效期（天）。 :param ip: 服务端 ip。 &quot;&quot;&quot; # 加载根私钥和证书 with open(rootkey, &#39;rb&#39;) as f: root_private_key = load_pem_private_key(f.read(), None) with open(rootcert, &#39;rb&#39;) as f: root_cert = load_pem_x509_certificate(f.read()) # 生成服务器私钥 server_private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048 ) # 生成服务器证书的公钥 server_public_key = server_private_key.public_key() # 生成服务器证书的主题 subject = Name(NAMEATTRS) # 生成服务器证书的扩展（包括 IP SAN） san = SubjectAlternativeName([ IPAddress(ipaddress.IPv4Address(&#39;127.0.0.1&#39;)), IPAddress(ipaddress.IPv4Address(ip)) ]) # 生成服务器证书 server_cert = CertificateBuilder().subject_name( subject ).issuer_name( root_cert.subject ).public_key( server_public_key ).serial_number( random_serial_number() ).not_valid_before( datetime.datetime.now(datetime.timezone.utc) ).not_valid_after( datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=days) ).add_extension( san, critical=False ).sign(root_private_key, hashes.SHA256()) # 保存 save_key(server_private_key, os.path.join(savedir, f&#39;{ip}.key&#39;)) save_cert(server_cert, os.path.join(savedir, f&#39;{ip}.cert&#39;))def create_parser() -&amp;gt; argparse.ArgumentParser: &quot;&quot;&quot; 创建命令行参数解析器。 &quot;&quot;&quot; parser = argparse.ArgumentParser() parser.add_argument(&#39;-c&#39;, &#39;--command&#39;, required=True, choices=[&#39;gen_root_cert&#39;, &#39;gen_client_cert&#39;, &#39;gen_server_cert&#39;]) parser.add_argument(&#39;-s&#39;, &#39;--savedir&#39;, required=True, default=&#39;.&#39;, help=&#39;Save directory. [default: .]&#39;) parser.add_argument(&#39;-d&#39;, &#39;--days&#39;, type=int, default=3650, help=&#39;Certificate validity period. [default: 3650]&#39;) parser.add_argument(&#39;-n&#39;, &#39;--cn&#39;, help=&#39;Common name(only used for gen_client_cert).&#39;) parser.add_argument(&#39;-k&#39;, &#39;--root-key&#39;, required=(&#39;gen_client_cert&#39; in sys.argv or &#39;gen_server_cert&#39; in sys.argv), help=&#39;Root private key.&#39;) parser.add_argument(&#39;-t&#39;, &#39;--root-cert&#39;, required=(&#39;gen_client_cert&#39; in sys.argv or &#39;gen_server_cert&#39; in sys.argv), help=&#39;Root certificate.&#39;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, required=(&#39;gen_server_cert&#39; in sys.argv), help=&#39;Server IP.&#39;) parser.add_argument(&#39;-v&#39;, &#39;--version&#39;, action=&#39;version&#39;, version=VERSION) return parserdef main() -&amp;gt; None: &quot;&quot;&quot; 入口函数。 &quot;&quot;&quot; parser = create_parser() args = parser.parse_args() if not os.path.exists(args.savedir): printerr_and_exit(f&#39;Savedir `{args.savedir}` does not exist.&#39;) if args.command == &#39;gen_root_cert&#39;: gen_root_cert(args.savedir, args.days) elif args.command == &#39;gen_client_cert&#39;: gen_client_cert(args.root_key, args.root_cert, args.savedir, args.days, args.cn) elif args.command == &#39;gen_server_cert&#39;: gen_server_cert(args.root_key, args.root_cert, args.savedir, args.days, args.ip)if __name__ == &#39;__main__&#39;: main()参考资料 [Transport security model] : https://etcd.io/docs/v3.5/op-guide/security/" }, { "title": "SSL/TLS 笔记", "url": "/posts/ssl-notes/", "categories": "计算机网络", "tags": "network, ssl, tls", "date": "2024-12-22 14:16:00 +0800", "snippet": "密码学基础 对称加密（又称单钥加密、私钥加密、共享密钥加密）：加密和解密使用同一个密钥，常见算法有 AES 和 DES 等。 非对称加密（又称双钥加密、公钥加密）：有一对密钥，私钥和公钥，公钥加密的数据，只能用对应的私钥来解密，反之亦然，常见算法有 RSA, DSA, DH, ECDSA 等。 数字签名（Digital Signature）：本质上就是用私钥对数据的摘要（md5, sha256, ...）进行加密就生成了私钥持有人的签名，然后持有对应公钥的人可以对签名进行解密，如果能解密则证明该签名确实是由持有私钥的人签署的，然后用约定的摘要算法计算数据的摘要并与解密出的摘要对比，如果一样则证明数据没有被篡改。 数字证书（Digital Certificate）：假设 Alice 在有一对密钥 A（公钥 A-pub 和私钥 A-pri）的情况下，使用另外一对密钥 B （公钥 B-pub 和私钥 B-pri）的私钥 B-pri 对 A 密钥的公钥 A-pub 和拥有者信息进行加密就生成了可以用来证明 Alice 身份的证书 Alice-A.cert。然后 Alice 将公钥 B-pub 分发给 Bob，以后 Bob 要和 Alice 通信前先向 Alice 索要证书 Alice-A.cert，Bob 得到证书后使用公钥 B-pub 对证书进行解密，能够解密并且解密后的拥有者信息确实是 Alice 则证明对方确实是 Alice，然后就可以使用解密后得到的公钥 A-pub 加密消息发送给 Alice 了，Alice 收到消息后可以使用私钥 A-pri 对消息进行解密。 证书机构（Certificate Authority，简称 CA）：把数字证书例子中的密钥对 B 改为第三个人 Tom 拥有，并且 Alice 和 Bob 都信任 Tom，那么 Tom 就是一个证书分发机构。Tom 可以分别为 Alice 和 Bob 生成他们的证书，并且向他们提供 CA 证书（或称为根证书，即 Tom 的证书），Bob 可以使用 CA 证书验证 Alice 的证书，Alice 也可以 CA 证书验证 Bob 的证书。 SSL/TLS 简介SSL: secure socket layerTLS: transport layer security 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。 1996年，SSL 3.0版问世，得到大规模应用。 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。 目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。 TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。SSL/TLS 原理 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 参考资料 [密码学笔记] : https://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html [数字签名] : https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html [SSL/TLS协议运行机制的概述] : https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" }, { "title": "PostgreSQL 编码支持（character set/encoding)", "url": "/posts/postgresql-encoding/", "categories": "PostgreSQL", "tags": "postgresql, encoding, character-set, codeset", "date": "2024-12-22 10:23:00 +0800", "snippet": "编码支持 PostgreSQL 支持的所有编码（包括服务端和客户端）: PostgreSQL Character Sets 客户端支持表中所有编码； 服务端支持表中大部分编码； 在服务端，编码设置必须与 locale 设置 LC_CTYPE 和 LC_COLLATE 兼容： 当 locale 设置为 C 或 POSIX 时，兼容所有支持的编码； 当 locale 设置为 libc 提供程序中的任一个时，只有一个对应的编码是兼容的（有一个例外情况是在 Windows 上，UTF-8 编码兼容所有 locale 设置）； 当 locale 设置为 icu 提供程序中的任一个时，可以与服务端支持的大部分编码兼容，详情见 PostgreSQL Character Sets； 当编码设置为 SQL_ASCII 时，相当于无编码设置，且仅支持 0-127 这部分字符；编码设置 服务端： initdb 时设置整个数据库集簇的默认编码： 可通过 -E/--encoding 选项指定编码（优先级高于 locale 中的编码设置）： 如果通过该选项指定的编码与 locale 设置不兼容时，会报错； 如果未指定则自动从 locale 设置中获取： 当 locale 设置为 C 或 POSIX 时，自动设置编码为 SQL_ASCII 当 locale 设置为 libc 提供程序中的任一个时，自动设置为对应的兼容编码（有的较老的系统可能不支持）； 当 locale 设置为 icu 提供程序中的任一个时，自动设置编码为 SQL_ASCII； CREATE DATABASE 时可以指定被创建数据库的编码（覆盖 initdb 默认设置）： 只有使用 template0 作为模板时才可以，详情见 Template Databases； 客户端（以下优先级依次递增）： 读取服务端的 client_encoding 配置，该配置默认为 SQL_ASCII，即无编码，最终效果则是与服务端编码相同； 读取客户端的环境变量 PGCLIENTENCODING； 通过 SQL 或 psql 命令修改编码设置： SQL: ALTER SYSTEM SET client_encoding TO &#39;VALUE&#39;; SQL: SET client_encoding TO &#39;VALUE&#39;; SQL: SET NAMES TO &#39;VALUE&#39;; psql: \\encoding VALUE 编码查询 服务端： SQL: SELECT * FROM pg_database; psql: psql -l 或 \\l； 客户端： SQL: SHOW client_encoding; psql: \\encoding 编码转换PostgreSQL 内置支持很多不同编码之间的转换，具体哪些可以查看文档 All Built-in Character Set Conversions，或者通过 SQL 命令 SELECT * FROM pg_conversion 查看。如果内置的不能满足需求，还可以使用 SQL 命令 CREATE CONVERSION 命令创建新的转换。PostgreSQL 支持服务端和客户端之间编码的自动转换，内置支持的所有自动转换可以查看文档 Built-in Client/Server Character Set Conversions，如果一个转换被标记为默认时（CREATE DEFAULT CONVERSION），就会被用于服务端和客户端之间的编码自动化转换，当服务端和客户端之间的编码不支持转换时，则会报错。参考资料 [Character Set Support] : https://www.postgresql.org/docs/17/multibyte.html" }, { "title": "PostgreSQL 区域设置（locale）", "url": "/posts/postgresql-locale/", "categories": "PostgreSQL", "tags": "postgresql, locale", "date": "2024-12-21 17:44:00 +0800", "snippet": "locale 分类 分类 作用 LC_COLLATE 字符顺序 LC_CTYPE 字符分类（什么是一个字符？它的大写形式是否等效？） LC_MESSAGES 消息语言 LC_MONETARY 货币符号 LC_NUMERIC 数字格式 LC_TIME 日期和时间格式 locale 查询可通过 SQL 命令 SHOW LC_* 查询对应分类的 locale 设置，如：SHOW LC_COLLATE;locale 设置 分类 设置方式 LC_COLLATE initdb 时生成默认值；CREATE DATABASE 时也可以指定其他值（只有使用 template0 作为模板时才可以）；也可以使用 collation 指定某一列或某一次查询使用其他值。 LC_CTYPE 同 LC_COLLATE LC_MESSAGES initdb 时生成默认值并写入 postgresql.conf 中，后续可以随时通过修改配置来改变。 LC_MONETARY 同 LC_MESSAGES LC_NUMERIC 同 LC_MESSAGES LC_TIME 同 LC_MESSAGES initdb 的 locale 选择策略initdb 时默认从当前环境变量读取 locale 设置，以 LC_COLLATE 为例，其读取优先级如下：LC_ALL &amp;gt; LC_COLLATE &amp;gt; LANG如果以上环境变量都没有设置，则设置为 C。也可以通过 initdb 命令的相关参数来指定（优先级大于环境变量），--locale 参数为所有 locale 分类设置值，也可以为具体的分类指定值，如 --lc-collate（优先级大于 --locale）。通过 initdb 参数指定的 locale 必须是当前操作系统支持的设置，Linux 上可通过以下命令查看当前系统支持的所有 locale：locale -alocale 提供程序（provider）PostgreSQL 支持选择不同的 locale 提供程序为 LC_COLLATE 和 LC_CTYPE 分类提供支持，而其他的分类则仍然由操作系统提供支持。PostgreSQL 支持在 initdb, CREATE DATABASE 和 CREATE COLLATION 时均可选择，也就是说可以在不同的维度上进行混用。 提供程序 说明 builtin PostgreSQL 内置，仅支持 C 和 C.UTF-8。 libc 操作系统自带 C 语言库，Linux 上即为 libc 或 glibc。 icu ICU(International Components for Unicode)，需要在编译配置 PostgreSQL 时选择编译该库（默认编译，除非指定 --without-icu 选项）。 locale 格式说明 提供程序 格式 builtin 仅支持 C 和 C.UTF-8。 libc language_territory.codeset (codeset 是可选项，如 en_US.UTF-8, en_US) icu language-region (如 en-US) locale 对性能的影响使用 locale 会对数据库的性能产生一定影响，所以建议在确实需要时才设置，不需要时可设置为 C 或 POSIX。参考资料 [Locale Support] : https://www.postgresql.org/docs/17/locale.html" }, { "title": "xbot: 一个轻量、易用、可扩展的自动化测试框架", "url": "/posts/introduction-to-xbot/", "categories": "软件测试", "tags": "automation-testing", "date": "2024-07-04 10:31:00 +0800", "snippet": " NOTE: 当前文章基于 xbot-0.4.0 编写，最新信息请查看官方仓库。简介xbot 是一个 轻量、易用、可扩展 的自动化测试框架。安装使用 pip 进行安装:pip install xbot.framework安装成功后即可调用 xbot 命令:$ xbot --helpusage: xbot [-h] [-d DIRECTORY] [-b TESTBED] [-s TESTSET] [-f {verbose,brief}] [-v] {init,run}positional arguments:{init,run}optional arguments:-h, --help show this help message and exit-d DIRECTORY, --directory DIRECTORY directory to init (required by `init` command)-b TESTBED, --testbed TESTBED testbed filepath (required by `run` command)-s TESTSET, --testset TESTSET testset filepath (required by `run` command)-f {verbose,brief}, --outfmt {verbose,brief} output format (option for `run` command, options: verbose/brief, default: brief)-v, --version show program&#39;s version number and exit入门初始化工程目录:$ xbot init -d ./testprojInitialized ./testproj工程目录结构如下:./testproj├── README.md├── lib # 测试库目录│ ├── __init__.py│ ├── testbed.py # 测试床基类│ └── testcase.py # 测试用例基类├── requirements.txt├── testbeds # 测试床目录│ └── testbed_example.yml ├── testcases # 测试用例目录│ ├── __init__.py│ └── examples│ ├── __init__.py│ ├── nonpass│ │ ├── __init__.py│ │ ├── tc_eg_nonpass_error_clsname.py│ │ ├── tc_eg_nonpass_error_syntax.py│ │ ├── tc_eg_nonpass_fail_setup_with_failfast_false.py│ │ ├── tc_eg_nonpass_fail_setup_with_failfast_true.py│ │ ├── tc_eg_nonpass_fail_step_with_failfast_false.py│ │ ├── tc_eg_nonpass_fail_step_with_failfast_true.py│ │ ├── tc_eg_nonpass_skip_excluded.py│ │ ├── tc_eg_nonpass_skip_not_included.py│ │ └── tc_eg_nonpass_timeout.py│ └── pass│ ├── __init__.py│ ├── tc_eg_pass_create_dirs_and_files.py│ └── tc_eg_pass_get_values_from_testbed.py└── testsets # 测试套目录 └── testset_example.yml测试床示例(testbeds/testbed_example.yml):# Testbed is used to store the information about the test environment.# The information can be accessed by self.testbed.get() in the testcases.example: key1: value1 key2: key2-1: value2-1 key2-2: value2-2 key3: - value3-1 - value3-2 - value3-3 key4: - name: jack age: 20 - name: tom age: 30测试套示例(testsets/testset_example.yml):# Testset is used to organize testcases to be executed.tags: # `exclude` has higher priority than `include`. include: # Include testcases with these tags. - tag1 exclude: # Exclude testcases with these tags. - tag2paths: - testcases/examples/pass/tc_eg_pass_get_values_from_testbed.py - testcases/examples/pass/tc_eg_pass_create_dirs_and_files.py # Recursively include all testcases in the directory, # only match files with the prefix &#39;tc_&#39; and suffix &#39;.py&#39;. - testcases/examples/nonpass/执行测试(测试工程目录下执行命令):$ xbot run -b testbeds/testbed_example.yml -s testsets/testset_example.yml (1/11) PASS 0:00:01 tc_eg_pass_get_values_from_testbed(2/11) PASS 0:00:01 tc_eg_pass_create_dirs_and_files(3/11) ERROR 0:00:00 tc_eg_nonpass_error_clsname(4/11) ERROR 0:00:00 tc_eg_nonpass_error_syntax(5/11) FAIL 0:00:01 tc_eg_nonpass_fail_setup_with_failfast_false(6/11) FAIL 0:00:01 tc_eg_nonpass_fail_setup_with_failfast_true(7/11) FAIL 0:00:01 tc_eg_nonpass_fail_step_with_failfast_false(8/11) FAIL 0:00:01 tc_eg_nonpass_fail_step_with_failfast_true(9/11) SKIP 0:00:00 tc_eg_nonpass_skip_excluded(10/11) SKIP 0:00:00 tc_eg_nonpass_skip_not_included(11/11) TIMEOUT 0:00:03 tc_eg_nonpass_timeoutreport: /Users/wan/CodeProjects/xbot.framework/testproj/logs/testbed_example/2024-07-02_12-19-43/report.html 执行完成后会在测试工程下根据测试床名称和时间戳生成日志目录保存 html 格式的用例日志和测试报告。测试报告:用例日志:用例开发测试用例存放在工程目录的 testcases 子目录下，以下为 testcases/examples/pass/tc_eg_pass_create_dirs_and_files.py 用例内容:import osimport tempfileimport shutilfrom xbot.framework.utils import assertxfrom lib.testcase import TestCaseclass tc_eg_pass_create_dirs_and_files(TestCase): &quot;&quot;&quot; Test creating directories and files. &quot;&quot;&quot; TIMEOUT = 60 FAILFAST = True TAGS = [&#39;tag1&#39;] def setup(self): &quot;&quot;&quot; Prepare test environment. &quot;&quot;&quot; self.workdir = tempfile.mkdtemp() self.info(&#39;Created workdir: %s&#39;, self.workdir) def step1(self): &quot;&quot;&quot; Create a subdirectory &#39;dir&#39; under the temporary working directory and check if it is created successfully. &quot;&quot;&quot; self.dir1 = os.path.join(self.workdir, &#39;dir1&#39;) os.mkdir(self.dir1) assertx(os.path.exists(self.dir1), &#39;==&#39;, True) def step2(self): &quot;&quot;&quot; Create an empty file &#39;file1&#39; under &#39;dir1&#39; and check if it is created successfully. &quot;&quot;&quot; self.file1 = os.path.join(self.dir1, &#39;file1&#39;) open(self.file1, &#39;w&#39;).close() assertx(os.path.exists(self.file1), &#39;==&#39;, True) def step3(self): &quot;&quot;&quot; Write &#39;hello world&#39; to &#39;file1&#39; and check if it is written successfully. &quot;&quot;&quot; with open(self.file1, &#39;w&#39;) as f: f.write(&#39;hello world&#39;) with open(self.file1, &#39;r&#39;) as f: assertx(f.read(), &#39;==&#39;, &#39;hello world&#39;) def teardown(self): &quot;&quot;&quot; Clean up test environment. &quot;&quot;&quot; shutil.rmtree(self.workdir) self.info(&#39;Removed workdir: %s&#39;, self.workdir) self.sleep(1) 用例 必须 继承自 TestCase 基类； 用例 必须 在 setup 方法内实现预置步骤，如无具体步骤则写 pass； 用例 必须 在 teardown 方法内实现清理步骤，如无具体步骤则写 pass； 测试步骤以 step1, step2, ... 这样的方式命名，末尾数字为执行顺序； TIMEOUT 属性定义测试用例最大执行时长(单位：秒)，超过该时长将被强制结束且置结果为 TIMEOUT； FAILFAST 属性为 True 时，当某个测试步骤失败时，则会跳过后续测试步骤立即执行清理步骤； TAGS 属性定义用例 标签，可用于测试套中对待执行测试用例列表进行筛选；测试库开发测试库存放在工程目录的 lib 子目录下，根据业务开发所需测试库放入该目录下，然后在测试用例中导入使用即可。插件 Name Description xbot.plugins.ssh SSH library for xbot.framework xbot.plugins.http(planning) HTTP library for xbot.framework xbot.plugins.wui(planning) WebUI library for xbot.framework xbot.plugins.gui(planning) GUI library for xbot.framework xbot.plugins.pgsql(planning) PostgreSQL library for xbot.framework " }, { "title": "Python 进阶 - deepget 和 deepset", "url": "/posts/python-advanced-deepget-and-deepset/", "categories": "Python 进阶", "tags": "python", "date": "2023-05-17 23:16:00 +0800", "snippet": "实现类似于 deepcopy 的 3 个函数 deepget, deepset, deeppop，代码如下：#!/usr/bin/env python3.10import reimport operatorimport typing as tfrom functools import reduceT = t.TypeVar(&#39;T&#39;)def parse_deepkey(deepkey: str, sep: str = &#39;.&#39;) -&amp;gt; list: &quot;&quot;&quot; 深度路径分割 :param deepkey: 深度路径 :param sep: 分隔符 :return: 列表格式的深度路径 &amp;gt;&amp;gt;&amp;gt; parse_deepkey(&#39;a.b1&#39;) [&#39;a&#39;, &#39;b1&#39;] &amp;gt;&amp;gt;&amp;gt; parse_deepkey(&#39;a.b2[0]&#39;) [&#39;a&#39;, &#39;b2&#39;, 0] &amp;gt;&amp;gt;&amp;gt; parse_deepkey(&#39;a.b2[0].c2&#39;) [&#39;a&#39;, &#39;b2&#39;, 0, &#39;c2&#39;] &amp;gt;&amp;gt;&amp;gt; parse_deepkey(&#39;a.b2[x=1].c2&#39;) [&#39;a&#39;, &#39;b2&#39;, {&#39;x&#39;: 1}, &#39;c2&#39;] &amp;gt;&amp;gt;&amp;gt; parse_deepkey(&#39;a.b2[x=1, y=&quot;z&quot;].c2&#39;) [&#39;a&#39;, &#39;b2&#39;, {&#39;x&#39;: 1, &#39;y&#39;: &#39;z&#39;}, &#39;c2&#39;] &quot;&quot;&quot; keys = [] for k in re.split(r&#39;%s|\\[&#39; % re.escape(sep), deepkey): if k.endswith(&#39;]&#39;): k = k[:-1] if k.isdigit(): keys.append(int(k)) else: try: keys.append(eval(f&#39;dict({k})&#39;)) except SyntaxError as e: raise SyntaxError(f&#39;Invalid expr `{k}` in deepkey `{deepkey}`: {str(e)}.&#39;) else: keys.append(k) return keysdef dump_deepkey(keys: list[str | int | dict], sep: str = &#39;.&#39;) -&amp;gt; list: &quot;&quot;&quot; 深度路径合并 :param keys: 切割后的深度路径 :param sep: 分隔符 :return: 合并后的深度路径 &amp;gt;&amp;gt;&amp;gt; dump_deepkey([&#39;a&#39;, &#39;b1&#39;]) &#39;a.b1&#39; &amp;gt;&amp;gt;&amp;gt; dump_deepkey([&#39;a&#39;, &#39;b2&#39;, 0]) &#39;a.b2[0]&#39; &amp;gt;&amp;gt;&amp;gt; dump_deepkey([&#39;a&#39;, &#39;b2&#39;, 0, &#39;c2&#39;]) &#39;a.b2[0].c2&#39; &amp;gt;&amp;gt;&amp;gt; dump_deepkey([&#39;a&#39;, &#39;b2&#39;, {&#39;x&#39;: 1}, &#39;c2&#39;]) &#39;a.b2[x=1].c2&#39; &amp;gt;&amp;gt;&amp;gt; dump_deepkey([&#39;a&#39;, &#39;b2&#39;, {&#39;x&#39;: 1, &#39;y&#39;: &#39;z&#39;}, &#39;c2&#39;]) &#39;a.b2[x=1, y=&quot;z&quot;].c2&#39; &quot;&quot;&quot; normkeys = [] for key in keys: if isinstance(key, int): normkeys.append(f&#39;[{key}]&#39;) elif isinstance(key, dict): parts = [] for k, v in key.items(): if isinstance(v, (int, float)): parts.append(f&#39;{k}={v}&#39;) else: parts.append(f&#39;{k}=&quot;{v}&quot;&#39;) normkeys.append(f&#39;[{&quot;, &quot;.join(parts)}]&#39;) else: normkeys.append(key) return sep.join(normkeys).replace(&#39;.[&#39;, &#39;[&#39;)def deep_getitem(obj: object, key: t.Union[str, int, dict]) -&amp;gt; t.Any: &quot;&quot;&quot; 专为 deep* 函数设计的获取对象中的值函数。 :param obj: 对象 :param key: 键 :return: 获取到的值 &quot;&quot;&quot; if obj is None: return None if isinstance(obj, list) and isinstance(key, dict): return GetableList(obj).get(musthave=True, **key) else: return operator.getitem(obj, key)def deepget(obj: object, deepkey: str, sep: str = &#39;.&#39;) -&amp;gt; t.Any: &quot;&quot;&quot; 深度获取对象中的值 :param obj: 对象 :param deepkey: 深度路径 :param sep: 分隔符 :return: 获取到的值 &amp;gt;&amp;gt;&amp;gt; d = { ... &#39;a&#39;: { ... &#39;b1&#39;: &#39;c&#39;, ... &#39;b2&#39;: [1, 2, 3], ... &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, ... {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, ... {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}], ... &#39;b4&#39;: None ... } ... } &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b1&#39;) &#39;c&#39; &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b2[0]&#39;) 1 &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b3[0].x&#39;) 1 &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b3[x=1]&#39;) {&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;} &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b3[x=1, y=&quot;j&quot;]&#39;) {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;} &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b4[999]&#39;) == None True &amp;gt;&amp;gt;&amp;gt; deepget(d, &#39;a.b4.x&#39;) == None True &quot;&quot;&quot; keys = parse_deepkey(deepkey, sep) return reduce(deep_getitem, keys, obj)def deepset(obj: object, deepkey: str, value: any, sep: str = &#39;.&#39;) -&amp;gt; None: &quot;&quot;&quot; 深度设置对象中的值。 如果路径不存在则创建（路径中带索引的情况除外，如 a.b[0]） :param obj: 对象 :param deepkey: 深度路径 :param value: 待设置的值 :param sep: 分隔符 &amp;gt;&amp;gt;&amp;gt; from pprint import pprint &amp;gt;&amp;gt;&amp;gt; d = { ... &#39;a&#39;: { ... &#39;b1&#39;: &#39;c&#39;, ... &#39;b2&#39;: [1, 2, 3], ... &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, ... {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, ... {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}] ... } ... } &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b1&#39;, &#39;d&#39;) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [1, 2, 3], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}]}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b2[0]&#39;, &#39;-1&#39;) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}]}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;i.j&#39;, &#39;x&#39;) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b2[999]&#39;, 4) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3, 4], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b4[0].c1[0]&#39;, &#39;x&#39;) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3, 4], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}], &#39;b4&#39;: [{&#39;c1&#39;: [&#39;x&#39;]}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b3[x=1].y&#39;, &#39;k&#39;) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3, 4], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}], &#39;b4&#39;: [{&#39;c1&#39;: [&#39;x&#39;]}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b3[x=1, y=&quot;j&quot;].y&#39;, &#39;k&#39;) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3, 4], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}], &#39;b4&#39;: [{&#39;c1&#39;: [&#39;x&#39;]}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b3[x=2]&#39;, {&#39;x&#39;: 2, &#39;y&#39;: &#39;k&#39;}) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3, 4], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}], &#39;b4&#39;: [{&#39;c1&#39;: [&#39;x&#39;]}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &amp;gt;&amp;gt;&amp;gt; deepset(d, &#39;a.b3[x=8]&#39;, {&#39;x&#39;: 8, &#39;y&#39;: &#39;k&#39;}) &amp;gt;&amp;gt;&amp;gt; pprint(d) {&#39;a&#39;: {&#39;b1&#39;: &#39;d&#39;, &#39;b2&#39;: [&#39;-1&#39;, 2, 3, 4], &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 2, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 1, &#39;y&#39;: &#39;k&#39;}, {&#39;x&#39;: 8, &#39;y&#39;: &#39;k&#39;}], &#39;b4&#39;: [{&#39;c1&#39;: [&#39;x&#39;]}]}, &#39;i&#39;: {&#39;j&#39;: &#39;x&#39;}} &quot;&quot;&quot; keys = parse_deepkey(deepkey, sep) for i, k in enumerate(keys[:-1]): try: child = deep_getitem(obj, k) if child is None: v = [] if isinstance(keys[i+1], (int, dict)) else {} operator.setitem(obj, k, v) child = deep_getitem(obj, k) obj = child except KeyError: obj[k] = [] if isinstance(keys[i+1], (int, dict)) else {} obj = obj[k] except (IndexError, AttributeError): obj.append([] if isinstance(keys[i+1], (int, dict)) else {}) obj = obj[-1] if isinstance(obj, list) and isinstance(keys[-1], int) and len(obj) &amp;lt;= keys[-1]: obj.append(value) elif isinstance(obj, list) and isinstance(keys[-1], dict): v = GetableList(obj).get(musthave=False, **keys[-1]) if v is None: obj.append(value) else: obj[obj.index(v)] = value else: operator.setitem(obj, keys[-1], value)def deeppop(obj: object, deepkey: str, sep: str = &#39;.&#39;) -&amp;gt; t.Any: &quot;&quot;&quot; 深度删除对象中的值 :param obj: 对象 :param deepkey: 深度路径 :param sep: 分隔符 :return: deepkey 存在时返回删除的值，否则返回 None。 &amp;gt;&amp;gt;&amp;gt; d = { ... &#39;a&#39;: { ... &#39;b1&#39;: &#39;c&#39;, ... &#39;b2&#39;: [1, 2, 3], ... &#39;b3&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;}, ... {&#39;x&#39;: 2, &#39;y&#39;: &#39;i&#39;}, ... {&#39;x&#39;: 1, &#39;y&#39;: &#39;j&#39;}] ... } ... } &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b1&#39;) &#39;c&#39; &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b2[0]&#39;) 1 &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b2[5]&#39;) == None True &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b4&#39;) == None True &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b3[x=1]&#39;) {&#39;x&#39;: 1, &#39;y&#39;: &#39;h&#39;} &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b3[x=1, y=&quot;j&quot;].y&#39;) &#39;j&#39; &amp;gt;&amp;gt;&amp;gt; deeppop(d, &#39;a.b3[x=3]&#39;) == None True &quot;&quot;&quot; keys = parse_deepkey(deepkey, sep) if len(keys) == 1: return obj.pop(keys[0]) else: v = deepget(obj, dump_deepkey(keys[:-1], sep=sep), sep=sep) if v is not None: if isinstance(v, list): if isinstance(keys[-1], dict): r = GetableList(v).get(musthave=False, **keys[-1]) if r: v.remove(r) return r else: try: return v.pop(keys[-1]) except IndexError: return None else: return v.pop(keys[-1], None) class GetableList(t.Generic[T], list): &quot;&quot;&quot; 可自定义获取元素的列表。 &quot;&quot;&quot; def get(self, musthave=True, **attrs) -&amp;gt; t.Optional[T]: &quot;&quot;&quot; 获取第一个属性都匹配的元素，否则返回 None 或报错。 :param musthave: 如果为 True，无匹配的元素时则报错。 :param attrs: 属性名和属性值。 &amp;gt;&amp;gt;&amp;gt; class Person: ... def __init__(self, name, age): ... self.name = name ... self.age = age ... &amp;gt;&amp;gt;&amp;gt; people = GetableList[Person]([ ... Person(&quot;Alice&quot;, 30), ... Person(&quot;Bob&quot;, 25), ... Person(&quot;Bob&quot;, 26), ... Person(&quot;Charlie&quot;, 35) ... ]) &amp;gt;&amp;gt;&amp;gt; people.get(name=&#39;Bob&#39;).age 25 &amp;gt;&amp;gt;&amp;gt; people.get(name=&#39;Tom&#39;, musthave=False) == None True &quot;&quot;&quot; for e in self: for k, v in attrs.items(): if isinstance(e, dict): value = e.get(k) else: value = getattr(e, k, None) if value != v: break else: return e if musthave: raise AttributeError(f&#39;No such element: {attrs}&#39;) def gets(self, **attrs) -&amp;gt; &#39;GetableList[T]&#39;: &quot;&quot;&quot; 获取所有属性都匹配的元素。 :param attrs: 属性名和属性值。 &amp;gt;&amp;gt;&amp;gt; class Person: ... def __init__(self, name, age): ... self.name = name ... self.age = age ... &amp;gt;&amp;gt;&amp;gt; people = GetableList[Person]([ ... Person(&quot;Alice&quot;, 30), ... Person(&quot;Bob&quot;, 25), ... Person(&quot;Bob&quot;, 26), ... Person(&quot;Charlie&quot;, 35) ... ]) &amp;gt;&amp;gt;&amp;gt; people.gets(name=&#39;Bob&#39;)[0].age 25 &amp;gt;&amp;gt;&amp;gt; people.gets(name=&#39;Tom&#39;) == [] True &quot;&quot;&quot; elements = [] for e in self: for k, v in attrs.items(): if getattr(e, k) != v: break else: elements.append(e) return elements " }, { "title": "date 命令使用示例", "url": "/posts/date-examples/", "categories": "Linux 命令", "tags": "date", "date": "2022-11-28 22:24:00 +0800", "snippet": "显示显示当前日期和时间$ dateMon 28 Nov 2022 10:50:05 PM CST显示指定格式的当前日期和时间$ date +&quot;%Y-%m-%d %H:%M:%S&quot;2022-11-28 22:51:10$ date +&quot;%y-%m-%d&quot;22-11-28$ date +&quot;%s&quot; # seconds since 1970-01-01 00:00:00 UTC1669647899显示指定日期和时间$ date --date=&quot;1 day ago&quot;Sun 27 Nov 2022 10:59:30 PM CST$ date --date=&quot;1 day&quot;Tue 29 Nov 2022 10:59:33 PM CST# 年 月 日 时 分 秒 -&amp;gt; year month day hour minute second显示指定格式的指定日期和时间$ date --date=&quot;1 day ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;2022-11-27 23:02:43$ date --date=&quot;1 day&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;2022-11-29 23:02:47" }, { "title": "sed 命令使用示例", "url": "/posts/sed-examples/", "categories": "Linux 命令", "tags": "sed", "date": "2022-11-20 17:17:00 +0800", "snippet": "替换把 hello 替换为 world$ sed &#39;s/hello/world/g&#39;把第 2 到 5 行替换为一行 hello world$ sed &#39;2,5c hello world&#39;插入在第 2 行前面插入一行 hello world$ sed &#39;2i hello world&#39;在第 2 行后面插入一行 hello world$ sed &#39;2a hello world&#39;在包含 hello 行的前面插入一行 world$ sed &#39;/hello/i world&#39;在包含 hello 行的后面插入一行 world$ sed &#39;/hello/a world&#39;删除删除第 2 行$ sed &#39;2d&#39;删除第 2 到 5 行$ sed &#39;2,5d&#39;删除第 2 到最后行$ sed &#39;2,$d&#39;删除包含 hello world 的行$ sed &#39;/hello world/d&#39;删除包含 /path/to/sth 的行并使用 # 作为分隔符$sed &#39;\\#/path/to/sth#d&#39;打印打印第 2 行$ sed &#39;2p&#39;打印第 2 到 5 行$ sed &#39;2,5p&#39;打印第 2 到最后行$ sed &#39;2,$p&#39;参考资料 https://www.gnu.org/software/sed/manual/sed.html#Joining-lines https://www.twle.cn/l/yufei/man/man-basic-sed.html " }, { "title": "Linux 上 ELF 文件依赖库的查找顺序", "url": "/posts/the-searching-order-of-elf-file-deps/", "categories": "Linux 打包", "tags": "elf, ld.so, rpath", "date": "2022-10-15 13:07:00 +0800", "snippet": "Linux 上的 2 种 ELF 文件类型：可执行文件（Executable file）和 共享对象文件（Shared object file），它们在执行期间需要通过 动态库链接器（ld.so）来查找其依赖的动态库文件，然而系统中可能在不同的目录下存在相同的动态库文件，那么执行时到底链接到哪个目录下的呢，本文将描述其在不同目录间的查找顺序。如何识别 ELF 文件类型Linux 上可通过 file 命令来查询文件类型，以 64 位系统为例，可执行文件 的查询结果中将包含如下内容ELF 64-bit LSB executable共享对象文件 的查询结果中将包含以下内容：ELF 64-bit LSB shared object如何查询依赖库Linux 上可通过 ldd 命令来查询 可执行文件 或 共享对象文件 的依赖库，例如查询 ls 命令的依赖库：root@localhost:~# ldd /usr/bin/ls linux-vdso.so.1 (0x00007ffff2eff000) /$LIB/libonion.so =&amp;gt; /lib/x86_64-linux-gnu/libonion.so (0x00007fbea7a43000) libselinux.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007fbea7a05000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbea7813000) libdl.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fbea780d000) libpcre2-8.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007fbea777d000) /lib64/ld-linux-x86-64.so.2 (0x00007fbea7b70000) libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fbea775a000)依赖库查找顺序Linux 上查找依赖库是通过 ld.so 程序来完成的，其具体查找顺序如下： ELF 文件头中 DT_RPATH 字段配置的目录：该字段是可选的，需要注意的是如果 ELF 文件头中同时包含了 DT_RUNPATH 时，则 DT_RPATH 将被忽略，可通过 readelf -d FILENAME 命令来查看是否包含 DT_RPATH 和 DT_RUNPATH。 环境变量 LD_LIBRARY_PATH 中配置的目录。 ELF 文件头中 DT_RUNPATH 字段配置的目录：该字段也为可选的，需要注意的是该字段只会查找 直接依赖 而不查找 间接依赖，而 DT_RPATH 则会查找间接依赖。 文件 /etc/ld.so.cache 中包含的动态库文件列表：该文件是 ldconfig 命令将 /etc/ld.so.conf.d/ 目录下配置的目录列表中的所有动态库搜索后生成的一个缓存列表。 默认系统库目录 /lib 和 /usr/lib：64 位系统则是 /lib64 和 /usr/lib64。 rpath 中的特殊变量DT_RPATH 和 DT_RUNPATH 统称为 rpath，可以通过在编译时通过编译参数编译进去，也可以在编译后通过其他工具（如 patchelf）来添加修改。在 rpath 中有一些特殊变量及其含义如下： $ORIGIN : 表示当前 ELF 文件所在的目录。 $LIB : 表示 /lib 或 lib64 (64 位系统)。 参考资料 https://man7.org/linux/man-pages/man8/ld.so.8.html" }, { "title": "fpm: 一个跨平台且支持多种包格式的打包工具", "url": "/posts/introduction-to-fpm/", "categories": "Linux 打包", "tags": "fpm", "date": "2022-09-04 20:42:00 +0800", "snippet": "通过《一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式》和《国产操作系统和 CPU 分类》两篇文章，介绍了一种针对 Linux 上的 C/C++ 程序的简化打包数量的方式，从一次打需要适配的操作系统和 CPU 组合数量的包，简化为 CPU 架构数 * 2 的数量，那么在准备编译环境的时候也就需要准备 CPU 架构数 * 2 个。现在介绍一个打包工具 fpm ，这是一个 跨平台 且 支持多种包格式 的打包工具，通过它可以在一个系统上同时打出 rpm 和 deb 的包，这样就可以把编译环境的数量从 CPU 架构数 * 2 减少到 CPU 架构数，进一步提高打包效率。fpm 相比 rpm 和 deb 原生的打包方式更简单，且打包时间更短，下面演示使用 fpm 打包 postgresql：[root@el6-x86_64 fpm_example]# lspg9[root@el6-x86_64 fpm_examplej# ls pg9/bin include lib share[root@el6-x86_64 fpm_example]# fpm -s dir -t rpm -n postgresql -v 9.6.24 --prefix /usr/local ./pg9Created package {:path=&amp;gt;&quot;postgresql-9.6.24-1.x86_64.rpm&quot;)[root@el6-x86_64 fpm_example]# fpm -s dir -t deb -n postgresql -v 9.6.24 --prefix /usr/local ./pg9Created package {:path=&amp;gt;&quot;postgresql_9.6.24_amd64.deb&quot;)[root@el6-x86_64 fpm_example]# lspg9 postgresql-9.6.24-1.x86_64.rpm postgresql_9.6.24_and64.deb[root@el6-x86_64 fpm_example]# rpm -ivh postgresql-9.6.24-1.x86_64.rpmPreparing... ########################################### [100%] 1:postgresql ########################################### [100%][root@el6-x86_64 fpm_example]# ls /usr/local/pg9/bin include lib share[root@el6-x86_64 fpm_example]# 更多关于 fpm 的说明请参考其 官方文档" }, { "title": "国产操作系统和 CPU 分类", "url": "/posts/classification-of-chinese-os-and-cpu/", "categories": "Linux 打包", "tags": "os, cpu", "date": "2022-09-04 15:32:00 +0800", "snippet": "国产 操作系统 和 CPU 厂商数量繁多，令人眼花缭乱，如果你做一款 C/C++ 软件需要适配国产的各种操作系统和 CPU，打包时针对每一种操作系统和 CPU 的组合都要打一个包的话，那么每一次打包的数量可能会多达数十个，光是编译环境的准备都需要耗费大量的时间，这无疑是令人难以接受的。但是万变不离其宗，如果经过仔细分析的话，会发现这些操作系统和 CPU 都是从现有的体系中衍生出来的，而不是完全新生事物，比如操作系统都是基于 Linux 的，且按照系统自带的包管理软件的不同，可以分为 2 个系列，分别是使用 rpm 的 redhat 系 和使用 dpkg 的 debian 系，适用于它们的安装包格式分别是 rpm 和 deb。CPU 按照指令架构划分，则可以分为 x86_64、aarch64、mips64el、loongarch64、sw_64 这 5 类，由于叫法的不同，有的会把 x86_64 叫做 amd64，把 aarch64 叫做 arm64，其实本质上它们是一样的。按照以上这样划分，再结合我的另一篇文章《一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式》中介绍的打包方法，打包工作就可以得到极大的简化，最终就变成了每次只需要打 2 * 5 = 10 个包就可以适配所有的操作系统和 CPU。以下是我个人接触过的国产操作系统和 CPU 分类：graph LR nfs(中科方德 = NFS) --&amp;gt; rpm(redhat系) isoft(普华 = iSoft) --&amp;gt; rpm linx(凝思 = Linx) --&amp;gt; rpm nkyl(中标麒麟 = NeoKylin) --&amp;gt; rpm kyl(银河麒麟 = Kylin) -- 服务器版 --&amp;gt; rpm kyl -- 桌面版 --&amp;gt; deb(debian系) uos(统信 = UOS) --&amp;gt; deb deepin(深度 = Deepin) --&amp;gt; deb rpm --&amp;gt; os(操作系统) deb --&amp;gt; os hygon(海光 = Hygon) --&amp;gt; x86_64 zhaoxin(兆芯 = Zhaoxin) --&amp;gt; x86_64 phytium(飞腾 = Phytium) --&amp;gt; aarch64(aarch64) kunpeng(鲲鹏 = Kunpeng) --&amp;gt; aarch64 loongson(龙芯 = Loongson) -- 3000/4000系列 --&amp;gt; mips64el(mips64el) loongson -- 5000系列 --&amp;gt; loongarch64(loongarch64) sunway(申威 = Sunway) --&amp;gt; sw_64(sw_64) x86_64 --&amp;gt; cpu(CPU) aarch64 --&amp;gt; cpu mips64el --&amp;gt; cpu loongarch64 --&amp;gt; cpu sw_64 --&amp;gt; cpu" }, { "title": "一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式", "url": "/posts/a-packaging-method-with-its-own-deps/", "categories": "Linux 打包", "tags": "rpm, deb", "date": "2022-09-03 15:34:00 +0800", "snippet": "Linux 上的 C/C++ 程序编译打包后拿到 同 CPU 架构 的其他 Linux 系统上运行时，通常会由于目标系统上缺少该程序所需的库而无法运行。这个问题在一个连接上互联网的 Linux 系统上可以很容易的通过 yum 或 apt 安装缺少的依赖库来解决，但是如果是在一个无法使用 yum 和 apt 的内网系统上，则非常麻烦。本文介绍一种打包方式，让打包后的程序自带依赖库，即使在目标系统上没有该程序所需的库时，也能正常运行。步骤以下为该方式的详细步骤：第一步：编译平台的选择选择一个 libc 版本 小于等于 该程序需要适配的所有系统中 libc 版本最小的系统。比如该程序需要适配 2 个系统，这两个系统的 libc 版本分别为 2.23 和 2.28，则选择一个 libc 版本 小于等于 2.23 的系统作为编译平台。第二步：拷贝依赖库在编译完成后，打包之前，通过 ldd 命令查询该程序中所有 ELF 文件的依赖库，并将查询到的 除 libc 以外的所有依赖库拷贝到该程序的安装目录中（通常是安装目录下的 lib 目录），然后再进行打包。如果打包方式为 rpm，建议在 spec 文件中添加 AutoReqProv: no 选项。第三步(可选)：添加 RPATH在打包之前，给所有该程序中的 ELF 文件添加 RPATH 指向其自带的 lib 目录，让程序在运行时自动优先查找自己的 lib 目录中的库文件，这样程序运行时就不需要目标系统上安装有其依赖库了。添加 RPATH 需要用到另外一个工具 patchelf，可点击链接下载后进行编译安装。当然也可以不添加 RPATH，而是在使用时配置 LD_LIBRARY_PATH 环境变量指向其自带的 lib 目录达到同样的效果。示例下面以 postgresql 为例对该打包方式进行演示：第一步：编译平台的选择选择 CentOS 6 作为编译平台，其 libc 版本为 2.12：[root@el6-x86_64 ~]# ls -l /lib64/libc.so.6lrwxrwxrwx 1 root root 12 Jul 8 13:13 /lib64/libc.so.6 -&amp;gt; libc-2.12.so[root@el6-x86_64 ~]# tar xf postgresql-9.6.24.tar.gz[root@el6-x86_64 ~]# cd postgresql-9.6.24/[root@el6-x86_64 postgresql-9.6.24]# ./configure --prefix=/usr/local/pg9...[root@el6-x86_64 postgresql-9.6.24]# make -j`nproc` &amp;amp;&amp;amp; make install...[root@el6-x86_64 postgresql-9.6.24]# cd /usr/local/pg9[root@el6-x86_64 pg9]# lsbin include lib share[root@el6-x86_64 pg9]# 第二步：拷贝依赖库[root@el6-x86_64 ~]# ./copy_deps.sh /usr/local/pg9/ /usr/local/pg9/lib...Processing /lib64/libc.so.6Processing /lib64/libdl.so.2 Processing /lib64/1ibm.so.6Processing /lib64/libpthread.so.0 Processing /lib64/libreadline.so.6`/lib64/libreadline.so.6&#39; -&amp;gt; `/usr/local/pg9/1ib/libreadline.so.6&#39; Processing /lib64/1ibrt.so.1Processing/lib64/libtinfo.so.5`/lib64/libtinfo.so.5&#39; -&amp;gt; `/usr/local/pg9/1ib/libtinfo.so.5&#39; Processing /lib64/1ibz.so.1`/lib64/libz.so.1&#39; -&amp;gt; `/usr/local/pg9/1ib/libz.so.1&#39; Processing /usr/local/pg9/lib/libecpg.so.6Processing /usr/local/pg9/1ib/libpgtypes.so.3 Processing /usr/local/pg9/lib/libpq.so.5 [root@el6-x86_64 ~]# 以下为 copy_deps.sh 脚本内容：#/bin/bash -e# Copy the deps of all elf files in `ELFDIR` to `LIBDIR`.PROGNAME=$(basename $0)if [[ $# != 2 ]]; then echo &quot;Usage: $PROGNAME ELFDIR LIBDIR&quot; &amp;gt;&amp;amp;2 exit 1fiELFDIR=$1LIBDIR=$2for elf in `find $ELFDIR -type f -exec file {} + | grep ELF | cut -d: -f1`; do echo &quot;Analysing $elf&quot; ldd $elf for sopath in `ldd $elf | grep -E &#39;.+.so.* =&amp;gt; /.+.so.* \\(θx.+\\)&#39; | awk &#39;{print $3}&#39;`; do sopaths+=($sopath) donedonesopaths=(`for i in ${sopaths[*]}; do echo $i; done | sort -u`) for sopath in ${sopaths[*]}; do echo &quot;Processing $sopath&quot; soname=`basename $sopath` if [[ (! -e $LIBDIR/$soname) ]]; then if [[ `which dpkg 2&amp;gt; /dev/null` ]]; then owninfo=`dpkg -S $sopath 2&amp;gt; /dev/null ||:` else owninfo=`rpm -qf $sopath 2&amp;gt; /dev/null ||:` fi if [[ ! $owninfo =~ ^glibc|^libc6 ]]; then cp -v $sopath $LIBDIR fi fidone第三步(可选)：添加 RPATH[root@el6-x86_64 ~]# ./set_relative_rpath.sh /usr/local/pg9/ /usr/local/pg9/libSet the rpath of /usr/local/pg9/lib/libz.so.1 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libecpg_compat.so.3.8 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libreadline.so.6 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libtinfo.so.5 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libecpg.so.6.8 to $ORIGINSet the rpath of/usr/local/pg9/1ib/postgresq1/utf8_and_uhc.so to $ORIGIN/..Set the rpath of/usr/local/pg9/1ib/postgresq1/latin2_and_win1250.so to $ORIGIN/.....Set the rpath of/usr/local/pg9/bin/clusterdb to $ORIGIN/../libSet the rpath of /usr/local/pg9/bin/postgres to $ORIGIN/../1ibSet the rpath of/usr/local/pg9/bin/pg_restore to $ORIGIN/../1ibSet the rpath of/usr/local/pg9/bin/ecpg to $ORIGIN/../lib [root@el6-x86_64 ~]# 以下为 set_relative_rpath.sh 脚本内容：#/bin/bash -e# Set the rpath of all elf files in `ELFDIR` to relative paths to `LIBDIR`.PROGNAME=$(basename $0)if [[ $# != 2 ]]; then echo &quot;Usage: $PROGNAME ELFDIR LIBDIR&quot; &amp;gt;&amp;amp;2 exit 1fiELFDIR=$1LIBDIR=$2for elf in $(find $ELFDIR -type f -exec file {} + | grep ELF | cut -d: -f1); do elf_parentdir=$(dirname $elf) relative_path=$(realpath --relative-to=$elf_parentdir $LIBDIR) if [[ $relative_path == &#39;.&#39; ]]; then relative_rpath=&quot;\\$ORIGIN&quot; else relative_rpath=&quot;\\$ORIGIN/$relative_path&quot; fi if [[ $(patchelf --print-rpath $elf) != $relative_rpath ]]; then echo &quot;Set the rpath of $elf to $relative_rpath&quot; patchelf --set-rpath $relative_rpath $elf fi done第四步：验证将 Centos 6 上的 postgresql 安装目录打包:[root@el6-x86_64 ~]# cd /usr/local/[root@el6-x86_64 local]# tar cf pg9.tar ./pg9/[root@el6-x86_64 local]# lsbin doc etc games include lib lib64 libexec patchelf pg9 pg9.tar pgsql sbin share src ssl[root@el6-x86_64 local]#将打包的 postgresql 放到另外一个 Ubuntu 20 系统上，该系统 libc 版本为 2.31，验证程序是否可正常使用：root@ubt20-x86-64:~# ls -l /lib/x86_64-linux-gnu/libc.so.6lrwxrwxrwx 1 root root 12 Dec 16 2020 /lib/x86_64-linux-gnu/libc.so.6 -&amp;gt; libc-2.31.soroot@ubt20-x86-64:~# tar xf pg9.tarroot@ubt20-x86-64:~# cd pg9/root@ubt20-x86-64:~/pg9# ldd ./bin/psql linux-vdso.so.1 (0x00097ffe0ace7000) libpq.so.5 =&amp;gt; /root/pg9/./bin/../lib/libpq.so.5 (0x00007f374e68a000) libreadline.so.6 =&amp;gt; /root/pg9/./bin/../lib/libreadline.so.6 (0x0000003fd9200000) libm.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f374e52f000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f374e33d090) libpthread.so.Q =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f374e31a000) libtinfo.so.5 =&amp;gt; /root/pg9/./bin/../lib/libtinfo.so.5 (0x0000603fdaa00000) /lib64/ld-linux-x86-64.so.2 (0x00007f374e8b5000)root@ubt20-x86-64:~/pg9# ./bin/psql -Vpsql (PostgreSQL) 9.6.24root@ubt20-x86-64:~/pg9# " }, { "title": "Python 入门 - 12 - 模块和包", "url": "/posts/python-tutorial-12-modules-and-packages/", "categories": "Python 入门", "tags": "python", "date": "2022-03-10 15:16:00 +0800", "snippet": "模块（module）一个包含 Python 代码的 .py 文件就是一个 模块（module），文件名去除 .py 后缀就是 模块名，模块名也可以通过模块的 __name__ 属性获取。一个模块可以被 import 引用，也可以当作脚本直接运行，模块中的 定义 和 语句 只在被 import 或直接运行的时候 执行一次。例如现在有一个名为 fibo.py 的文件，其内容如下：def fib(n): a, b = 0, 1 while b &amp;lt; n: print(b, end=&#39; &#39;) a, b = b, a+b print()def fib2(n): result = [] a, b = 0, 1 while b &amp;lt; n: result.append(b) a, b = b, a+b return result# 被当作脚本运行时会进入该 if 分支if __name__ == &quot;__main__&quot;: import sys fib(int(sys.argv[1]))导入模块import 方式导入：&amp;gt;&amp;gt;&amp;gt; import fibo&amp;gt;&amp;gt;&amp;gt; fibo.fib(1000)1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&amp;gt;&amp;gt;&amp;gt; fibo.fib2(100)[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&amp;gt;&amp;gt;&amp;gt; fibo.__name__&#39;fibo&#39;from … import 方式导入：&amp;gt;&amp;gt;&amp;gt; from fibo import fib, fib2&amp;gt;&amp;gt;&amp;gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377&amp;gt;&amp;gt;&amp;gt; from fibo import * # 为避免名称冲突，建议尽量不要使用这种方式&amp;gt;&amp;gt;&amp;gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377以脚本方式运行模块$ python fibo.py 501 1 2 3 5 8 13 21 34内置模块（标准库）Python 解释器内置了很多的模块（即标准库），这些库提供了很多的便利性，并且单独提供了文档对这些库进行说明：https://docs.python.org/3.5/library/index.html模块搜索路径当使用 import 导入模块时，Python 搜索这个模块的路径如下： 内置模块列表 sys.path 列表，其包含如下目录（按顺序）： 包含输入脚本的目录（如果未指定输入脚本直接启动解释器则是当前目录） PYTHONPATH 环境变量中的目录 其他安装时生成的默认路径（如第三方库安装目录 site-packages） 模块缓存为了提升模块的 加载 速度，Python 在第一次 import 时会在模块文件所在目录下创建 __pycache__ 目录，并将模块编译后的字节码文件（.pyc），以 modname.version.pyc 文件名格式缓存在该目录下。例如一个模块文件名为 mymod.py，使用 CPython 3.5 在第一次加载后，会在该文件所在目录下生成路径为 __pycache__/mymod.cpython-35.pyc 的模块缓存文件，那么在下次加载该模块时，如果模块源文件（.py）没有修改（通过 .pyc 文件和对应 .py 文件的修改日期对比进行判断），则直接加载缓存的模块字节文件，如果有修改则重新生成缓存文件。如果是在命令行以脚本方式直接执行模块文件，则不会生成缓存文件。缓存模块字节文件还可以在源文件不存在的时候直接加载使用，例如删除 mymod.py 后把 mymod.cpython-35.pyc 从 __pycache__ 中拷贝到上级目录（即原 mymod.py 所在目录），并且去掉文件名中 version 字段（即改名为 mymod.pyc），然后即可直接 import mymod 并使用。这种方式可以方便进行不带源文件分发使用，Python 还提供了 compileall 标准库来进行批量编译源文件后分发使用。需要注意的是缓存模块文件仅仅提升了 加载 速度，执行速度还是和源文件执行的方式一样的。查看模块属性可以使用内置函数 dir() 查看模块中定义的所有名称：&amp;gt;&amp;gt;&amp;gt; import builtins&amp;gt;&amp;gt;&amp;gt; dir(builtins) [&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;, &#39;BlockingIOError&#39;, &#39;BrokenPipeError&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;, &#39;ChildProcessError&#39;, &#39;ConnectionAbortedError&#39;, &#39;ConnectionError&#39;, &#39;ConnectionRefusedError&#39;, &#39;ConnectionResetError&#39;, &#39;DeprecationWarning&#39;, &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;, &#39;FileExistsError&#39;, &#39;FileNotFoundError&#39;, &#39;FloatingPointError&#39;, &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;, &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;InterruptedError&#39;, &#39;IsADirectoryError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;, &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotADirectoryError&#39;, &#39;NotImplemented&#39;, &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;, &#39;PendingDeprecationWarning&#39;, &#39;PermissionError&#39;, &#39;ProcessLookupError&#39;, &#39;ReferenceError&#39;, &#39;ResourceWarning&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;, &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;, &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;TimeoutError&#39;, &#39;True&#39;, &#39;TypeError&#39;, &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;, &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;, &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;_&#39;, &#39;__build_class__&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;, &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;exit&#39;, &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;, &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;, &#39;quit&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;, &#39;zip&#39;]包（package）包的目录结构Python 中当一个目录包含一个 __init__.py 文件（可以是空文件，也可以定义名称）时，这个目录就会被当作一个 包（package），包内可以包含模块文件，也可以包含 子包，不同包内的模块名可以相同而互不冲突，这种机制可以方便对模块分类管理，例如一个处理音频文件的包目录结构如下：sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ...包的导入方式包的用户可以从包中导入单个模块，例如:import sound.effects.echo这会加载子模块 sound.effects.echo 。但引用它时必须使用它的全名。sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)导入子模块的另一种方法是from sound.effects import echo这也会加载子模块 echo ，并使其在没有包前缀的情况下可用，因此可以按如下方式使用:echo.echofilter(input, output, delay=0.7, atten=4)另一种形式是直接导入所需的函数或变量:from sound.effects.echo import echofilter同样，这也会加载子模块 echo，但这会使其函数 echofilter() 直接可用:echofilter(input, output, delay=0.7, atten=4)请注意，当使用 from package import item 时，item 可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 import 语句首先测试是否在包中定义了item，如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。相反，当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包，最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。包的 __all__ 属性包的 __init__.py 文件中可以定义一个名为 __all__ 的列表，用来列出 from package import * 时导入的模块，假如 sound/effects/__init__.py 文件中包含如下定义：__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]那么在使用 from sound.effects import * 语句时只会导入 echo、surround 和 reverse 三个子模块。如果没有定义 __all__，当使用 from sound.effects import * 语句时，实际上只导入了 effects 子包。兄弟包的导入方式在包中可以使用绝对路径导入兄弟包的模块，比如在上面的 sound 示例包中，在模块 sound.filters.vocoder 中导入 sound.effects.echo 模块的命令如下：from sound.effects import echo也可以使用相对路径导入兄弟包的模块，比如在 sound.effects.surround 模块使用相对路径导入其他模块：from . import echofrom .. import formatsfrom ..filters import equalizer请注意，相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是 __main__ ，因此用作 Python 应用程序主模块的模块必须始终使用绝对导入。参考资料 [Modules] : https://docs.python.org/3.5/tutorial/modules.html" }, { "title": "Python 入门 - 11 - 类", "url": "/posts/python-tutorial-11-classes/", "categories": "Python 入门", "tags": "python", "date": "2022-02-24 11:05:00 +0800", "snippet": "Python 类源自于 C++ 和 Modula-3 这两种语言的类机制的结合。Python 中一切皆 对象（Object），类里边又引入了 3 种对象：类对象（Class）、实例对象（Instance） 和 方法对象（Method）作用域和命名空间作用域（scope） 指的是 Python 代码中的一个文本区域，分为以下几类： 模块 类 函数命名空间（namespace） 是一个名字到对象的映射，一个作用域对应会有一个命名空间来保存该作用域中的 名称（name），Python 中按照以下顺序去查找一个名称： 最内部作用域的命名空间（包含局部名称） 最内部作用域与最近的作用域之间的 中间作用域 的命名空间（包含非全局名称 nonlocal） 当前模块的命名空间（包含全局名称 global） 内置名称模块（builtins）的命名空间命名空间是动态创建的，不同时刻创建的命名空间具有不同的生存期： 包含内置名称的命名空间（builtins）是在 Python 解释器启动时创建的，会持续到解释器退出； 模块的全局命名空间在模块被读入时创建，也会持续到解释器退出（）； 函数的本地命名空间在函数被调用时创建，当函数返回或者抛出异常时被删除（递归调用的函数每次都有自己的本地命名空间）；以下是一个作用域和命名空间的示例：def scope_test(): def do_local(): spam = &quot;local spam&quot; def do_nonlocal(): nonlocal spam spam = &quot;nonlocal spam&quot; def do_global(): global spam spam = &quot;global spam&quot; spam = &quot;test spam&quot; do_local() print(&quot;After local assignment:&quot;, spam) do_nonlocal() print(&quot;After nonlocal assignment:&quot;, spam) do_global() print(&quot;After global assignment:&quot;, spam)scope_test()print(&quot;In global scope:&quot;, spam)# 其输出内容是：&#39;&#39;&#39;After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam&#39;&#39;&#39;类定义语法格式类定义语法格式如下：class ClassName: &amp;lt;statement-1&amp;gt; . . . &amp;lt;statement-N&amp;gt;通常类定义内的语句都是 函数定义，但也可以是其他语句（如属性定义等）。在进入类定义时，将创建一个 命名空间，用于保存类中的名称。当（从结尾处）正常离开类定义时，将创建一个 类对象。类对象支持两种操作：属性引用 和 实例化。class MyClass: &quot;&quot;&quot;A simple example class&quot;&quot;&quot; i = 12345 def f(self): return &#39;hello world&#39;例如以上示例中定义的 MyClass 类，那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。类的 实例化 使用函数表示法：# 创建类的新 实例 并将此对象分配给局部变量 xx = MyClass()初始化方法类中可以定义一个 __init__() 方法，用于自定义类的初始化操作：class MyClass: def __init__(self): self.data = []__init__() 方法定义时还可以有额外的参数：&amp;gt;&amp;gt;&amp;gt; class Complex:... def __init__(self, realpart, imagpart):... self.r = realpart... self.i = imagpart...&amp;gt;&amp;gt;&amp;gt; x = Complex(3.0, -4.5)&amp;gt;&amp;gt;&amp;gt; x.r, x.i(3.0, -4.5)self 参数类中定义的方法的第一个参数固定被当作类初始化后的 实例本身，通常写作 self，可在方法中使用该变量引用其他 实例属性：class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart def get_realpart(self): return self.r def get_imagpart(self): return self.i # 也可以不定义参数，只是这样就不能在该方法中访问实例属性 r 和 i 了 def get_nothing(): return None访问限制如果类中定义的 属性（包括变量和方法） 是以 双下划线（__） 开头，并且以 最多一个下划线结尾，那么即表示该属性是 私有的（Private），不能从外部访问：&amp;gt;&amp;gt;&amp;gt; class Student(object):... def __init__(self, name, score):... self.__name = name... self.__score = score... &amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 59)&amp;gt;&amp;gt;&amp;gt; bart.__nameTraceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;实际上 Python 并没有机制严格的限制对私有属性的访问，只是简单的对私有属性进行了 改名（加上了下划线开头的类名前缀） 而已：&amp;gt;&amp;gt;&amp;gt; class Student(object):... def __init__(self, name, score):... self.__name = name... self.__score = score... &amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 59)&amp;gt;&amp;gt; # 虽然通过下面这种方式可以访问私有属性，但强烈不建议这样做&amp;gt;&amp;gt;&amp;gt; bart._Student__name&#39;Bart Simpson&#39; 双下划线开头 并且 双下划线结尾 的名称是 Python 类的一些特殊属性，比如 __name__ 表示类名，__doc__ 表示类注释，还有用于初始化实例的 __init__() 方法等，所以建议也不要自定义这样的属性：&amp;gt;&amp;gt;&amp;gt; class MyClass(object):... &quot;&quot;&quot;my class&quot;&quot;&quot;... pass...&amp;gt;&amp;gt;&amp;gt; MyClass.__name__&#39;MyClass&#39;&amp;gt;&amp;gt;&amp;gt; MyClass.__doc__&#39;my class&#39;&amp;gt;&amp;gt;&amp;gt;单下划线 开头的属性也可以直接访问，但是约定俗成的规范是这样的属性表示 保护属性，即能在子类中访问，但不建议从外部访问。数据属性 会覆盖掉同名的 方法属性，为了避免这种情况发生，建议数据属性使用名词，方法属性使用动词。类与实例类是抽象模板，实例是根据类创建出来的具体的对象，每个实例都拥有相同的方法，但各自的数据可能不同。&amp;gt;&amp;gt;&amp;gt; class Student(object):... def __init__(self, name):... self.name = name...&amp;gt;&amp;gt;&amp;gt; student1 = Student(&#39;tom&#39;)&amp;gt;&amp;gt;&amp;gt; student2 = Student(&#39;jack&#39;)&amp;gt;&amp;gt;&amp;gt; student1.name&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; student2.name&#39;jack&#39;&amp;gt;&amp;gt;&amp;gt;在类中直接定义的属性为 类属性，而绑定到实例上的属性是 实例属性，类属性是所有实例 共有 的，实例属性是每个实例 独有 的。&amp;gt;&amp;gt;&amp;gt; class Student(object):... # 类属性... clsname = &#39;Student&#39;... def __init__(self, instname):... # 实例属性... self.instname = instname...&amp;gt;&amp;gt;&amp;gt; student1 = Student(&#39;tom&#39;)&amp;gt;&amp;gt;&amp;gt; student2 = Student(&#39;jack&#39;)&amp;gt;&amp;gt;&amp;gt; student1.clsname&#39;Student&#39;&amp;gt;&amp;gt;&amp;gt; student1.instname&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; student2.clsname&#39;Student&#39;&amp;gt;&amp;gt;&amp;gt; student2.instname&#39;jack&#39;&amp;gt;&amp;gt;&amp;gt;类继承单继承单继承的语法格式如下：class DerivedClassName(BaseClassName): &amp;lt;statement-1&amp;gt; . . . &amp;lt;statement-N&amp;gt;其中 BaseClassName 叫做 DerivedClassName 的 基类，也可叫做 父类 或 超类，DerivedClassName 则叫做 BaseClassName 的 子类。通过继承的方式，子类可以拥有父类的所有属性（包括数据属性和方法属性），当引用类的属性时，搜索顺序是先搜索子类，再搜索父类，然后是父类的父类，依次往上，所以子类如果定义了和父类同名的属性，就相当于覆盖了父类的同名属性。多重继承多种继承的语法格式如下：class DerivedClassName(Base1, Base2, Base3): &amp;lt;statement-1&amp;gt; . . . &amp;lt;statement-N&amp;gt;子类 DerivedClassName 同时从父类 Base1、Base2 和 Base3 继承，这种情况下搜索一个属性的顺序是 深度优先、从左至右、同一个类只搜索一次，比如以上示例中先搜索 DerivedClassName，然后搜索 Base1，然后搜索 Base1 的父类一直搜索到顶，然后再搜索 Base2 依次到顶，依此类推。关于更详细的搜索顺序见：https://www.python.org/download/releases/2.3/mro/获取对象信息type()使用 type() 函数可以判断一个对象的类型：&amp;gt;&amp;gt;&amp;gt; type(123)&amp;lt;class &#39;int&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(&#39;hello&#39;)&amp;lt;class &#39;str&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(True)&amp;lt;class &#39;bool&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(int) # 类的类型都是 type&amp;lt;class &#39;type&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(str)&amp;lt;class &#39;type&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(bool)&amp;lt;class &#39;type&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;types 模块中定义了各种类型，可以方便直观的用于类型判断和比较：&amp;gt;&amp;gt;&amp;gt; import types&amp;gt;&amp;gt;&amp;gt; def fn():... pass...&amp;gt;&amp;gt;&amp;gt; type(fn)==types.FunctionTypeTrue&amp;gt;&amp;gt;&amp;gt; type(abs)==types.BuiltinFunctionTypeTrue&amp;gt;&amp;gt;&amp;gt; type(lambda x: x)==types.LambdaTypeTrue&amp;gt;&amp;gt;&amp;gt; type((x for x in range(10)))==types.GeneratorTypeTrueisinstance()isinstance() 函数可以判断一个实例是否为某个 类或其子类 的实例：&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;a&#39;, str)True&amp;gt;&amp;gt;&amp;gt; isinstance(123, int)True&amp;gt;&amp;gt;&amp;gt; isinstance(b&#39;a&#39;, bytes)True&amp;gt;&amp;gt;&amp;gt; isinstance([1, 2, 3], (list, tuple)) # 判断是否某些类型中的一种True&amp;gt;&amp;gt;&amp;gt; isinstance((1, 2, 3), (list, tuple))True&amp;gt;&amp;gt;&amp;gt; isinstance(True, int) # bool 是 int 的子类Trueissubclass()issubclass() 函数可以判断某个类是否是另一个类的子类：&amp;gt;&amp;gt;&amp;gt; issubclass(bool, int) # bool 是 int 的子类True&amp;gt;&amp;gt;&amp;gt; issubclass(str, int)Falsedir()dir() 函数可以获取一个对象的所有 属性 和 方法:&amp;gt;&amp;gt;&amp;gt; dir(&#39;hello&#39;)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]getattr(), setattr(), hasattr()使用 getattr(), setattr(), hasattr() 这三个函数可以操作对象的属性：&amp;gt;&amp;gt;&amp;gt; class MyObject(object):... def __init__(self):... self.x = 9... def power(self):... return self.x * self.x...&amp;gt;&amp;gt;&amp;gt; obj = MyObject()&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？True&amp;gt;&amp;gt;&amp;gt; obj.x9&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？False&amp;gt;&amp;gt;&amp;gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？True&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;19&amp;gt;&amp;gt;&amp;gt; obj.y # 获取属性&#39;y&#39;19类的一些特殊属性下面只简单介绍一些特殊属性，完整的特性属性详见：https://docs.python.org/3/reference/datamodel.html#special-method-names__iter__()如果一个类想被用于 for ... in 循环，类似 list 或 tuple 那样，就必须实现一个 __iter__() 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环。我们以斐波那契数列为例，写一个 Fib 类，可以作用于 for 循环：class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &amp;gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值现在，试试把 Fib 实例作用于 for 循环：&amp;gt;&amp;gt;&amp;gt; for n in Fib():... print(n)...11235...4636875025__len__如果想要让对象适用于 len() 函数，即像 list 或 tuple 那样，可以自定义一个 __len__() 方法：&amp;gt;&amp;gt;&amp;gt; class MyList(object):... def __init__(self, datas):... self.datas = datas... def __len__(self):... return len(self.datas)...&amp;gt;&amp;gt;&amp;gt; mylist = MyList([1, 2, 3])&amp;gt;&amp;gt;&amp;gt; len(mylist)3参考资料 [Classes] : https://docs.python.org/3.5/tutorial/classes.html [Special method names] : https://docs.python.org/3/reference/datamodel.html#special-method-names [面向对象编程] : https://www.liaoxuefeng.com/wiki/1016959663602400/1017495723838528 [面向对象高级编程] : https://www.liaoxuefeng.com/wiki/1016959663602400/1017501628721248" }, { "title": "Python 入门 - 10 - 异常", "url": "/posts/python-tutorial-10-exceptions/", "categories": "Python 入门", "tags": "python", "date": "2022-02-11 14:12:00 +0800", "snippet": "异常简介异常（Exception） 即程序执行过程中产生的预期以外的错误，例如有一个脚本 test.py，其内容如下：#!/bin/python3print(&#39;2&#39; + 2)当执行该脚本时会产生如下异常：[root@localhost ~] python3 test.py Traceback (most recent call last): File &quot;test.py&quot;, line 3, in &amp;lt;module&amp;gt; print(&#39;2&#39; + 2)TypeError: can only concatenate str (not &quot;int&quot;) to str上面打印的内容称为 异常栈，以 File 开头的那一行指明了产生异常的位置（即 test.py 的第 3 行），接下来一行即产生异常的语句（即 print(‘2’ + 2)），最后一行为异常类型以及异常消息，通过查看异常栈可以准确定位到产生异常的代码位置并进行修复。异常处理tryPython 中使用 try 语句进行异常处理，其语法定义如下：try_stmt ::= try1_stmt | try2_stmttry1_stmt ::= &quot;try&quot; &quot;:&quot; suite (&quot;except&quot; [expression [&quot;as&quot; identifier]] &quot;:&quot; suite)+ [&quot;else&quot; &quot;:&quot; suite] [&quot;finally&quot; &quot;:&quot; suite]try2_stmt ::= &quot;try&quot; &quot;:&quot; suite &quot;finally&quot; &quot;:&quot; suite以下是一个简单的示例，该示例会一直等到用户输入一个整数为止，如果输入的不是整数，就会进入到 except 子句中执行 print 打印错误提示：&amp;gt;&amp;gt;&amp;gt; while True:... try:... x = int(input(&quot;Please enter a number: &quot;))... break... except ValueError:... print(&quot;Oops! That was no valid number. Try again...&quot;)...exceptexcept 后面的异常类型可以是多个，使用圆括号括起来，表示捕获其中任一异常类型：except (RuntimeError, TypeError, NameError):except 后面也可以不接异常类型，表示捕获任意异常：except: print(&quot;Some error occurred.&quot;)except 后面还可以接一个 as 子句来保存异常实例，以便后续进行处理：except OSError as err: print(&quot;OS error: {0}&quot;.format(err))try 后面也可以同时接多个 except 子句，当发生异常时会按照顺序从上往下匹配，如果其中某个 except 子句匹配上了，后面的 except 子句就会跳过:import systry: f = open(&#39;myfile.txt&#39;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: {0}&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise当产生的异常属于某个 except 子句后面的异常类的子类时，也会被捕获，比如以下示例中由于 C 和 D 都是 B 的子类，所以最终打印结果将是 B B B：class B(Exception): passclass C(B): passclass D(C): passfor cls in [B, C, D]: try: raise cls() except B: print(&quot;B&quot;) except C: print(&quot;C&quot;) except D: print(&quot;D&quot;)else在 except 子句后面还可以接一个 else 子句（如果有多个 except，else 必须放在所有 except 后面），当没有异常发生时，才会进入到 else 子句：try: print(&#39;hello, world&#39;)except: print(&#39;error&#39;)else: print(&#39;no error&#39;)finally在 try 语句的最后（即 except 和 else 后面）还可以接一个 finally 子句，无论是否发生异常，最终都会进入 finally 子句，所以通常可以在 finally 子句中进行一些清理工作：try: print(&#39;hello, world&#39;)except: print(&#39;error&#39;)else: print(&#39;no error&#39;)finally: print(&#39;finished&#39;)抛出异常raise 语句可以主动抛出异常：&amp;gt;&amp;gt;&amp;gt; raise NameError(&#39;HiThere&#39;)Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;NameError: HiThereraise 后面可以是一个异常类或者一个异常实例，如果接的是一个异常类则相当于无参数的异常类实例：raise ValueError # 相当于 &#39;raise ValueError()&#39;在 except 子句中还可以使用不接任何参数的 raise 语句，这样表示直接将 except 捕获的异常再次原样抛出：&amp;gt;&amp;gt;&amp;gt; try:... raise NameError(&#39;HiThere&#39;)... except NameError:... print(&#39;An exception flew by!&#39;)... raise...An exception flew by!Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in &amp;lt;module&amp;gt;NameError: HiThere自定义异常Python 提供了很多了内置异常类，其继承关系如下：BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning但是用户也可以自定义异常类，自定义异常类必须直接或间接的继承自 Exception，通常一个异常类里边什么都不做，或者最多定义几个属性用于保存异常相关的信息：class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&#39;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message参考资料 [Errors and Exceptions] : https://docs.python.org/3.5/tutorial/errors.html [Exception hierarchy] : https://docs.python.org/3.5/library/exceptions.html#bltin-exceptions" }, { "title": "Python 入门 - 9 - 输入输出", "url": "/posts/python-tutorial-9-input-and-output/", "categories": "Python 入门", "tags": "python", "date": "2021-02-24 20:44:30 +0800", "snippet": "终端的输入输出inputPython 提供了一个 input 函数供终端的输入使用，当程序执行到 input 处时会暂停并等待用户输入，用户输入完成并敲击回车后才会继续执行后续的代码。input 的返回值就是读取到的用户输入内容，还可以在调用 input 时传入一个字符串参数作为等待输入的提示信息显示。## 用 var 保存用户输入内容&amp;gt;&amp;gt;&amp;gt; var = input()&#39;hello, world&#39;&amp;gt;&amp;gt;&amp;gt; var&#39;hello, world&#39;&amp;gt;&amp;gt;&amp;gt; ## 等待输入时显示提示信息&amp;gt;&amp;gt;&amp;gt; name = input(&#39;Please input your name:&#39;)Please input your name:&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; name&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; printPython 提供一个 print 函数，可用于向终端打印内容，print 函数的定义如下：print(*objects, sep=&#39; &#39;, end=&#39;\\n&#39;, file=sys.stdout, flush=False)根据定义：print 会把任意多个 object 使用 str() 方法转换为字符串，并且在多个 object 之间使用 sep 进行分割，并且在最后增加 end，sep 和 end 必须是字符串，然后将这些内容输出到 file 参数所指定的对象，file 参数指定的对象必须要有 write(string) 方法，默认 file 参数为 sys.stdout，即当前终端。## 向终端输出两个字符 a 和 b&amp;gt;&amp;gt;&amp;gt; print(&#39;a&#39;, &#39;b&#39;)a b## 向终端输出 a 和 b，并且将 a 和 b 使用 - 进行分割&amp;gt;&amp;gt;&amp;gt; print(&#39;a&#39;, &#39;b&#39;, sep=&#39;-&#39;)a-b## 向终端输出 a 和 b，并且在最后输出两个换行(\\n)&amp;gt;&amp;gt;&amp;gt; print(&#39;a&#39;, &#39;b&#39;, end=&#39;\\n\\n&#39;)a b&amp;gt;&amp;gt;&amp;gt;需要注意的是 print 函数的 sep、end、file 和 flush 参数必须使用关键字参数的方式传入(即使用 name=value 的形式)，否则会被当作待打印的 object 对象。文件的输入输出文件的输入输出即为文件的读写，Python 中文件的读写分别使用 read 和 write 函数，但是在进行文件读写前必须使用 open 函数打开文件。openopen 函数定义如下：open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)下面分别对其各参数进行说明： file 可以是表示 文件路径（相对路径或绝对路径）的字符串（string）或者字节类型（bytes）。 也可以是表示 文件描述符 的数字（Integer），如果是文件描述符，那么默认情况下当 open 返回的文件对象被关闭时，文件描述符也会同时被关闭，除非调用 open 时传入 closefd 参数为 False。 mode 由固定的字符组成的表示文件打开模式的字符串，所有可选字符模式如下： 字符 含义 r 读模式 w 写模式，如果文件已存在则清空文件内容 x 写模式，如果文件已存在则报错 a 追加写模式，如果文件已存在则从文件末尾开始写入 b 二进制模式 t 文本模式 + 更新模式（可读可写） 以上字符又可以按照如下规则进行组合： (r|w|x|a)[b|t][+] 共 3 部分组成，圆括号表示必选参数，方括号表示可选参数 第一部分为必选参数，从 r、w、x、a 中任选一个 第二部分为可选参数，从 b 和 t 中任选一个，默认为 t 第三部分也为可选参数，只有一个可选项 + 根据组合规则，最终完整的模式及含义如下： 模式 含义 r 只读模式，进行写操作会报错 w 只写模式，如果文件不存在则创建新文件，如果已存在则清空文件内容，进行读操作会报错 x 只写模式，如果文件不存在则创建新文件，如果已存在则报错，进行读操作会报错 a 追加写模式，如果文件不存在则创建新文件，如果已存在则从文件末尾开始写 r+ 读写模式，相当于对 r 模式增加了写操作 w+ 读写模式，相当于对 w 模式增加了读操作 x+ 读写模式，相当于对 x 模式增加了读操作 a+ 读写模式，相当于对 a 模式增加了读操作 rb 与 r 模式相比，不同点在于以二进制模式打开文件 wb 与 w 模式相比，不同点在于以二进制模式打开文件 xb 与 x 模式相比，不同点在于以二进制模式打开文件 ab 与 a 模式相比，不同点在于以二进制模式打开文件 rb+ 与 r+ 模式相比，不同点在于以二进制模式打开文件 wb+ 与 w+ 模式相比，不同点在于以二进制模式打开文件 xb+ 与 x+ 模式相比，不同点在于以二进制模式打开文件 ab+ 与 a+ 模式相比，不同点在于以二进制模式打开文件 rt 与 r 模式相同 wt 与 w 模式相同 xt 与 x 模式相同 at 与 a 模式相同 rt+ 与 r+ 模式相同 wt+ 与 w+ 模式相同 xt+ 与 x+ 模式相同 at+ 与 a+ 模式相同 buffering 缓存策略，可选值即含义如下： 值 含义 -1 二进制模式: 自动检测存储设备的块大小（即 io.DEFAULT_BUFFER_SIZE，通常是 4096 或 8192，单位字节），并以此作为缓存大小。 交互式文本模式: 即 isatty() 为 True 的文件对象，该情况下将缓存 一行。 其他文本模式: 与二进制模式相同。 0 不使用缓存，仅适用于二进制模式 1 缓存 一行，仅适用于文本模式 &amp;gt;1 以该值（单位字节）作为固定大小进行缓存 encoding 文件编码和解码格式，仅适用于文本模式，完整的可选编码格式列表见 standard-encodings errors 当编码或者解码文件内容出现错误时的处理方式，仅适用于文本模式，常用的处理方式如下 值 含义 strict 当出现编码错误时报 ValueError，默认值 ignore 忽略错误 完整的处理方式见 error-handlers newline 该参数控制读和写的换行符，仅适用于文本模式，可选值及其作用如下： 值 读操作时 写操作时 None ‘\\n’、’\\r’ 和 ‘\\r\\n’ 都会被当作换行符，并且统一转换为 ‘\\n’ ‘\\n’ 会被转换为当前系统默认换行符，即 os.linesep ’’ ‘\\n’、’\\r’ 和 ‘\\r\\n’ 都会被当作换行符，但是均保持原样，不做转换 对换行符保持原样，不做转换 ‘\\n’ 只有 ‘\\n’ 会被当作换行符，但是不会做转换 对换行符保持原样，不做转换 ‘\\r’ 只有 ‘\\r’ 会被当作换行符，但是不会做转换 ‘\\n’ 会被转换为 ‘\\r’ ‘\\r\\n’ 只有 ‘\\r\\n’ 会被当作换行符，但是不会做转换 ‘\\n’ 会被转换为 ‘\\r\\n’ ioopen 方法返回的所有对象都定义在 io 模块中，其类图如下：classDiagram IOBase &amp;lt;|-- RawIOBase RawIOBase &amp;lt;|-- FileIO IOBase &amp;lt;|-- BufferedIOBase BufferedIOBase &amp;lt;|-- BufferedReader BufferedIOBase &amp;lt;|-- BufferedWriter BufferedIOBase &amp;lt;|-- BufferedRWPair BufferedIOBase &amp;lt;|-- BufferedRandom BufferedIOBase &amp;lt;|-- BytesIO IOBase &amp;lt;|-- TextIOBase TextIOBase &amp;lt;|-- TextIOWrapper TextIOBase &amp;lt;|-- StringIO class IOBase{ +closed +close() +fileno() +flush() +isatty() +readable() +readline(size=-1) +readlines(hint=-1) +seek(offset[, whence]) +seekable() +tell() +truncate(size=None) +writable() +writelines(lines) } class RawIOBase{ +read(size=-1) +readall() +readinto(b) +write(b) } class FileIO{ +mode +name } class BufferedIOBase{ +raw +detach() +read(size=-1) +read1(size=-1) +readinto(b) +readinto1(b) +write(b) } class BufferedReader{ +peek([size]) +read([size]) +read1(size) } class BufferedWriter{ +flush() +write(b) } class BytesIO{ +getbuffer() +getvalue() +read1() +readinto1() } class TextIOBase{ +encoding +errors +newlines +buffer +detach() +read(size) +readline(size=-1) +seek(offset[, whence]) +tell() +write(s) } class TextIOWrapper{ +line_buffering } class StringIO{ +getvalue() }open 方法在不同模式和缓存策略下返回的文件对象类型如下： 模式 buffering == 0 buffering != 0 r N/A TextIOWrapper w N/A TextIOWrapper x N/A TextIOWrapper a N/A TextIOWrapper r+ N/A TextIOWrapper w+ N/A TextIOWrapper x+ N/A TextIOWrapper a+ N/A TextIOWrapper rb FileIO BufferedReader wb FileIO BufferedWriter xb FileIO BufferedWriter ab FileIO BufferedWriter rb+ FileIO BufferedRandom wb+ FileIO BufferedRandom xb+ FileIO BufferedRandom ab+ FileIO BufferedRandom rt 与 r 模式相同 与 r 模式相同 wt 与 w 模式相同 与 w 模式相同 xt 与 x 模式相同 与 x 模式相同 at 与 a 模式相同 与 a 模式相同 rt+ 与 r+ 模式相同 与 r+ 模式相同 wt+ 与 w+ 模式相同 与 w+ 模式相同 xt+ 与 x+ 模式相同 与 x+ 模式相同 at+ 与 a+ 模式相同 与 a+ 模式相同 文件读写示例通常文件读写的流程是先使用 open() 打开文件，然后进行读写操作，最后使用 close() 方法关闭文件：&amp;gt;&amp;gt;&amp;gt; f = open(&#39;testfile&#39;, &#39;r+&#39;)&amp;gt;&amp;gt;&amp;gt; f.read()&#39;hello&#39;&amp;gt;&amp;gt;&amp;gt; f.write(&#39;world&#39;)5&amp;gt;&amp;gt;&amp;gt; f.seek(0)0&amp;gt;&amp;gt;&amp;gt; f.read()&#39;helloworld&#39;&amp;gt;&amp;gt;&amp;gt; f.close()但是更推荐的方法是使用 with 子句来进行文件读写操作，这样在 with 结束后会自动关闭文件，避免因忘记关闭而占用文件的情况：&amp;gt;&amp;gt;&amp;gt; data = &#39;&#39;&amp;gt;&amp;gt;&amp;gt; with open(&#39;testfile&#39;) as f:... data = f.read()...&amp;gt;&amp;gt;&amp;gt; f.closedTrue&amp;gt;&amp;gt;&amp;gt; data&#39;hello&#39;参考资料 [Input and Output] : https://docs.python.org/3.5/tutorial/inputoutput.html [input] : https://docs.python.org/3.5/library/functions.html#input [print] : https://docs.python.org/3.5/library/functions.html#print [open] : https://docs.python.org/3.5/library/functions.html#open [io] : https://docs.python.org/3.5/library/io.html#i-o-base-classes" }, { "title": "Python 入门 - 8 - 函数定义", "url": "/posts/python-tutorial-8-function-definition/", "categories": "Python 入门", "tags": "python", "date": "2020-11-24 10:45:50 +0800", "snippet": "函数定义先看一个简单的函数定义的例子，以 def 语句开头，定义一个名为 add 的函数，接收两个参数 a 和 b，然后返回这两个参数的 和：&amp;gt;&amp;gt;&amp;gt; def add(a, b):... return a + b...&amp;gt;&amp;gt;&amp;gt; add(1, 2)3&amp;gt;&amp;gt;&amp;gt;在 Python 中，一个定义好的函数可以把函数名赋值给其他变量，然后通过其他变量也可以调用该函数：&amp;gt;&amp;gt;&amp;gt; def add(a, b):... return a + b...&amp;gt;&amp;gt;&amp;gt; plus = add&amp;gt;&amp;gt;&amp;gt; plus(1, 2)3&amp;gt;&amp;gt;&amp;gt;如果定义的函数体中没有明确使用 return 语句返回值，那么默认返回值是 None：&amp;gt;&amp;gt;&amp;gt; def nothing():... pass...&amp;gt;&amp;gt;&amp;gt; r = nothing()&amp;gt;&amp;gt;&amp;gt; r is NoneTrue&amp;gt;&amp;gt;&amp;gt;函数参数参数默认值定义函数时可以指定参数的默认值，调用函数时可以不给默认参数传值，不传值则会使用默认值：## 定义一个有两个参数有默认值的函数&amp;gt;&amp;gt;&amp;gt; def introduce(name, age=18, city=&#39;beijing&#39;):... print(&#39;My name is %s, I am %d years old and I am from %s&#39; % (name, age, city))...&amp;gt;&amp;gt;&amp;gt; introduce(&#39;tom&#39;) # age 和 city 都使用默认值My name is tom, I am 18 years old and I am from beijing&amp;gt;&amp;gt;&amp;gt; introduce(&#39;liubei&#39;, city=&#39;chengdu&#39;) # city 不使用默认值My name is liubei, I am 18 years old and I am from chengdu&amp;gt;&amp;gt;&amp;gt; introduce(&#39;sanmao&#39;, 30, &#39;chongqin&#39; ) # age 和 city 都不使用默认值My name is sanmao, I am 30 years old and I am from chongqin&amp;gt;&amp;gt;&amp;gt;需要注意的是如果参数默认值使用变量的话，那在函数定义时值就已经确定了，即使后面再改变变量的值不会影响参数的默认值：&amp;gt;&amp;gt;&amp;gt; i = 5&amp;gt;&amp;gt;&amp;gt; def f(arg=i):... print(arg)...&amp;gt;&amp;gt;&amp;gt; f()5&amp;gt;&amp;gt;&amp;gt; i = 6&amp;gt;&amp;gt;&amp;gt; f() # i 已经变为 6，但是 arg 参数的默认值仍然是 55&amp;gt;&amp;gt;&amp;gt;如果参数默认值是一个可变类型的话，可能会有一些意想不到的结果：&amp;gt;&amp;gt;&amp;gt; def f(a, L=[]):... L.append(a)... return L...&amp;gt;&amp;gt;&amp;gt; print(f(1))[1]&amp;gt;&amp;gt;&amp;gt; print(f(2))[1, 2]&amp;gt;&amp;gt;&amp;gt; print(f(3)) # 因为 L 是对一个列表的引用，多次调用都是操作的同一个列表[1, 2, 3]&amp;gt;&amp;gt;&amp;gt;## 如果想要避免上面的情况，应该像下面这样写&amp;gt;&amp;gt;&amp;gt; def f(a, L=None):... if L is None:... L = []... L.append(a)... return L...&amp;gt;&amp;gt;&amp;gt; print(f(1))[1]&amp;gt;&amp;gt;&amp;gt; print(f(2))[2]&amp;gt;&amp;gt;&amp;gt; print(f(3))[3]&amp;gt;&amp;gt;&amp;gt;*args 和 **kwargs有两种比较特殊的形式 *args 和 **kwargs 在函数定义和其他情况下使用时有着不同的作用，在函数定义时使用，相当于定义了个数不确定的参数：## 此函数的 nums 相当于是一个序列&amp;gt;&amp;gt;&amp;gt; def sum(*nums):... s = 0... for i in nums:... s += i... return s...## 调用时可以传入任意多个位置参数（按位置传入的参数即为位置参数）&amp;gt;&amp;gt;&amp;gt; sum(1) 1&amp;gt;&amp;gt;&amp;gt; sum(1, 2)3&amp;gt;&amp;gt;&amp;gt; sum(1, 2, 3)6&amp;gt;&amp;gt;&amp;gt; sum() 0&amp;gt;&amp;gt;&amp;gt;## 此函数的 kwargs 相当于一个字典&amp;gt;&amp;gt;&amp;gt; def fun(**kwargs):... for k, v in kwargs.items():... print(&#39;%s: %s&#39; % (k, v))...## 调用时可以传入任意多个关键字参数（以 name=value 形式传入的参数即为关键字参数）&amp;gt;&amp;gt;&amp;gt; fun(name=&#39;tom&#39;, age=18, city=&#39;beijing&#39;)name: tomage: 18city: beijing&amp;gt;&amp;gt;&amp;gt; fun()&amp;gt;&amp;gt;&amp;gt;当 *args 和 **kwargs 在其他地方使用时，其作用相当于对一个序列和字典进行 解包 操作：&amp;gt;&amp;gt;&amp;gt; def add(a, b):... return a + b...&amp;gt;&amp;gt;&amp;gt; nums = [1, 2]&amp;gt;&amp;gt;&amp;gt; add(*nums) # 函数调用时在 nums 前面加 * 相当于解包 nums3&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; def introduce(name, age):... print(&#39;My name is %s, I am %d years old.&#39; % (name, age))...&amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 18}&amp;gt;&amp;gt;&amp;gt; introduce(**d) # 函数调用时在字典 d 前面加 ** 相当于解包 dMy name is tom, I am 18 years old.&amp;gt;&amp;gt;&amp;gt;匿名函数（lambda）Python 中运行使用 lambda 语句定义一个匿名函数，通常用在只需要一行代码即可完成定义的函数：## 以下使用 lambda 定义一个匿名函数，函数有两个参数 a 和 b，函数体返回 a + b&amp;gt;&amp;gt;&amp;gt; add = lambda a, b: a + b&amp;gt;&amp;gt;&amp;gt; add(1, 2)3&amp;gt;&amp;gt;&amp;gt;函数文档字符串（docstr）定义函数时可以在文档字符串中对函数进行简介或详细说明，同时文档字符串还可以方便其他文档生成工具自动生成代码的函数说明文档。文档字符串在函数定义 def 语句的下一行开始写，以三个双引号（&quot;&quot;&quot;）进行包裹，可以是一行或多行：## 只有一行文档字符串进行简要介绍def add(a, b): &quot;&quot;&quot;This is an add function.&quot;&quot;&quot; return a + b## 多行文档字符串对函数进行详细说明def add(a, b): &quot;&quot;&quot;This is an add function. :param a: number a :type a: int :param b: number b :type b: int :return: The sum of a and b. &quot;&quot;&quot; return a + b函数注解（Function Annotations）从 Python3 开始支持定义函数时使用 注解 方式说明参数和返回值类型：## 使用注解说明参数 a, b 和返回值类型都是 int&amp;gt;&amp;gt;&amp;gt; def add(a: int, b: int) -&amp;gt; int:... return a + b...&amp;gt;&amp;gt;&amp;gt; add(1, 2)3&amp;gt;&amp;gt;&amp;gt;更多关于函数注解说明可以参考 PEP 484参考资料 [Defining Functions] : https://docs.python.org/3.5/tutorial/controlflow.html#defining-functions [More on Defining Functions] : https://docs.python.org/3.5/tutorial/controlflow.html#more-on-defining-functions [Function definitions] : https://docs.python.org/3.5/reference/compound_stmts.html#function-definitions [PEP 484] : https://www.python.org/dev/peps/pep-0484/" }, { "title": "Python 入门 - 7 - 流程控制", "url": "/posts/python-tutorial-7-flow-control/", "categories": "Python 入门", "tags": "python", "date": "2020-10-18 15:58:25 +0800", "snippet": "ifif 是条件控制语句，其语法定义如下：if_stmt ::= &quot;if&quot; expression &quot;:&quot; suite ( &quot;elif&quot; expression &quot;:&quot; suite )* [&quot;else&quot; &quot;:&quot; suite]if 是固定格式，当 if 后面的 expression 为 真 时执行其后面的 suite，然后可以在后面接 0 或任意多个 elif 语句，最后一条 else 语句为 可选。&amp;gt;&amp;gt;&amp;gt; x = 8&amp;gt;&amp;gt;&amp;gt; if x &amp;lt; 0:... print(&#39;negative&#39;)... elif x == 0:... print(&#39;zero&#39;)... else:... print(&#39;positive&#39;)... positive&amp;gt;&amp;gt;&amp;gt; Python 中没有像 C 语言的 switch...case 这样的结构，因为使用 elif 就能达到这样的效果。真值计算对于 if 语句后面的表达式 expression 的计算结果，除了以下几种情况为 假 之外，其他情况均为 真： None False 数字类型零：0, 0.0, 0j 空序列：&#39;&#39;, (), [] 空字典：{} 如果是用户自定义类，然后实现了 __bool__ 或 __len__ 方法，并且其返回结果为 False 或者 0，那么也被当作 假## None&amp;gt;&amp;gt;&amp;gt; if None:... print(&#39;should not print&#39;)... else:... print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt; ## 整数0&amp;gt;&amp;gt;&amp;gt; if 0:... print(&#39;should not print&#39;)... else:... print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt;## 空字符串&amp;gt;&amp;gt;&amp;gt; if &#39;&#39;:... print(&#39;should not print&#39;)... else:... print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt; ## 空字典&amp;gt;&amp;gt;&amp;gt; if {}:... print(&#39;should not print&#39;)... else:... print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt; 布尔运算符有时在 if 后面的 expression 中会是一个由 布尔运算符 连接多个部分所组成的表达式，比如：&amp;gt;&amp;gt;&amp;gt; p = &#39;/home/user1/&#39;&amp;gt;&amp;gt;&amp;gt; if p.startswith(&#39;/&#39;) and p.endswith(&#39;/&#39;):... print(&#39;The absolute path of a directory&#39;)... The absolute path of a directory&amp;gt;&amp;gt;&amp;gt; 对于包含 布尔运算符 的表达式的真假值判断遵循以下规范： 操作符 结果 x or y 如果 x 为假，则结果为 y，否则为 x x and y 如果 x 为假，则结果为 x，否则为 y not x 如果 x 为假，则结果为 True，否则为 False (1) or 是一个 短路运算符，只有当 x 为 假 时才会计算 y。(2) and 也是一个 短路运算符，只有当 x 为 真 时才会计算 y。(3) 这 3 个布尔运算符的优先级关系为：not &amp;gt; and &amp;gt; or&amp;gt;&amp;gt;&amp;gt; 1 or 21&amp;gt;&amp;gt;&amp;gt; 0 or 22&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; 1 and 22&amp;gt;&amp;gt;&amp;gt; 0 and 10比较运算符比较运算符也常用于 if 后面的 expression 表达式，比较运算符总是返回 bool 类型的结果，即 True 或 Flase，所有比较运算符如下： 运算符 说明 &amp;lt; 小于 &amp;lt;= 小于等于 &amp;gt; 大于 &amp;gt;= 大于等于 == 等于 != 不等于 is 判断是否是某个对象 is not 判断是否不是某个对象 forfor 语句的定义如下：for_stmt ::= &quot;for&quot; target_list &quot;in&quot; expression_list &quot;:&quot; suite [&quot;else&quot; &quot;:&quot; suite]Python 中的 for 循环只有 for...in 的形式，它遍历序列 expression_list，每次遍历取出的元素赋值给 target_list，第一个 suite 是循环体，然后还可以使用一个 else 子句，else 只有在 for 循环正常结束之后才会执行，如果在 for 循环中被 break 打断了，则会跳过 else 子句。## 遍历一个 list&amp;gt;&amp;gt;&amp;gt; for c in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]:... print(c)... abc&amp;gt;&amp;gt;&amp;gt; ## 如果想要类似 C 语言中的 for 循环，可以使用 range## 关于 range 的详细说明可参考前面《列表与元组》章节&amp;gt;&amp;gt;&amp;gt; for i in range(5):... print(i)... 01234&amp;gt;&amp;gt;&amp;gt; ## 如果使用了 else 子句，那么会在循环正常结束后再执行 else 子句&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; for i in (1, 2, 3):... sum += i... else:... print(&#39;sum = %d&#39; % sum)... sum = 6&amp;gt;&amp;gt;&amp;gt; ## 如果 for 循环体中使用了 break，那么则不会执行 else 子句&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; for i in (1, 2, 3):... sum += i... if i == 2:... break... else:... print(&#39;sum = %d&#39; % sum)... &amp;gt;&amp;gt;&amp;gt; print(sum)3&amp;gt;&amp;gt;&amp;gt; 如果需要在 for 循环时同时取序列中元素的下标和值，可以使用 enumerate 函数：&amp;gt;&amp;gt;&amp;gt; for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):... print(i, v)...0 tic1 tac2 toe如果需要在 for 循环遍历一个序列的同时修改该序列，建议是对该序列做一个拷贝然后再遍历该拷贝，如果不用拷贝的方式，直接在遍历该序列的同时修改该序列，可能会出现一些不可意料的情况：## 想要去除 nums 中的偶数&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 4, 3]&amp;gt;&amp;gt;&amp;gt; for n in nums:... if n % 2 == 0:... nums.remove(n)... &amp;gt;&amp;gt;&amp;gt; nums## python 在循环时内部会有一个计数器记录当前循环下标(从 0 开始)，并且每次自动加 1## 所以当循环到元素 2 时，记录的当前下标为 1，然后判断 2 为偶数并移除了它，然后后面## 的元素依次往前挪一位，当进入下一次循环时自动取下标为 2 的元素，则取到了元素 3，这## 样就把元素 4 给漏掉了。[1, 4, 3]&amp;gt;&amp;gt;&amp;gt; ## 这种情况一般建议拷贝一份序列后再对其进行遍历&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 4, 3]&amp;gt;&amp;gt;&amp;gt; for n in nums.copy():... if n % 2 == 0:... nums.remove(n)... &amp;gt;&amp;gt;&amp;gt; nums[1, 3]&amp;gt;&amp;gt;&amp;gt;## 还可以使用切片方式 nums[:] 创建一个拷贝，比 copy 的方式更简洁&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 4, 3]&amp;gt;&amp;gt;&amp;gt; for n in nums[:]:... if n % 2 == 0:... nums.remove(n)... &amp;gt;&amp;gt;&amp;gt; nums[1, 3]&amp;gt;&amp;gt;&amp;gt; 使用 for 循环对字典遍历时默认遍历其 key，但是也可以使用字典的 .items() 方法同时遍历其 key 和 value，或者使用字典的 .values() 方法只遍历其 value：## 遍历字典的 key&amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 18}&amp;gt;&amp;gt;&amp;gt; for k in d:... print(k)... nameage&amp;gt;&amp;gt;&amp;gt; ## 同时遍历 key 和 value&amp;gt;&amp;gt;&amp;gt; for k, v in d.items():... print(k, v)... name tomage 18&amp;gt;&amp;gt;&amp;gt; ## 只遍历 value&amp;gt;&amp;gt;&amp;gt; for v in d.values():... print(v)... tom18&amp;gt;&amp;gt;&amp;gt; 如果需要使用 for 循环同时遍历多个长度相同的序列时可以使用 zip 函数：## 同时遍历 2 个序列&amp;gt;&amp;gt;&amp;gt; keys = [&#39;name&#39;, &#39;age&#39;]&amp;gt;&amp;gt;&amp;gt; values = [&#39;tom&#39;, 18]&amp;gt;&amp;gt;&amp;gt; for k, v in zip(keys, values):... print(k, v)... name tomage 18&amp;gt;&amp;gt;&amp;gt; ## 同时遍历 3 个序列&amp;gt;&amp;gt;&amp;gt; for i, j, k in zip([1, 2], [3, 4], [5, 6]):... print(i, j, k)... 1 3 52 4 6&amp;gt;&amp;gt;&amp;gt; 如果需要使用 for 循环反向遍历一个序列时，可以使用 reversed 函数：&amp;gt;&amp;gt;&amp;gt; for i in reversed([1, 2, 3]):... print(i)... 321&amp;gt;&amp;gt;&amp;gt; whilewhile 语句的定义如下：while_stmt ::= &quot;while&quot; expression &quot;:&quot; suite [&quot;else&quot; &quot;:&quot; suite]当表达式 expression 为 真 时执行 suite，后边还可以跟一个可选的 else 子句，当表达式 expression 为 假 时执行 else 子句中的 suite，如果在第一个 suite 中执行了 break，则退出循环，并且不会执行 else 子句。## 使用 while 循环计算 1 ~ 10 的和&amp;gt;&amp;gt;&amp;gt; i = 1&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:... sum += i... i += 1... &amp;gt;&amp;gt;&amp;gt; sum55&amp;gt;&amp;gt;&amp;gt; ## else 子句在 while 的 expression 为假时执行&amp;gt;&amp;gt;&amp;gt; i = 1&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:... sum += i... i += 1... else:... print(&#39;loops over&#39;)... loops over&amp;gt;&amp;gt;&amp;gt; sum55## while 的循环体中执行了 break，所以子句 else 被跳过不执行&amp;gt;&amp;gt;&amp;gt; i = 1&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:... sum += i... i += 1... if i == 9:... break... else:... print(&#39;loop over&#39;)... &amp;gt;&amp;gt;&amp;gt; sum36&amp;gt;&amp;gt;&amp;gt; breakbreak 语句用于 for 或者 while 循环体中，执行后直接退出循环，并且不会执行循环的 else 子句，具体示例请见上面的 for 和 while 小节内容，这里不再重复举例。continuecontinue 语句用在 for 或者 while 循环体中，跳过本次循环中后续的内容，然后进入下一次循环，它不会结束整个循环，并且不影响循环的 else 子句。## 使用 continue 跳过 for 循环中偶数的打印步骤，并且不会影响到 else 子句&amp;gt;&amp;gt;&amp;gt; for i in range(1, 11):... if i % 2 == 0:... continue... print(i)... else:... print(&#39;loops over&#39;)... 13579loops over&amp;gt;&amp;gt;&amp;gt; ## 使用 continue 跳过 while 循环中偶数的打印步骤，并且不会影响到 else 子句&amp;gt;&amp;gt;&amp;gt; i = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:... i += 1... if i % 2 == 0:... continue... print(i)... else:... print(&#39;loops over&#39;)... 1357911loops over&amp;gt;&amp;gt;&amp;gt; passpass 语句不做任何事情，通常用于一些在语法上需要写内容，但是实际没有内容可写的情况下进行占位。## 自定义异常类class MyException(Exception): pass## 先定好函数名，函数体还需进一步思考后编写def myfun(): pass参考资料 [More Control Flow Tools] : https://docs.python.org/3.5/tutorial/controlflow.html [Truth Value Testing] : https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing [Boolean Operations] : https://docs.python.org/3.5/library/stdtypes.html#boolean-operations-and-or-not [Comparisons] : https://docs.python.org/3.5/library/stdtypes.html#comparisons [The if statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-if-statement [The while statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-while-statement [The for statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-for-statement" }, { "title": "Python 入门 - 6 - 字典与集合", "url": "/posts/python-tutorial-6-dict-and-set/", "categories": "Python 入门", "tags": "python", "date": "2020-08-06 10:31:58 +0800", "snippet": "字典（dict）字典通过 键值对(key: value) 的方式，把 key 映射到 value。key 必须是 可 hash 的(hashable)，由于 Python 中所有内置的 不可变类型(immutable) 都是可 hash 的，所以都可用作字典的 key，比如 字符串(str)、数字(int, float) 和 只包含不可变类型元素的元组(tuple)，如果元组直接或间接的包含了 可变类型 的元素，也不能作为字典的 key。value 则可以是任意类型。字典中元素是无序的，并不会按照插入的顺序排列，可能会是任意的顺序，如果想要有序的字典，可以使用 collections.OrderedDict。但是从 Python 3.7 开始，字典默认是按照插入顺序排序的了。字典创建创建一个字典可以通过以下 3 种方式： 大括号 {} 方式： &amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;lilei&#39;, &#39;age&#39;: 18} &amp;gt;&amp;gt;&amp;gt; d {&#39;age&#39;: 18, &#39;name&#39;: &#39;lilei&#39;} dict 关键字方式： dict 的定义如下： class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg) 根据定义 dict 接受如下形式的参数进行初始化： &amp;gt;&amp;gt;&amp;gt; dict(one=1, two=2) # 关键字参数形式(**kwargs) {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; dict({&#39;one&#39;: 1, &#39;two&#39;: 2}) # 字典形式(mapping) {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; dict([(&#39;one&#39;, 1), [&#39;two&#39;, 2]]) # 可迭代类型中内嵌2个元素的可迭代类型(iterable) {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; dict({&#39;one&#39;: 1}, two=2) # 字典+关键字参数形式(mapping + **kwargs) {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; dict([(&#39;one&#39;, 1)], two=2) # 可迭代类型+关键字参数形式(iterable + **kwargs) {&#39;one&#39;: 1, &#39;two&#39;: 2} 字典推导式(dict comprehension)： &amp;gt;&amp;gt;&amp;gt; {x: x**2 for x in (2, 4, 6)} {2: 4, 4: 16, 6: 36} 字典操作 len(d) 返回字典 d 的长度，即包含多少个键值对 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; len(d) 2 d[key] 返回 key 对应的 value，如果 key 不存在，则抛出 KeyError 异常 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d[&#39;one&#39;] 1 &amp;gt;&amp;gt;&amp;gt; d[&#39;three&#39;] Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; KeyError: &#39;three&#39; d[key] = value 设置 key 对应的 value，如果 key 不存在则自动添加 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d[&#39;two&#39;] = 2.0 &amp;gt;&amp;gt;&amp;gt; d[&#39;three&#39;] = 3 &amp;gt;&amp;gt;&amp;gt; d {&#39;one&#39;: 1, &#39;two&#39;: 2.0, &#39;three&#39;: 3} del d[key] 删除 key 对应的项，如果 key 不存在则抛出 KeyError 异常 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; del d[&#39;two&#39;] &amp;gt;&amp;gt;&amp;gt; d {&#39;one&#39;: 1} pop(key[, default]) 删除 key 对应的项并且返回对应的 value，如果 key 不存在并且传入了 default 参数，那么返回 default，否则抛出 KeyError 异常 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d.pop(&#39;two&#39;) 2 &amp;gt;&amp;gt;&amp;gt; d.pop(&#39;three&#39;, 0) # 不存在 key 为 &#39;three&#39; 的项则返回 0 0 &amp;gt;&amp;gt;&amp;gt; d {&#39;one&#39;: 1} popitem() 任意删除并返回一个项，由于字典是无序的，所以删除的项是不确定的 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d.popitem() (&#39;one&#39;, 1) &amp;gt;&amp;gt;&amp;gt; d {&#39;two&#39;: 2} 从 Python 3.7 开始字典是有序的（按照插入顺序排序），所以 popitem() 会按照 LIFO 规则删除，即相当于删除最后一个项 key in d 如果 key 存在于字典 d 中，则返回 True，否则返回 False &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; &#39;one&#39; in d True &amp;gt;&amp;gt;&amp;gt; &#39;three&#39; in d False key not in d 如果 key 不存在于字典 d 中，则返回 True，否则返回 False &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; &#39;one&#39; not in d False &amp;gt;&amp;gt;&amp;gt; &#39;three&#39; not in d True iter(d) 返回一个包含字典 d 的所有 key 的迭代器（iterator） &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; for k in iter(d): ... print(k) ... one two clear() 清空字典 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d.clear() &amp;gt;&amp;gt;&amp;gt; d {} copy() 返回字典的 浅拷贝，关于 浅拷贝 与 深拷贝 可以参考 《列表与元组》 章节 &amp;gt;&amp;gt;&amp;gt; d1 = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d2 = d1.copy() &amp;gt;&amp;gt;&amp;gt; d2 {&#39;one&#39;: 1, &#39;two&#39;: 2} classmethod fromkeys(seq[, value]) 返回一个新的字典，字典的 keys 来自参数 seq，并且所有 key 的 value 为参数 value，value 参数默认值为 None。 这是一个 类方法，用于以其他形式创建字典。 &amp;gt;&amp;gt;&amp;gt; dict.fromkeys([&#39;three&#39;, &#39;four&#39;]) {&#39;four&#39;: None, &#39;three&#39;: None} &amp;gt;&amp;gt;&amp;gt; dict.fromkeys([&#39;three&#39;, &#39;four&#39;], 0) # 初始值为 0 {&#39;four&#39;: 0, &#39;three&#39;: 0} &amp;gt;&amp;gt;&amp;gt; get(key[, default]) 返回 key 对应的 value，如果 key 不存在则返回 default，default 默认为 None &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d.get(&#39;one&#39;) 1 &amp;gt;&amp;gt;&amp;gt; d.get(&#39;three&#39;, 0) # 不存在则返回 0 0 items() 返回一个包含所有项的 字典视图(view)，每一项是一个 2 个元素的 tuple，分别为 key 和 value &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; for k, v in d.items(): ... print(&#39;%s = %s&#39; % (k, v)) ... one = 1 two = 2 keys() 返回一个包含所有 key 的 字典视图(view) &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; for k in d.keys(): ... print(k) ... one two values() 返回一个包含所有 value 的 字典视图(view) &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; for v in d.values(): ... print(v) ... 1 2 setdefault(key[, default]) 如果 key 存在于字典中，则返回其对应的 value，否则插入 key ，并且将其 value 设置为 default，default 默认为 None &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d.setdefault(&#39;two&#39;) 2 &amp;gt;&amp;gt;&amp;gt; d.setdefault(&#39;three&#39;, 3) 3 &amp;gt;&amp;gt;&amp;gt; d {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} update([other]) 更新字典中的项，可接受参数类型与 dict 关键字一样 &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2} &amp;gt;&amp;gt;&amp;gt; d.update({&#39;two&#39;: 2.0, &#39;three&#39;: 3}) # mapping 形式 &amp;gt;&amp;gt;&amp;gt; d {&#39;one&#39;: 1, &#39;two&#39;: 2.0, &#39;three&#39;: 3} &amp;gt;&amp;gt;&amp;gt; d.update([(&#39;three&#39;, 3.0), (&#39;four&#39;, 4)]) # iterable 形式 &amp;gt;&amp;gt;&amp;gt; d {&#39;one&#39;: 1, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;four&#39;: 4} &amp;gt;&amp;gt;&amp;gt; d.update(five=5, six=6) # **kwargs 形式 &amp;gt;&amp;gt;&amp;gt; d {&#39;four&#39;: 4, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;six&#39;: 6, &#39;one&#39;: 1, &#39;five&#39;: 5} &amp;gt;&amp;gt;&amp;gt; d.update({&#39;six&#39;: 6.0}, seven=7) # mapping + **kwargs 形式 &amp;gt;&amp;gt;&amp;gt; d {&#39;four&#39;: 4, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;six&#39;: 6.0, &#39;one&#39;: 1, &#39;seven&#39;: 7, &#39;five&#39;: 5} &amp;gt;&amp;gt;&amp;gt; d.update([(&#39;one&#39;, 1.0), (&#39;four&#39;, 4.0)], five=5.0, seven=7.0) # iterable + **kwargs 形式 &amp;gt;&amp;gt;&amp;gt; d {&#39;four&#39;: 4.0, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;six&#39;: 6.0, &#39;one&#39;: 1.0, &#39;seven&#39;: 7.0, &#39;five&#39;: 5.0} 字典视图上面提到的 d.keys()、d.values() 和 d.items() 等方法返回的都是一个 视图类型(view object)，通过这些视图可以访问字典 d 的 keys、values 或 items，并且视图会随着字典的变化而自动更新。&amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}&amp;gt;&amp;gt;&amp;gt; keys = d.keys()&amp;gt;&amp;gt;&amp;gt; values = d.values()&amp;gt;&amp;gt;&amp;gt; items = d.items()&amp;gt;&amp;gt;&amp;gt; keysdict_keys([&#39;one&#39;, &#39;two&#39;])&amp;gt;&amp;gt;&amp;gt; valuesdict_values([1, 2])&amp;gt;&amp;gt;&amp;gt; itemsdict_items([(&#39;one&#39;, 1), (&#39;two&#39;, 2)])## 视图随着字典变化而动态更新&amp;gt;&amp;gt;&amp;gt; d.update(three=3)&amp;gt;&amp;gt;&amp;gt; keysdict_keys([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;])&amp;gt;&amp;gt;&amp;gt; valuesdict_values([1, 2, 3])&amp;gt;&amp;gt;&amp;gt; itemsdict_items([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])## 可以对视图进行迭代(iteration)&amp;gt;&amp;gt;&amp;gt; for k in keys:... print(k)...onetwothree字典比较字典只支持 == 比较操作符，当且仅当所有项都相等时才相等。对于 &amp;lt;、&amp;gt;、&amp;lt;= 和 &amp;gt;= 比较操作符都不支持，如果使用会抛 TypeError 错误。集合（set）集合(set) 是一些 无序(unordered)、无重复(no duplicate) 并且 可hash(hashable) 元素的组合。通常用于 是否包含某个成员的检测、去除重复元素 等操作。同时也支持数学上的集合运算，比如 交集(intersection)、并集(union)、差集(difference) 和 对称差集(symmetric difference)。Python 内置两种类型集合，set 和 frozenset，set 是可变类型(mutable)，frozenset 是不可变类型(immutable)。集合创建集合创建可以通过以下 3 种方式： 大括号 {} 方式： &amp;gt;&amp;gt;&amp;gt; s = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;} &amp;gt;&amp;gt;&amp;gt; s {&#39;c&#39;, &#39;b&#39;, &#39;a&#39;} # 相等元素只保留第一个 set 或 frozenset 关键字方式： set 和 frozenset 的定义如下： class set([iterable]) class frozenset([iterable]) 根据以上定义可以通过下面的方式创建集合： &amp;gt;&amp;gt;&amp;gt; s = set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) &amp;gt;&amp;gt;&amp;gt; fs = frozenset([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) &amp;gt;&amp;gt;&amp;gt; s {&#39;c&#39;, &#39;b&#39;, &#39;a&#39;} &amp;gt;&amp;gt;&amp;gt; fs frozenset({&#39;c&#39;, &#39;b&#39;, &#39;a&#39;}) &amp;gt;&amp;gt;&amp;gt; s.add(&#39;d&#39;) # set 是可变类型 &amp;gt;&amp;gt;&amp;gt; s {&#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;} &amp;gt;&amp;gt;&amp;gt; fs.add(&#39;d&#39;) # frozenset 是不可变类型 Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39; &amp;gt;&amp;gt;&amp;gt; 集合推导式(set comprehension): &amp;gt;&amp;gt;&amp;gt; {x for x in range(1, 11)} {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 集合中的元素必须是 可hash的(hashable)## str、numeric 和 tuple 类型都是可hash的&amp;gt;&amp;gt;&amp;gt; {&#39;one&#39;, 2, (3, 4)}{&#39;one&#39;, 2, (3, 4)}## list 是 unhashable 类型&amp;gt;&amp;gt;&amp;gt; {1, [2]}Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: unhashable type: &#39;list&#39;## 间接包含 unhashable 类型也不行&amp;gt;&amp;gt;&amp;gt; {1, (2, [3])}Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: unhashable type: &#39;list&#39;如果要创建空集合，必须使用 set 或 frozenset 关键字，不能使用大括号，因为 {} 创建的是一个空字典。&amp;gt;&amp;gt;&amp;gt; s = set()&amp;gt;&amp;gt;&amp;gt; sset()&amp;gt;&amp;gt;&amp;gt; fs = frozenset()&amp;gt;&amp;gt;&amp;gt; fsfrozenset()&amp;gt;&amp;gt;&amp;gt; d = {}&amp;gt;&amp;gt;&amp;gt; d{}&amp;gt;&amp;gt;&amp;gt; type(d)&amp;lt;class &#39;dict&#39;&amp;gt;集合操作以下是 set 和 frozenset 都支持的操作： len(s) 返回结合中元素的个数 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; len(s) 2 x in s 判断 x 是否被包含于集合 s 中 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; 1 in s True &amp;gt;&amp;gt;&amp;gt; 3 in s False x not in s 判断 x 是否不被包含于集合 s 中 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; 1 not in s False &amp;gt;&amp;gt;&amp;gt; 3 not in s True isdisjoint(other) 判断当前集合是否与其他集合 other 没有交集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.isdisjoint({3, 4}) True &amp;gt;&amp;gt;&amp;gt; s.isdisjoint({2, 3}) False issubset(other)set &amp;lt;= other 判断当前集合是否为其他集合 other 的 子集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {1, 2, 3} &amp;gt;&amp;gt;&amp;gt; s.issubset(other) True &amp;gt;&amp;gt;&amp;gt; s &amp;lt;= other True &amp;gt;&amp;gt;&amp;gt; other = {1, 4, 3} &amp;gt;&amp;gt;&amp;gt; s.issubset(other) False &amp;gt;&amp;gt;&amp;gt; s &amp;lt;= other False set &amp;lt; other 判断当前集合是否为其他集合 other 的 真子集 &amp;gt;&amp;gt;&amp;gt; {1, 2} &amp;lt; {1, 2, 3} True &amp;gt;&amp;gt;&amp;gt; {1, 2} &amp;lt; {1, 2} False issuperset(other)set &amp;gt;= other 判断当前集合是否为其他集合 other 的 超集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2, 3} &amp;gt;&amp;gt;&amp;gt; other = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.issuperset(other) True &amp;gt;&amp;gt;&amp;gt; s &amp;gt;= other True set &amp;gt; other 判断当前集合是否其他集合 other 的 真超集 &amp;gt;&amp;gt;&amp;gt; {1, 2, 3} &amp;gt; {1, 2} True &amp;gt;&amp;gt;&amp;gt; {1, 2} &amp;gt; {1, 2} False union(*others)set | other | … 当前集合与其他一个或多个集合求 并集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.union(other) {1, 2, 3} &amp;gt;&amp;gt;&amp;gt; s | other {1, 2, 3} intersection(*others)set &amp;amp; other &amp;amp; … 当前集合与其他一个或多个集合求 交集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.intersection(other) {2} &amp;gt;&amp;gt;&amp;gt; s &amp;amp; other {2} difference(*others)set - other - … 当前集合与其他一个或多个集合求 差集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.difference(other) {1} &amp;gt;&amp;gt;&amp;gt; s - other {1} symmetric_difference(other)set ^ other 当前集合与其他集合 other 求 对称差集 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s ^ other {1, 3} &amp;gt;&amp;gt;&amp;gt; s.symmetric_difference(other) {1, 3} copy() 返回当前集合的一个 浅拷贝 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.copy() {1, 2} 需要注意的是以上的 比较方法 union()、intersection()、difference()、symmetric_difference()、issubset() 和 issuperset()，接受的参数除了集合类型外，还可以是 可迭代类型(iterable)。相比之下，对应的 比较运算符 则只能接受集合类型参数。&amp;gt;&amp;gt;&amp;gt; {1, 2}.union([3, 4]) # union 方法可以接受 iterable 类型{1, 2, 3, 4}&amp;gt;&amp;gt;&amp;gt; {1, 2} | [3, 4] # | 运算符不能接受 iterable 类型Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: unsupported operand type(s) for |: &#39;set&#39; and &#39;list&#39;以下是只有 set 支持的操作： update(*others)set |= other | … 将当前集合与其他一个或多个集合求 并集 然后更新到当前集合 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.update(other) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3} &amp;gt;&amp;gt;&amp;gt; s |= {3, 4} &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3, 4} intersection_update(*others)set &amp;amp;= other &amp;amp; … 将当前集合与其他一个或多个集合求 交集 然后更新到当前集合 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.intersection_update(other) &amp;gt;&amp;gt;&amp;gt; s {2} &amp;gt;&amp;gt;&amp;gt; s &amp;amp;= {3, 4} &amp;gt;&amp;gt;&amp;gt; s set() difference_update(*others)set -= other | … 将当前集合与其他一个或多个集合求 差集 然后更新到当前集合 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.difference_update(other) &amp;gt;&amp;gt;&amp;gt; s {1} &amp;gt;&amp;gt;&amp;gt; s -= {3, 4} &amp;gt;&amp;gt;&amp;gt; s {1} symmetric_difference_update(other)set ^= other 将当前集合与其他集合 other 求 对称差集 然后更新到当前集合 &amp;gt;&amp;gt;&amp;gt; other = {2, 3} &amp;gt;&amp;gt;&amp;gt; s.symmetric_difference_update(other) &amp;gt;&amp;gt;&amp;gt; s {1, 3} &amp;gt;&amp;gt;&amp;gt; s ^= {3, 4} &amp;gt;&amp;gt;&amp;gt; s {1, 4} add(elem) 添加一个元素 elem 到当前集合 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.add(3) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3} remove(elem) 从当前集合删除元素 elem ，如果 elem 不存在则抛 KeyError 异常 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.remove(2) &amp;gt;&amp;gt;&amp;gt; s {1} &amp;gt;&amp;gt;&amp;gt; s.remove(2) Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; KeyError: 2 discard(elem) 从当前集合删除元素 elem ，如果 elem 不存在也不抛异常 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.discard(2) &amp;gt;&amp;gt;&amp;gt; s {1} &amp;gt;&amp;gt;&amp;gt; s.discard(2) &amp;gt;&amp;gt;&amp;gt; s {1} pop() 从当前集合任意删除一个元素并返回，由于集合是无序的，所以删除哪个元素不确定，如果当前集合为空，则抛 KeyError 异常 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.pop() 1 &amp;gt;&amp;gt;&amp;gt; s.pop() 2 &amp;gt;&amp;gt;&amp;gt; s.pop() Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; KeyError: &#39;pop from an empty set&#39; clear() 清空当前集合 &amp;gt;&amp;gt;&amp;gt; s = {1, 2} &amp;gt;&amp;gt;&amp;gt; s.clear() &amp;gt;&amp;gt;&amp;gt; s set() 同样的以上的 update()、intersection_update()、difference_update() 和 symmetric_difference_update() 也接受可迭代类型参数，但是对应的 运算符 则只能接受集合类型参数。immutable 与 hashablePython 中不可变类型 immutable 都是 hashable 类型的，但是 hashable 类型并不一定都是 immutable 的，因为默认所有 自定义类的实例 都是 hashable 类型的，其 hash 值通常就是 id() 函数的计算结果，由于用户自定义类不一定是不可变类型的，所以 hashable 类型不一定都是 immutable 类型。关于 hashable 可参考：https://docs.python.org/3.5/glossary.html#term-hashable关于 immutable 可参考：https://docs.python.org/3.5/glossary.html#term-immutable参考资料 [Sets] : https://docs.python.org/3.5/tutorial/datastructures.html#sets [Dictionaries] : https://docs.python.org/3.5/tutorial/datastructures.html#dictionaries [Set Types — set, frozenset] : https://docs.python.org/3.5/library/stdtypes.html#set-types-set-frozenset [Mapping Types — dict] : https://docs.python.org/3.5/library/stdtypes.html#mapping-types-dict" }, { "title": "Python 入门 - 5 - 列表与元组", "url": "/posts/python-tutorial-5-list-and-tuple/", "categories": "Python 入门", "tags": "python", "date": "2020-07-15 15:16:00 +0800", "snippet": "序列（Sequence）在前面已经介绍过的 字符串(str)，以及接下来要学习的 列表(list) 和 元组(tuple) 都属于 序列(Sequence) 类型。序列又分为 可变序列(mutable) 和 不可变序列(immutable)，可变指的是可修改序列的元素，列表属于可变序列，字符串和元组都属于不可变序列。## 列表使用中括号表示&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]&amp;gt;&amp;gt;&amp;gt; type(nums)&amp;lt;class &#39;list&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; nums[1] = 0 # 列表是可变序列&amp;gt;&amp;gt;&amp;gt; nums[1, 0, 3]## 元组使用圆括号表示&amp;gt;&amp;gt;&amp;gt; seqs = (4, 5, 6)&amp;gt;&amp;gt;&amp;gt; type(seqs)&amp;lt;class &#39;tuple&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; seqs[1] = 0 # 元组是不可变序列Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: &#39;tuple&#39; object does not support item assignment&amp;gt;&amp;gt;&amp;gt; seqs(4, 5, 6)序列操作序列类型支持的一些通用操作（即可变和不可变序列均支持）如下表： Operation Result x in s 如果 s 中的某项等于 x 则结果为 True，否则为 False x not in s 如果 s 中的某项等于 x 则结果为 False，否则为 True s + t s 与 t 相拼接 s * n 或 n * s 相当于 s 与自身进行 n 次拼接 s[i] s 的第 i 项，起始为 0 s[i:j] s 从 i 到 j 的切片 s[i:j:k] s 从 i 到 j 步长为 k 的切片 len(s) s 的长度 min(s) s 的最小项 max(s) s 的最大项 s.index(x[, i[, j]]) x 在 s 中首次出现项的索引号（索引号在 i 或其后且在 j 之前） s.count(x) x 在 s 中出现的总次数 下面对以上操作进行示例演示： x in s &amp;gt;&amp;gt;&amp;gt; 1 in [1, 2, 3] True &amp;gt;&amp;gt;&amp;gt; 4 in [1, 2, 3] False x not in s &amp;gt;&amp;gt;&amp;gt; 4 not in (1, 2, 3) True &amp;gt;&amp;gt;&amp;gt; &#39;a&#39; not in &#39;abc&#39; False s + t &amp;gt;&amp;gt;&amp;gt; [1, 2] + [3, 4] [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; (5, 6) + (7, 8) (5, 6, 7, 8) s * n 或 n * s &amp;gt;&amp;gt;&amp;gt; [1, 2] * 2 [1, 2, 1, 2] &amp;gt;&amp;gt;&amp;gt; 3 * &#39;w&#39; &#39;www&#39; s[i] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][0] 1 &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;[-1] &#39;c&#39; s[i:j] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][0:2] [1, 2] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][:2] # i 可以省略，默认值为 0 [1, 2] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:] # j 也可以省略，默认值为 len(s) [2, 3] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][:] # i 和 j 同时省略则相当于对 s 进行了一个拷贝 [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][2:1] # 如果 j &amp;lt;= i，则返回一个空列表 [] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:-1] # i 和 j 也可以是负数，如果是负数则会被转换为 len(s) + i/j [2] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:2] # [1:-1] 就相当于 [1:len(s)+(-1)] = [1:3-1] = [1:2] [2] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:5] # 如果 i 或 j 大于 len(s)，则被转换为 len(s) [2, 3] s[i:j:k] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][0:3:2] # 设定步长 k 为 2，默认为 1 [1, 3] &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][2:0:-1] # 相当于取 2, 2-1, 2+n*(-1), ... [3, 2] # k 为负数时 i 或 j 的默认值会倒转 # k 为正数时，i 和 j 的默认值分别为 0, len(s) # k 为负数时，i 和 j 的默认值分别为 len(s)-1, 0，且包含第 0 个元素 &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][::-1] [3, 2, 1] # k 不能为 0 &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][::0] Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; ValueError: slice step cannot be zero len(s) &amp;gt;&amp;gt;&amp;gt; len([1, 2, 3]) 3 &amp;gt;&amp;gt;&amp;gt; len(&#39;abc&#39;) 3 min(s) &amp;gt;&amp;gt;&amp;gt; min([1, 2, 3]) 1 &amp;gt;&amp;gt;&amp;gt; min(&#39;abc&#39;) &#39;a&#39; &amp;gt;&amp;gt;&amp;gt; min([1, 2, &#39;c&#39;]) # 序列中的元素必须时相同类型的 Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; TypeError: unorderable types: str() &amp;lt; int() max(s) &amp;gt;&amp;gt;&amp;gt; max([1, 2, 3]) 3 &amp;gt;&amp;gt;&amp;gt; max(&#39;abc&#39;) &#39;c&#39; &amp;gt;&amp;gt;&amp;gt; max((1, 2, &#39;c&#39;)) # 序列中的元素必须时相同类型的 Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; TypeError: unorderable types: str() &amp;gt; int() s.index(x[, i[, j]]) &amp;gt;&amp;gt;&amp;gt; [1, 2, 3].index(1) 0 &amp;gt;&amp;gt;&amp;gt; [1, 2, 3].index(4) # 未查找到元素报 ValueError Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; ValueError: 4 is not in list s.count(x) &amp;gt;&amp;gt;&amp;gt; [1, 2, 1].count(1) 2 &amp;gt;&amp;gt;&amp;gt; [1, 2, 1].count(3) 0 列表（list）列表属于可变序列（mutable Sequence），列表定义除了用 中括号([]) 外，还可以使用内置函数 list() 把其他序列类型转换为列表：&amp;gt;&amp;gt;&amp;gt; list(&#39;abc&#39;) # 把字符串转换为列表[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&amp;gt;&amp;gt;&amp;gt; list((1, 2, 3)) # 把元组转换为列表[1, 2, 3]列表操作列表除了支持序列类型的通用操作外，还支持以下这些 可变序列独有的操作： Operation Result s[i] = x 将 s 的第 i 项替换为 x s[i:j] = t 将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容 del s[i:j] 等同于 s[i:j] = [] s[i:j:k] = t 将 s[i:j:k] 的元素替换为 t 的元素 del s[i:j:k] 从列表中移除 s[i:j:k] 的元素 s.append(x) 将 x 添加到序列的末尾 (等同于 s[len(s):len(s)] = [x]) s.clear() 从 s 中移除所有项 (等同于 del s[:]) s.copy() 创建 s 的浅拷贝 (等同于 s[:]) s.extend(t) 或 s += t 用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t) s *= n 使用 s 的内容重复 n 次来对其进行更新 s.insert(i, x) 在由 i 给出的索引位置将 x 插入 s (等同于 s[i:i] = [x]) s.pop([i]) 提取在 i 位置上的项，并将其从 s 中移除 s.remove(x) 删除 s 中第一个等于 x 的项目。 s.reverse() 就地将列表中的元素逆序。 下面对以上操作进行示例演示： s[i] = x &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums[1] = 0 &amp;gt;&amp;gt;&amp;gt; nums [1, 0, 3] s[i:j] = t &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums[1:3] = [0, 0] # 把第 1 到 3-1 范围的元素替换为 [0, 0] &amp;gt;&amp;gt;&amp;gt; nums [1, 0, 0] &amp;gt;&amp;gt;&amp;gt; nums[1:3] = [] # 把第 1 到 3-1 范围的元素删除 &amp;gt;&amp;gt;&amp;gt; nums [1] &amp;gt;&amp;gt;&amp;gt; nums[:] = [] # 清空整个列表 &amp;gt;&amp;gt;&amp;gt; nums [] del s[i:j] &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; del nums[1:3] &amp;gt;&amp;gt;&amp;gt; nums [1] s[i:j:k] = t &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums[0:3:2] = [5, 6] # 把第 0, 0+2 两个元素分别替换为 [5, 6] 中的元素 &amp;gt;&amp;gt;&amp;gt; nums [5, 2, 6] &amp;gt;&amp;gt;&amp;gt; nums[0:3:2] = [5] # t 的元素个数必须和 [i:j:k] 切割出的元素个数相等 Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; ValueError: attempt to assign sequence of size 1 to extended slice of size 2 del s[i:j:k] &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; del nums[0:3:2] &amp;gt;&amp;gt;&amp;gt; nums [2] s.append(x) &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.append(4) &amp;gt;&amp;gt;&amp;gt; nums [1, 2, 3, 4] s.clear() &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.clear() &amp;gt;&amp;gt;&amp;gt; nums [] s.copy() &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums_copy = nums.copy() &amp;gt;&amp;gt;&amp;gt; nums_copy [1, 2, 3] s.extend(t) 或 s += t &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.extend([4, 5]) &amp;gt;&amp;gt;&amp;gt; nums [1, 2, 3, 4, 5] &amp;gt;&amp;gt;&amp;gt; nums += [6, 7] &amp;gt;&amp;gt;&amp;gt; nums [1, 2, 3, 4, 5, 6, 7] s *= n &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums *= 2 &amp;gt;&amp;gt;&amp;gt; nums [1, 2, 3, 1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums *= -1 # 如果 n 小于等于 0，则 s 被清空 &amp;gt;&amp;gt;&amp;gt; nums [] s.insert(i, x) &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.insert(1, 4) &amp;gt;&amp;gt;&amp;gt; nums [1, 4, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums[1:1] = [5] # 等同于 nums.insert(1, 5) &amp;gt;&amp;gt;&amp;gt; nums [1, 5, 4, 2, 3] s.pop([i]) &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.pop() # 参数 i 默认为 -1 3 &amp;gt;&amp;gt;&amp;gt; nums [1, 2] &amp;gt;&amp;gt;&amp;gt; nums.pop(0) # 也可以 pop 指定位置的元素 1 &amp;gt;&amp;gt;&amp;gt; nums [2] s.remove(x) &amp;gt;&amp;gt;&amp;gt; chars = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &amp;gt;&amp;gt;&amp;gt; chars.remove(&#39;b&#39;) &amp;gt;&amp;gt;&amp;gt; chars [&#39;a&#39;, &#39;c&#39;] &amp;gt;&amp;gt;&amp;gt; chars.remove(&#39;f&#39;) # 如果 s 中不存在值为 x 的元素，则报 ValueError Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; ValueError: list.remove(x): x not in list s.reverse() &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.reverse() &amp;gt;&amp;gt;&amp;gt; nums [3, 2, 1] 列表排序列表除了支持 序列通用操作 和 可变序列操作 外，列表还实现了一个单独的方法 sort ： list.sort(key=None, reverse=False) sort 是一个就地排序方法，默认升序排序，如果 reverse 参数为 True，则是进行降序排序。 key 可以接受一个函数，对待排序的对象进行预处理后再进行排序。 &amp;gt;&amp;gt;&amp;gt; nums = [2, 3, 1] &amp;gt;&amp;gt;&amp;gt; nums.sort() &amp;gt;&amp;gt;&amp;gt; nums [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; nums.sort(reverse=True) # 降序排序 &amp;gt;&amp;gt;&amp;gt; nums [3, 2, 1] &amp;gt;&amp;gt;&amp;gt; ids = [&#39;lily-02&#39;, &#39;tom-01&#39;, &#39;jack-03&#39;] &amp;gt;&amp;gt;&amp;gt; ids.sort() # 默认按字母序进行升序排序：j &amp;lt; l &amp;lt; t &amp;gt;&amp;gt;&amp;gt; ids [&#39;jack-03&#39;, &#39;lily-02&#39;, &#39;tom-01&#39;] # 只取 - 后两位数字进行排序比较：01 &amp;lt; 02 &amp;lt; 03 &amp;gt;&amp;gt;&amp;gt; ids.sort(key=lambda s: s.split(&#39;-&#39;)[-1]) &amp;gt;&amp;gt;&amp;gt; ids [&#39;tom-01&#39;, &#39;lily-02&#39;, &#39;jack-03&#39;] 列表推导式列表推导式提供了一种简洁的方式来创建列表，比如需要创建一个 1~10 的平方数的列表，只需要像这样一行代码即可完成：&amp;gt;&amp;gt;&amp;gt; [x**2 for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]列表推导式也同时支持在 for 后面添加 if 语句：&amp;gt;&amp;gt;&amp;gt; [x for x in range(1, 11) if x%2 == 0] # 1~10 的偶数[2, 4, 6, 8, 10]列表推导式也支持嵌套：&amp;gt;&amp;gt;&amp;gt; [(x, y) for x in [1, 2] for y in [3, 4]][(1, 3), (1, 4), (2, 3), (2, 4)]## 上面的推导式与以下嵌套循环作用相同&amp;gt;&amp;gt;&amp;gt; combs = []&amp;gt;&amp;gt;&amp;gt; for x in [1, 2]:... for y in [3, 4]:... combs.append((x, y))...&amp;gt;&amp;gt;&amp;gt; combs[(1, 3), (1, 4), (2, 3), (2, 4)]浅拷贝与深拷贝列表支持嵌套列表或嵌套其他可变对象，对于列表自带的 copy 方法和切片式拷贝，以及 *(repeation)，都只是一个 浅拷贝，下面举例对浅拷贝进行说明：&amp;gt;&amp;gt;&amp;gt; nested_nums = [1, [2, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums = nested_nums.copy() # 浅拷贝，等同于 nested_nums[:]## 修改原始列表中非嵌套元素，拷贝列表不受影响&amp;gt;&amp;gt;&amp;gt; nested_nums[0] = 9&amp;gt;&amp;gt;&amp;gt; nested_nums[9, [2, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums[1, [2, 3], 4]## 修改原始列表中嵌套列表的元素，拷贝列表受影响&amp;gt;&amp;gt;&amp;gt; nested_nums[1][0] = 9&amp;gt;&amp;gt;&amp;gt; nested_nums[9, [9, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums[1, [9, 3], 4]如果想要避免上面的浅拷贝的情况，可以使用 copy.deepcopy 函数进行深拷贝：&amp;gt;&amp;gt;&amp;gt; nested_nums = [1, [2, 3], 4]&amp;gt;&amp;gt;&amp;gt; import copy&amp;gt;&amp;gt;&amp;gt; copy_nested_nums = copy.deepcopy(nested_nums)&amp;gt;&amp;gt;&amp;gt; nested_nums[1][0] = 9&amp;gt;&amp;gt;&amp;gt; nested_nums[1, [9, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums # 深拷贝的列表不受影响[1, [2, 3], 4]rangerange 是一个 内置类型，可以用来创建一个 不可变序列(immutable)，定义如下：class range(stop)class range(start, stop[, step])# 在 start 到 stop 范围内（不包含 stop），以步长为 step，产生一个序列。start, stop, step 均为 int 类型，如果只传入一个参数，这个参数会被当作 stop ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(3)][0, 1, 2]也可以传入 2 个参数，则分别会被当作 start 和 stop ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(1, 3)][1, 2]还可以设定步长（step），步长默认值是 1 ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(1, 10, 2)][1, 3, 5, 7, 9]如果步长 step 为负数，那么应该满足 start &amp;gt;= stop ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(3, 0, -1)][3, 2, 1]和 list 相比，range 类型更节约内存，因为 list 占用内存大小是根据元素的多少而变化，而 range 生成的实例只是记录了一下计算方法，不管范围多大，都占用固定大小的内存，在每一次 for 循环时才实时计算出当前的元素内容：&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]&amp;gt;&amp;gt;&amp;gt; import sys&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(nums)88&amp;gt;&amp;gt;&amp;gt; r = range(1, 4)&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(r)48&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; sys.getsizeof(nums) # 增加一个元素后，大小也增加了 896&amp;gt;&amp;gt;&amp;gt; r = range(1, 5)&amp;gt;&amp;gt;&amp;gt; rrange(1, 5)&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(r) # 扩大范围后，占用大小仍然不变48元组（tuple）元组和列表类似，都是序列，不同的是元组是 不可变序列(immutable Sequence)，元组的定义使用 圆括号，也可以使用内置关键字 tuple，将其他序列转换为元组：&amp;gt;&amp;gt;&amp;gt; t = (1, 2, 3)&amp;gt;&amp;gt;&amp;gt; t(1, 2, 3)&amp;gt;&amp;gt;&amp;gt; t = 1, 2, 3 # 如果元素个数超过 1 个，也可以不使用圆括号&amp;gt;&amp;gt;&amp;gt; t(1, 2, 3)## 只有 1 个元素的元组需要用圆括号括起来，并且在末尾添加一个逗号(,)## 这样做是为了和数学符号的圆括号进行区分&amp;gt;&amp;gt;&amp;gt; t = (1,) &amp;gt;&amp;gt;&amp;gt; t(1,)&amp;gt;&amp;gt;&amp;gt; tuple([1, 2, 3]) # 把列表转换为元组(1, 2, 3)元组作为不可变序列，一旦定义后，其中的元素不能被修改：&amp;gt;&amp;gt;&amp;gt; t = (1, 2, 3)&amp;gt;&amp;gt;&amp;gt; t[0] = 5Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: &#39;tuple&#39; object does not support item assignment但是元组里的可变类型的内容的是可以被修改的：&amp;gt;&amp;gt;&amp;gt; t = (1, [2, 3], 4)&amp;gt;&amp;gt;&amp;gt; t[1][0] = 3&amp;gt;&amp;gt;&amp;gt; t(1, [3, 3], 4)参考资料 [More on Lists] : https://docs.python.org/3.5/tutorial/datastructures.html#more-on-lists [Tuples and Sequences] : https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences [Sequence Types — list, tuple, range] : https://docs.python.org/3.5/library/stdtypes.html#sequence-types-list-tuple-range" }, { "title": "Python 入门 - 4 - 字符串", "url": "/posts/python-tutorial-4-string/", "categories": "Python 入门", "tags": "python", "date": "2020-07-10 17:39:07 +0800", "snippet": "字符串方法字符串(str) 在 Python 中是一个 对象(object)，并且包含很多的 方法(method)，这些方法可以给我们操作字符串带来很大的方便，下面列举一些常用的方法及其使用示例： str.capitalize() 把字符串的首字母变成大写。 &amp;gt;&amp;gt;&amp;gt; &#39;hello&#39;.capitalize() &#39;Hello&#39; str.lower() 把字符串转换为小写。 &amp;gt;&amp;gt;&amp;gt; &#39;Hello&#39;.lower() &#39;hello&#39; str.upper() 把字符串转换为大写。 &amp;gt;&amp;gt;&amp;gt; &#39;Hello&#39;.upper() &#39;HELLO&#39; str.center(width[, fillchar]) 返回一个长度为 width，原始字符串居中，两边多余长度使用 fillchar 进行填充的新字符串。 &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.center(10, &#39;=&#39;) &#39;===abc====&#39; &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.center(10) # fillchar 默认为空格 &#39; abc &#39; &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.center(3) # 如果 width 小于等于字符串长度，则返回原始字符串 &#39;abc&#39; str.count(sub[, start[, end]]) 在字符串的 start 到 end 范围内查找子字符串 sub 出现的次数。 start 默认为0，end 默认为字符串长度，即默认查找整个字符串，这2个参数在其他方法中类似，不再重复说明。 &amp;gt;&amp;gt;&amp;gt; &#39;abcad&#39;.count(&#39;a&#39;) 2 &amp;gt;&amp;gt;&amp;gt; &#39;abcad&#39;.count(&#39;a&#39;, 0, 3) 1 &amp;gt;&amp;gt;&amp;gt; &#39;abcad&#39;.count(&#39;a&#39;, 0, 4) 2 str.encode(encoding=”utf-8”, errors=”strict”) 对字符串按照 encoding 进行编码。 &amp;gt;&amp;gt;&amp;gt; &#39;中文&#39;.encode() b&#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#39; str.startswith(prefix[, start[, end]]) 判断字符串在 start 到 end 范围内是否是以 prefix 开头，是返回 True，否则返回 False。 prefix 可以是多个，以 tuple 格式传入。 str.endswith 方法与此方法类似。 &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.startswith(&#39;a&#39;) True &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.startswith(&#39;b&#39;) False &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.startswith((&#39;a&#39;, &#39;b&#39;)) # 是否以 &#39;a&#39; 或 &#39;b&#39; 开头 True str.find(sub[, start[, end]]) 在字符串的 start 到 end 范围内查找子字符串 sub，如果查到到则返回 sub 出现的最小起始索引号，否则返回 -1 。 &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.find(&#39;b&#39;) 1 &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.find(&#39;x&#39;) -1 如果只需要判断是否包含子字符串，可以使用 in 关键字进行判断，无需使用 find 方法。 &amp;gt;&amp;gt;&amp;gt; &#39;b&#39; in &#39;abc&#39; True &amp;gt;&amp;gt;&amp;gt; &#39;d&#39; in &#39;abc&#39; False str.index(sub[, start[, end]]) 与 str.find 方法类似，不同的是如果没有查找到子字符串 sub ，会抛出 ValueError 异常。 &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.index(&#39;b&#39;) 1 &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.index(&#39;x&#39;) Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; ValueError: substring not found &amp;gt;&amp;gt;&amp;gt; str.format(*args, **kwargs) 格式化字符串，此方法在下面会进行详细讲解，这里只演示一个简单示例。 &amp;gt;&amp;gt;&amp;gt; &quot;The sum of 1 + 2 is {0}&quot;.format(1+2) &#39;The sum of 1 + 2 is 3&#39; str.join(iterable) 把 iterable 中的字符串元素用 str 进行连接。 iterable 可以是 list、tuple 等可迭代对象，但是里边的元素必须是 str 类型。 &amp;gt;&amp;gt;&amp;gt; &#39;_&#39;.join([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) &#39;a_b_c&#39; &amp;gt;&amp;gt;&amp;gt; &#39;_&#39;.join([1, 2, 3]) # 不能是非 str 类型 Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; TypeError: sequence item 0: expected str instance, int found &amp;gt;&amp;gt;&amp;gt; str.strip([chars]) 去除字符串首尾的在 chars 中出现的字符。 如果 chars 不指定，则默认去除空白字符。 &amp;gt;&amp;gt;&amp;gt; &#39; spacious &#39;.strip() &#39;spacious&#39; &amp;gt;&amp;gt;&amp;gt; &#39;www.example.com&#39;.strip(&#39;cmowz.&#39;) &#39;example&#39; str.lstrip([chars]) 方法则只去除左边(首部)的字符。 &amp;gt;&amp;gt;&amp;gt; &#39; spacious &#39;.lstrip() &#39;spacious &#39; &amp;gt;&amp;gt;&amp;gt; &#39;www.example.com&#39;.lstrip(&#39;cmowz.&#39;) &#39;example.com&#39; str.rstrip([chars]) 与 lstrip 类似，只是去除右边(尾部)字符。 str.split(sep=None, maxsplit=-1) 用分隔符 sep 对字符串进行最多 maxsplit 次切割，返回切割后的 list 。 sep 默认为空白字符，即空格、制表符等。 maxsplit 如果不指定或指定为 -1，则会进行最大次数的切割。 # 指定 sep &amp;gt;&amp;gt;&amp;gt; &#39;1,2,3&#39;.split(&#39;,&#39;) [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] &amp;gt;&amp;gt;&amp;gt; &#39;1,2,3&#39;.split(&#39;,&#39;, maxsplit=1) [&#39;1&#39;, &#39;2,3&#39;] &amp;gt;&amp;gt;&amp;gt; &#39;1,2,,3,&#39;.split(&#39;,&#39;) [&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;] # 不指定 sep &amp;gt;&amp;gt;&amp;gt; &#39;1 2 3&#39;.split() [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] &amp;gt;&amp;gt;&amp;gt; &#39;1 2 3&#39;.split(maxsplit=1) [&#39;1&#39;, &#39;2 3&#39;] &amp;gt;&amp;gt;&amp;gt; &#39; 1 2 3 &#39;.split() [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] str.splitlines([keepends]) 把字符串按照行边界符(line boundaries)切割成多行，并以 list 形式返回。 如果 keepends 为True，则返回的每行末尾仍然包含换行符，keepends 默认为False。 符合行边界符(line boundaries)定义的字符如下： Representation Description \\n Line Feed \\r Carriage Return \\r\\n Carriage Return + Line Feed \\v or \\x0b Line Tabulation \\f or \\x0c Form Feed \\x1c File Separator \\x1d Group Separator \\x1e Record Separator \\x85 Next Line (C1 Control Code) \\u2028 Line Separator \\u2029 Paragraph Separator &amp;gt;&amp;gt;&amp;gt; &#39;first line \\nsecond line \\r\\nthird line&#39;.splitlines() [&#39;first line &#39;, &#39;second line &#39;, &#39;third line&#39;] &amp;gt;&amp;gt;&amp;gt; &#39;first line \\nsecond line \\r\\nthird line&#39;.splitlines(True) [&#39;first line \\n&#39;, &#39;second line \\r\\n&#39;, &#39;third line&#39;] 使用 % 格式化字符串Python 中使用 % 格式化字符串的格式是 format % values ：&amp;gt;&amp;gt;&amp;gt; &#39;I am %s&#39; % &#39;python&#39;&#39;I am python&#39;&amp;gt;&amp;gt;&amp;gt;如果 values 是多个值，那么需要使用表示 tuple 的圆括号括起来：&amp;gt;&amp;gt;&amp;gt; &#39;This is %s, that is %s&#39; % (&#39;python&#39;, &#39;java&#39;)&#39;This is python, that is java&#39;&amp;gt;&amp;gt;&amp;gt;values 也可以是字典，如果是字典那么 format 里需要用 映射键(mapping key) 的方式取值：&amp;gt;&amp;gt;&amp;gt; &#39;I am %(lang)s&#39; % {&#39;lang&#39;: &#39;python&#39;}&#39;I am python&#39;以上示例中的 %s 里的 s 表示转换类型为 str，Python 也支持很多其他类型，以下列出常见的几种： d/i : 有符号的十进制整数 &amp;gt;&amp;gt;&amp;gt; &#39;1 + 1 = %d&#39; % 2 &#39;1 + 1 = 2&#39; &amp;gt;&amp;gt;&amp;gt; &#39;1 + 1 = %i&#39; % 2 &#39;1 + 1 = 2&#39; o : 有符号的八进制整数 &amp;gt;&amp;gt;&amp;gt; &#39;decimal 9 convert to octal is %o&#39; % 9 &#39;decimal 9 convert to octal is 11&#39; x/X : 有符号16进制数 &amp;gt;&amp;gt;&amp;gt; &#39;decimal 17 convert to hex is %x&#39; % 17 &#39;decimal 17 convert to hex is 11&#39; f/F : 浮点数十进制格式 &amp;gt;&amp;gt;&amp;gt; &#39;%f&#39; % 3.14 &#39;3.140000&#39; e/E : 浮点数指数格式 &amp;gt;&amp;gt;&amp;gt; &#39;%e&#39; % 31.4 &#39;3.140000e+01&#39; c : 单个字符 &amp;gt;&amp;gt;&amp;gt; &#39;%c&#39; % 97 &#39;a&#39; &amp;gt;&amp;gt;&amp;gt; &#39;%c&#39; % &#39;a&#39; &#39;a&#39; r : 字符串（使用 repr() 转换任何 Python 对象） &amp;gt;&amp;gt;&amp;gt; &#39;hello %r&#39; % &#39;world&#39; &quot;hello &#39;world&#39;&quot; s : 字符串（使用 str() 转换任何 Python 对象） &amp;gt;&amp;gt;&amp;gt; &#39;hello %s&#39; % &#39;world&#39; &#39;hello world&#39; a : 字符串（使用 ascii() 转换任何 Python 对象） &amp;gt;&amp;gt;&amp;gt; &#39;hello %a&#39; % &#39;world&#39; &quot;hello &#39;world&#39;&quot; 如果需要原样表示 % ，只需双写 % 即可：&amp;gt;&amp;gt;&amp;gt; &#39;3 %% 2 = %d&#39; % 1&#39;3 % 2 = 1&#39;可以指定占位宽度，如果实际内容小于宽度，默认右对齐，左边补空格：&amp;gt;&amp;gt;&amp;gt; &#39;%3s&#39; % &#39;a&#39;&#39; a&#39;&amp;gt;&amp;gt;&amp;gt; &#39;%3d&#39; % 10&#39; 10&#39;对于浮点数，可以使用 .precision 的格式指定指定精度：&amp;gt;&amp;gt;&amp;gt; &#39;%.3f&#39; % 3.1415&#39;3.142&#39;&amp;gt;&amp;gt;&amp;gt; &#39;%.3f&#39; % 3.14&#39;3.140&#39;可以使用 转换标志(Conversion flags) 对转换行为进行一些控制，支持的转换标志如下： ’#’ : 替代模式(alternate form) # 八进制和十进制转换在替代模式下会显示 0o 和 0x/0X 前缀 &amp;gt;&amp;gt;&amp;gt; &#39;%o&#39; % 9 &#39;11&#39; &amp;gt;&amp;gt;&amp;gt; &#39;%#o&#39; % 9 &#39;0o11&#39; &amp;gt;&amp;gt;&amp;gt; &#39;%#x&#39; % 17 &#39;0x11&#39; &amp;gt;&amp;gt;&amp;gt; &#39;%#X&#39; % 17 &#39;0X11&#39; # 浮点数转换在替代模式下会始终保留一个小数点在末尾，即使精度为0的整数 &amp;gt;&amp;gt;&amp;gt; &#39;%.0f&#39; % 3.0 &#39;3&#39; &amp;gt;&amp;gt;&amp;gt; &#39;%#.0f&#39; % 3.0 &#39;3.&#39; ‘0’ : 数值类型转换时多余位置补0 &amp;gt;&amp;gt;&amp;gt; &#39;%03d&#39; % 1 &#39;001&#39; ’-‘ : 转换值将靠左对齐（会覆盖 ‘0’ 转换） &amp;gt;&amp;gt;&amp;gt; &#39;%-3d&#39; % 1 &#39;1 &#39; &amp;gt;&amp;gt;&amp;gt; &#39;%0-3d&#39; % 1 # &#39;-&#39; 转换会覆盖 &#39;0&#39; 转换 &#39;1 &#39; ’ ‘ : (空格) 正数前面保留一个空格 &amp;gt;&amp;gt;&amp;gt; &#39;% d&#39; % 1 &#39; 1&#39; &amp;gt;&amp;gt;&amp;gt; &#39;% d&#39; % -1 &#39;-1&#39; ’+’ : 数值类型前面显示符号位（会覆盖 “空格” 转换） &amp;gt;&amp;gt;&amp;gt; &#39;%+d&#39; % 1 &#39;+1&#39; &amp;gt;&amp;gt;&amp;gt; &#39;%+d&#39; % -1 &#39;-1&#39; 以上这些符号组合使用时需要遵守以下规则和顺序：%[M][F][W][P][L]T% : 固定格式。M : 映射键(mapping key)（可选），由加圆括号的字符序列组成 (例如 (somename))，values 是字典的情况下使用。F : 转换标志(conversion flags)（可选），用于影响某些转换类型的结果。W : 最小字段宽度(width)（可选）。 如果指定为 &#39;*&#39; (星号)，则实际宽度会从 values 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。P : 精度(precision)（可选），以在 &#39;.&#39; (点号) 之后加精度值的形式给出。 如果指定为 &#39;*&#39; (星号)，则实际精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。L : 长度修饰符(length modifier)（可选）。T : 转换类型(conversion type)。注：长度修饰符（h, l 或 L）可以使用，但是会被忽略，因为在 Python3 中只有长整型（L），没有短整型（h），所有 %ld 和 %d 是一样的。下面是一些组合使用的示例：## 十进制浮点数转换类型(f)，带符号位(+)，左对齐(-)，最小宽度5(5)，精度1位(.1)&amp;gt;&amp;gt;&amp;gt; &#39;%+-5.1f&#39; % 3.14&#39;+3.1 &#39;## 十进制整数转换类型(d)，带符号位(+)，最小宽度4(4)，不足位补0(0)&amp;gt;&amp;gt;&amp;gt; &#39;%+04d&#39; % 16&#39;+016&#39;## 字符串转换类型(s)，左对齐(-)，最小宽度6(6)，精度2(.2)&amp;gt;&amp;gt;&amp;gt; &#39;%-6.2s&#39; % &#39;Python&#39;&#39;Py &#39;使用 str.format 格式化字符串从 Python3 开始官方推荐使用字符串自带的 format 方法对字符串进行格式化，该方法能够完全兼容 % 的形式且更强大，比如像下面这样：&amp;gt;&amp;gt;&amp;gt; &#39;hello {}!&#39;.format(&#39;world&#39;)&#39;hello world!&#39;format 的语法定义如下：replacement_field ::= &quot;{&quot; [field_name] [&quot;!&quot; conversion] [&quot;:&quot; format_spec] &quot;}&quot;field_name ::= arg_name (&quot;.&quot; attribute_name | &quot;[&quot; element_index &quot;]&quot;)*arg_name ::= [identifier | integer]attribute_name ::= identifierelement_index ::= integer | index_stringindex_string ::= &amp;lt;any source character except &quot;]&quot;&amp;gt; +conversion ::= &quot;r&quot; | &quot;s&quot; | &quot;a&quot;format_spec ::= &amp;lt;described in the next section&amp;gt;下面通过举例的方式逐一对 format 语法定义中的字段进行解释： field_name/arg_name : 参数名（可选），可以是位置（integer）或名称（identifier）。 # arg_name 为空则按顺序依次引用后面的位置参数 &amp;gt;&amp;gt;&amp;gt; &#39;{} {} {}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) &#39;first second third&#39; # arg_name 为位置（integer），则按照索引号引用后面的位置参数 &amp;gt;&amp;gt;&amp;gt; &#39;{0} {1} {2}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) &#39;first second third&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{2} {1} {0}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) &#39;third second first&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{0} {0} {1}&#39;.format(&#39;first&#39;, &#39;second&#39;) &#39;first first second&#39; # 但是空和位置引用不能混用 &amp;gt;&amp;gt;&amp;gt; &#39;{} {1} {2}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;) Traceback (most recent call last): File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; ValueError: cannot switch from automatic field numbering to manual field specification # arg_name 为名称（identifier），则按照名称引用后面的关键字参数 &amp;gt;&amp;gt;&amp;gt; &#39;{f1} {f2} {f3}&#39;.format(f1=&#39;first&#39;, f2=&#39;second&#39;, f3=&#39;third&#39;) &#39;first second third&#39; # 空引用和名称引用混用，或者数字引用和名称引用混用是可以的 &amp;gt;&amp;gt;&amp;gt; &#39;{} {f2} {}&#39;.format(&#39;first&#39;, &#39;third&#39;, f2=&#39;second&#39;) &#39;first second third&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{0} {f2} {1}&#39;.format(&#39;first&#39;, &#39;third&#39;, f2=&#39;second&#39;) &#39;first second third&#39; field_name/arg_name.attribute_name : 属性名（可选），是对参数的属性进行引用。 &amp;gt;&amp;gt;&amp;gt; c = 3-5j &amp;gt;&amp;gt;&amp;gt; &#39;realpart = {0.real}, imagpart = {0.imag}&#39;.format(c) &#39;realpart = 3.0, imagpart = -5.0&#39; &amp;gt;&amp;gt;&amp;gt; &#39;realpart = {cnum.real}, imagpart = {cnum.imag}&#39;.format(cnum=c) &#39;realpart = 3.0, imagpart = -5.0&#39; field_name/arg_name[element_index] : 元素索引（可选），可以是数字或名称，通过索引的方式引用参数的元素。 # 数字索引 &amp;gt;&amp;gt;&amp;gt; arr = [1, 2] &amp;gt;&amp;gt;&amp;gt; &#39;e1 = {0[0]}, e2 = {0[1]}&#39;.format(arr) &#39;e1 = 1, e2 = 2&#39; # 名称索引 &amp;gt;&amp;gt;&amp;gt; d = {&#39;id&#39;: 1, &#39;name&#39;: &#39;tom&#39;} &amp;gt;&amp;gt;&amp;gt; &#39;id = {0[id]}, name = {0[name]}&#39;.format(d) &#39;id = 1, name = tom&#39; conversion : 转换标志，’!s’ 会对值调用 str()，’!r’ 调用 repr() 而 ‘!a’ 则调用 ascii() 。 &amp;gt;&amp;gt;&amp;gt; &#39;hello {0!r}&#39;.format(&#39;world&#39;) &quot;hello &#39;world&#39;&quot; &amp;gt;&amp;gt;&amp;gt; &#39;hello {0!s}&#39;.format(&#39;world&#39;) &#39;hello world&#39; &amp;gt;&amp;gt;&amp;gt; &#39;hello {0!a}&#39;.format(&#39;world&#39;) &quot;hello &#39;world&#39;&quot; format_spec 的语法定义如下：format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]fill ::= &amp;lt;any character&amp;gt;align ::= &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;=&quot; | &quot;^&quot;sign ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot;width ::= integerprecision ::= integertype ::= &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;下面通过举例的方式逐一对 format_spec 语法定义中的字段进行解释： width : 最小宽度 # 指定最小宽度为 10 位 &amp;gt;&amp;gt;&amp;gt; &#39;{:10}&#39;.format(&#39;Python&#39;) &#39;Python &#39; align : 对齐方式，支持 ‘&amp;lt;’, ‘&amp;gt;’, ‘^’ 三种方式。 &amp;gt;&amp;gt;&amp;gt; &#39;{:&amp;lt;30}&#39;.format(&#39;left aligned&#39;) # 最小宽度 30，并且左对齐 &#39;left aligned &#39; &amp;gt;&amp;gt;&amp;gt; &#39;{:&amp;gt;30}&#39;.format(&#39;right aligned&#39;) # 最小宽度 30，并且又对齐 &#39; right aligned&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{:^30}&#39;.format(&#39;centered&#39;) # 最小宽度 30，并且居中对齐 &#39; centered &#39; fill : 填充符 # 最小宽度 30，并且居中对齐，多余部分使用 * 填充 &amp;gt;&amp;gt;&amp;gt; &#39;{:*^30}&#39;.format(&#39;centered&#39;) &#39;***********centered***********&#39; sign : 符号位，仅对数学类型有效，支持 ‘+’, ‘-‘, ‘ ‘ 三种类型。 &amp;gt;&amp;gt;&amp;gt; &#39;{:+}, {:+}&#39;.format(1, -1) # 始终保留符号位 &#39;+1, -1&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{:-}, {:-}&#39;.format(1, -1) # 负数才有符号位 &#39;1, -1&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{: }, {: }&#39;.format(1, -1) # 正数前保留一个空格 &#39; 1, -1&#39; precision : 精度 &amp;gt;&amp;gt;&amp;gt; &#39;{:.2}&#39;.format(3.14) &#39;3.1&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{:.2}&#39;.format(&#39;Python&#39;) # 作用在字符串上则会按照进行截断 &#39;Py&#39; , : 千分位 &amp;gt;&amp;gt;&amp;gt; &#39;{:,}&#39;.format(12345678) &#39;12,345,678&#39; type : 转换类型 转换类型大部分与 % 格式化的方式相同，下面只对不一样的类型进行示例说明： &amp;gt;&amp;gt;&amp;gt; &#39;{:b}&#39;.format(7) # 二进制类型 &#39;111&#39; &amp;gt;&amp;gt;&amp;gt; &#39;{:.2%}&#39;.format(23/89) # 百分比类型 &#39;25.84%&#39; #/0 : # 和 0 的作用与 % 格式化的方式相同 参考资料 [Strings] : https://docs.python.org/3.5/tutorial/introduction.html#strings [String Methods] : https://docs.python.org/3.5/library/stdtypes.html#string-methods [Format String Syntax] : https://docs.python.org/3.5/library/string.html#formatstrings [printf-style String Formatting] : https://docs.python.org/3.5/library/stdtypes.html#old-string-formatting" }, { "title": "Python 入门 - 3 - 数据类型", "url": "/posts/python-tutorial-3-variable-type/", "categories": "Python 入门", "tags": "python", "date": "2020-06-12 17:52:02 +0800", "snippet": "数字（int, float）Python 中的整数和数学上的整数一样，但是跟 Python2 和 C 语言相比不同的是，Python3 中的整数没有 短整型(int) 和 长整型(long) 的区别，即 int 直接相当于 Python2 和 C 语言中的 长整型(long) 类型。Python 中的 浮点数(float) 则相当于数学上的小数。叫做浮点数是由于在计算机中小数的表示方法有 浮点表示 和 定点表示 的区别，浮点表示即小数点的位置可变，比如 1.23 也可以表示为 0.123e1。关于浮点数可以参考《浮点数的二进制表示》。四则运算：## 加减乘除&amp;gt;&amp;gt;&amp;gt; 2 + 24&amp;gt;&amp;gt;&amp;gt; 50 - 5*620&amp;gt;&amp;gt;&amp;gt; (50 - 5*6) / 4 # 除法运算结果始终为浮点数5.0取余和幂运算：&amp;gt;&amp;gt;&amp;gt; 17 % 3 # 取余2&amp;gt;&amp;gt;&amp;gt; 2 ** 3 # 幂运算8&amp;gt;&amp;gt;&amp;gt; pow(2, 3) # 也可以适用内置函数 pow 进行幂运算8地板除法（floor division）：&amp;gt;&amp;gt;&amp;gt; 11 // 4 # 地板除运算符(//)的结果将会向负无穷的方向取整2&amp;gt;&amp;gt;&amp;gt; -11 // 4 # -2.75 向负无穷的方向取整结果为 -3-3## math.floor 方法和 // 运算符结果一样&amp;gt;&amp;gt;&amp;gt; import math&amp;gt;&amp;gt;&amp;gt; math.floor(2.75)2&amp;gt;&amp;gt;&amp;gt; math.floor(-2.75)-3## math.ceil 则是向正无穷方向取整&amp;gt;&amp;gt;&amp;gt; math.ceil(2.75)3&amp;gt;&amp;gt;&amp;gt; math.ceil(-2.75)-2int 和 float 混合运算时的规则：在数值范围表示上 int &amp;lt; float，所以 int 相对于 float 来说是窄类型（narrower），float 相对 int 来说是宽类型，在混合运算或比较时，窄类型会转换为宽类型进行计算，所以最终结果也是宽类型：## 窄类型 int 转换为宽类型 float 进行计算&amp;gt;&amp;gt;&amp;gt; 2 + 2.04.0&amp;gt;&amp;gt;&amp;gt; 2.0 - 11.0&amp;gt;&amp;gt;&amp;gt; 2.0 * 3.06.0&amp;gt;&amp;gt;&amp;gt; 2 ** 3.08.0&amp;gt;&amp;gt;&amp;gt; 17 % 3.02.0## 窄类型 int 转换为宽类型 float 进行比较&amp;gt;&amp;gt;&amp;gt; 1 == 1.0True&amp;gt;&amp;gt;&amp;gt; [1, 2] == [1.0, 2.0]True字符串（str）字符串的 单引号 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&#39;I am a string&#39;)I am a string&amp;gt;&amp;gt;&amp;gt; print(&#39;I\\&#39;m a string&#39;) # 单引号中如果要包含单引号，需要用反斜杠(\\)转义I&#39;m a string&amp;gt;&amp;gt;&amp;gt; print(&#39;I am a &quot;string&quot;&#39;) # 单引号中可以包含双引号(&quot;)I am a &quot;string&quot;字符串的 双引号 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&quot;I am a string&quot;)I am a string&amp;gt;&amp;gt;&amp;gt; print(&quot;I am a \\&quot;string\\&quot;&quot;) # 双引号中如果要包含双引号，需要用反斜杠(\\)转义I am a &quot;string&quot;&amp;gt;&amp;gt;&amp;gt; print(&quot;I&#39;m a string&quot;) # 双引号中可以包含单引号(&#39;)I&#39;m a string字符串的 三引号 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&#39;&#39;&#39;I am a string&#39;&#39;&#39;) # 三个单引号形式I am a string&amp;gt;&amp;gt;&amp;gt; print(&quot;&quot;&quot;I am a string&quot;&quot;&quot;) # 三个双引号形式I am a string&amp;gt;&amp;gt;&amp;gt; print(&#39;&#39;&#39;I&#39;m a &quot;string&quot;&#39;&#39;&#39;) # 三引号中既可以包含单引号，也可以包含双引号I&#39;m a &quot;string&quot;## 三引号中可以包含多行print(&#39;&#39;&#39;I am first lineI am second line&#39;&#39;&#39;)I am first lineI am second line## 三引号中可以在行尾添加反斜杠(\\)表示不换行print(&#39;&#39;&#39;I am first line, \\I am still first line&#39;&#39;&#39;)I am first line, I am still first line字符串的 raw 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&#39; first line \\n second line&#39;) # \\n表示换行 first line second line## 添加r前缀的字符串表示把反斜杠(\\)当作普通字符，而不是转义符&amp;gt;&amp;gt;&amp;gt; print(r&#39; first line \\n still first line&#39;) first line \\n still first line字符串可以用 + 进行拼接：&amp;gt;&amp;gt;&amp;gt; print(&#39;Py&#39; + &#39;thon&#39;)Python字符串也可以用 空格 进行拼接：&amp;gt;&amp;gt;&amp;gt; print(&#39;Py&#39; &#39;thon&#39;)Python&amp;gt;&amp;gt;&amp;gt; s = &#39;thon&#39;&amp;gt;&amp;gt;&amp;gt; print(&#39;Py&#39; s) # 不能用空格连接变量字符串 File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1 print(&#39;Py&#39; s) ^SyntaxError: invalid syntax字符串可以用 * 进行重复：&amp;gt;&amp;gt;&amp;gt; print(&#39;w&#39; * 3)www字符串可以用列表索引截取：&amp;gt;&amp;gt;&amp;gt; s = &#39;Python&#39;&amp;gt;&amp;gt;&amp;gt; s[0]&#39;P&#39;&amp;gt;&amp;gt;&amp;gt; s[-1]&#39;n&#39;&amp;gt;&amp;gt;&amp;gt; s[0:2] # 切片(slice)，切片将在后续章节进一步讲解&#39;Py&#39;布尔（bool）Python 中的布尔值使用 True 和 False 表示(注意区分大小写)，布尔运算符分别为 and、or 和 not ：## and 运算符&amp;gt;&amp;gt;&amp;gt; True and TrueTrue&amp;gt;&amp;gt;&amp;gt; True and FalseFalse&amp;gt;&amp;gt;&amp;gt; False and FalseFalse&amp;gt;&amp;gt;&amp;gt; 5 &amp;gt; 3 and 3 &amp;gt; 1True## or 运算符&amp;gt;&amp;gt;&amp;gt; True or TrueTrue&amp;gt;&amp;gt;&amp;gt; True or FalseTrue&amp;gt;&amp;gt;&amp;gt; False or FalseFalse&amp;gt;&amp;gt;&amp;gt; 5 &amp;gt; 3 or 1 &amp;gt; 3True## not 运算符&amp;gt;&amp;gt;&amp;gt; not TrueFalse&amp;gt;&amp;gt;&amp;gt; not FalseTrue&amp;gt;&amp;gt;&amp;gt; not 1 &amp;gt; 2TruePython 中的 bool 类其实是从 int 类继承实现的，True 和 False 分别是 1 和 0 ：&amp;gt;&amp;gt;&amp;gt; [&#39;a&#39;, &#39;b&#39;][True]&#39;b&#39;&amp;gt;&amp;gt;&amp;gt; [&#39;a&#39;, &#39;b&#39;][False]&#39;a&#39;空（None）空值(None)在 Python 中是一个特殊值，与 JAVA 中的 null 相同，None 和 0 是不相同的，0 是一个 int类型的，是有值的。如果一个函数没有 return 语句，那么默认就会返回 None。参考资料 [Numbers] : https://docs.python.org/3.5/tutorial/introduction.html#numbers [数据类型和变量] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112" }, { "title": "Python 入门 - 2 - 安装和使用", "url": "/posts/python-tutorial-2-install-and-usage/", "categories": "Python 入门", "tags": "python", "date": "2020-03-07 20:03:27 +0800", "snippet": "Windows下载安装包进入 Python 官网的 windows downloads 页面，以 Python 3.5.1 为例，可以看到除了帮助文件之外一共有 6 个安装包可以下载，操作系统位数分为 32 位(X86)和 64 位(x86-64)，安装包类型分为 embeddable、executable、web-based 三种，所以一共有 2*3 = 6 个安装包可下载。需要注意的是从 Python 3.5 开始就只支持 Windows Vista 及以上的版本，如果是 Windows XP 则只能选择安装 Python 3.4。如何查看操作系统版本和位数可以参考 微软官方帮助文档。3 种不同类型的安装包区别如下： embeddable：嵌入式包，相当于绿色版 Python，短小精干且无需安装，可直接嵌入到其他应用中使用 executable：离线安装包，包含默认安装所需的所有组件，可用于离线安装 web-based：在线安装包，只是一个安装器，在安装过程种需要联网下载安装所需的组件图形界面安装下面以 Python 3.5 为例进行说明，双击安装包进入图界面安装：如果选择 Install Now，会安装到当前用户目录下，也就是说安装后只有当前用户可以使用。如果选择 Customize installation ，可以选择为所有用户安装，也可以自定义安装路径。如果同时安装了多个版本，推荐都勾选上 Install launcher for all users，安装好之后可以使用 py 命令指定运行版本，比如同时安装了 3.5 和 3.7，则可以使用 py -3.5 或 py -3.7指定运行版本。更多关于 Python Launcher 的内容可以参考官方文档 Python Launcher for Windows如果不是多版本并存的系统上，建议都勾选上 Add Python 3.5 to PATH，这样会把 Python 的安装路径自动添加到环境变量 PATH 中，避免在命令行中执行 python 命令时系统不能识别。如果是多版本并存的系统上可以不用勾选，然后都使用 Python Launcher 进行多版本管理。命令行安装可能很多同学不知道，Windows 下的 Python 安装包其实也支持命令行的方式安装，这个在用于制作自动安装程序或者批量安装时非常有用。我们以下载的 64 位的 3.5.1 的安装包为例，下载后的安装包名称为 python-3.5.1-amd64.exe，在命令行(cmd)中切换到安装包所在路径，然后执行 python-3.5.1-amd64.exe /?，可以看到如下图所示的命令行安装帮助：可以使用 name=value 的方式指定安装参数，比如为所有用户安装 InstallAllUsers=1，还有自动添加安装路径到 PATH 环境变量 PrependPath=1，完整的安装参数请参考官方文档 Installing Without UI。比如以下安装命令就表示不需要用户干预但是会显示安装过程的自动安装，并且为所有用户安装，并且自动添加安装路径到 PATH 环境变量：python-3.5.1-amd64.exe /passive InstallAllUsers=1 PrependPath=1Linux大多数的 Linux 发行版都自带了 Python2，系统自带的 python2 一定不要删除，因为通常会有一些系统自带软件依赖于它，如果要安装 Python3 可以通过下面几种方式。通过安装源在线安装如果你的电脑可以连接互联网，或者在一个内部网络上但是有内部安装源，推荐使用这种方式。不同的 Linux 发行版有不同的安装源工具，以 CentOS7 为例，CentOS7 自带的 python 版本是 2.7，CentOS 上的安装源工具是 yum，我们可以通过命令 yum install python3 来安装 Python3，目前 CentOS7 官方 yum 源的 python3 的版本应该是 3.7，安装完成后可通过键入 python3 查看是否安装成功需要注意的是在 CentOS 上安装好 Python3 后一定不能修改系统默认链接 /usr/bin/python 指向 python3，否则运行 yum 时会得到如下错误： File &quot;/usr/bin/yum&quot;, line 30 except KeyboardInterrupt, e: ^SyntaxError: invalid syntax这是由于 yum 依赖于系统自带的 python2，改成 python3 之后由于语法不兼容，所以会出现错误。所以应该保持链接 /usr/bin/python 始终执行系统自带的 python2。如果在其他 Linux 发行版上也遇到类似问题可以参考这种情况。使用包管理器离线安装不同的 Linux 发行版也有不同的包管理方式，安装源在线安装本质上就是自动从源上下载安装包然后使用包管理器进行安装。好处是方便，但是如果电脑不能联网就只能提前下载好安装包，然后使用系统自带的包管理器进行离线安装。还是以 CentOS7 为例，CentOS 的包管理器是 rpm，比如已经下载好的 rpm 安装包名为 python35-3.5.1-xxx.rpm，那么可以使用命令 rpm -ivh python35-3.5.1-xxx.rpm 进行离线安装。离线安装包的下载可以通过各 Linux 发行版官网进行下载，也可以通过国内的镜像源网站下载，速度会比国外的快一些，这里列出几个常用的国内源： 清华大学：https://mirrors.tuna.tsinghua.edu.cn/ 网易：http://mirrors.163.com/ 阿里巴巴：https://developer.aliyun.com/mirror/使用源码编译安装Python 官网提供 源码下载，下载解压后可通过 make 三连击 ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install 进行编译安装，前提是系统上已经配置好 gcc 等编译安装环境，如果对 Linux 不是很熟悉的用户不推荐使用此方式，因为出现安装问题的解决难度较大。macOSmacOS 是在 BSD(Berkeley Software Distribution)的基础上发展而来，而 BSD 是一个派生自 Unix 的操作系统，而 Linux 又是一个类 Unix 系统，所以 macOS 安装 Python 的方式也和 Linux 大体上差不多，主要分下面两种方式。需要注意的是 macOS 同样也自带了 python2，系统自带的一些软件也会依赖于此，所以也一定不能删除。以 macOS 10.15 为例，自带的 python2.7 安装在 /System/Library/Frameworks/Python.framework/Versions/2.7 路径下。使用 Homebrew 在线安装Homebrew 是 macOS 上的一种安装源工具，类似于 CentOS 的 yum，直接使用如下命令安装即可：brew install python3图形界面安装可去 Python 官网下载 macOS installer，下载后双击进行图形界面安装，安装选项说明大体和 Windows 类似，这里不再赘述。Python 命令行使用除了在命令行直接键入 python 进入 Python 交互式命令行的使用方式外，在命令行下使用 Python 通常还有下面三种方式python -c command通过这种方式可以快速的执行 python 命令：python -c &quot;print(&#39;hello, world!&#39;)&quot;python stript通过这种方式可以直接执行一个脚本文件：python mystript.pypython -m module_name通过这种方式调用一个安装好的 python 模块，比如可以使用 python 自带的 http.server 模块临时启动一个 http 服务器：python -m http.server参考资料 [Python 安装] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624 [Python Setup and Usage] ：https://docs.python.org/3.5/using/index.html" }, { "title": "Python 入门 - 1 - 简介", "url": "/posts/python-tutorial-1-introduction/", "categories": "Python 入门", "tags": "python", "date": "2020-03-04 17:43:50 +0800", "snippet": "Python 简介Python 是由荷兰人 Guido van Rossum (“龟叔”)于 1989 年圣诞节期间，为了打发时间而编写。Python 这个名字取自作者很喜欢的 BBC 电视剧”Monty Python’s Flying Circus”。Python 是在另一种编程语言 ABC 的基础上发展而来，ABC 是“龟叔”参与设计的一种教学语言，他认为 ABC 非常优美和强大，但是并没有取得成功，他认为是没有开放造成的，所以 Python 进行了开源。Python 还结合了很多 C 语言的使用习惯，比如 Python 中的 open 函数和 C 语言的 open 函数非常类似，Python 里同样也有文件描述符等概念。Python 是一种 解释型、面向对象 的语言，相比较而言 C 则是 编译型、面向过程 的语言。解释型语言使用解释器在运行期间动态的逐条将语句解释为计算机可识别的机器代码，编译型语言需要提前把源代码编译为机器代码，然后运行。解释型语言相比编译型语言的主要缺点是运行速度慢，但是由于很多的应用不需要追求很高的性能，所以使用解释型语言已经完全满足运行速度的要求。解释型语言相比编译型语言的主要优点是开发速度快，因为开发过程中可以不用编译就立即运行而得到反馈，另外像 Python 这样的高级语言做了更高程度的抽象和封装，并且把很多常用操作封装为了标准库，所以在代码量上会比 C 语言少很多。而且 Python 可以使用即时编译(JIT)技术提高运行速度面向对象和面向过程语言的主要区别是面向对象可以定义类(class)，而面向过程语言只能定义函数，Python 既支持面向过程，也支持面向对象。关于面向对象和面向过程的更多区别请点击对应的链接进行深入了解。Python 应用近些年来 Python 越来越火，应用也越来越广泛，根据编程语言排行榜 TIOBE 2020 年 2 月最新的数据显示，目前 Python 的流行程度排行第 3，居于 Java 和 C 之后。很多我们所熟知的网站也是使用 Python 开发，比如国外的 Youtube 、Instgram，国内的知乎、豆瓣，还有像 Google 、Yahoo 这样的大公司内部都在大量的使用 Python。Python 在人工智能领域也非常流行，很多人工智能框架都选择使用 Python 语言，比如大名鼎鼎的 Google 人工智能框架 TensorFlow 就支持 Python。另外 Python 在自动化测试方面也是应用广泛，比如开源的自动化测试框架 RobotFramework 就是使用 Python 编写的，很多公司在自己开发自动化测试框架时也大多选择使用 Python，比如华为就是在大量的使用 Python 来进行自动化测试。由于 Python 简单、易学、易用的特点，所以在非编程相关的工作上也可以使用，比如日常办公中需要在大量的文本文件中搜索并替换某些内容，或者需要批量的整理操作大量文件，这个时候可以使用 Python 快速的编写一些小脚本来提升工作效率。相比 shell 或者 bat 等操作系统专用的脚本，Python 的跨平台特性使得使用 Python 编写的脚本使用更方便。而且目前的大多数 Linux 发行版和 OSX 等系统上都内置了 Python。可以在 Python 官网 https://www.python.org/about/apps/ 上看到 Python 的很多应用列表。Python 版本Python 自诞生以来经历了 2 个主要的大版本，一个是发布于 2000 年的 Python2，另一个是发布于 2008 年的 Python3。Python3 相比 Python2 有了很大的变更，所以 Python2 下编写的代码是不能直接在 Python3 上运行的。而且官方已经于 2020.1.1 停止了对 Python2 的维护，也就是说如果 Python2 出现了重大漏洞也不会再有更新的修复版本发布了，所以建议如果是新写的项目都使用 Python3。如果由老的 Python2 的应用需要迁移到 Python3，可以参考官方迁移指南：https://docs.python.org/3/howto/pyporting.html更多关于 Python2 和 Python3 的区别可以参考：http://python-future.org/compatible_idioms.htmlPython 解释器通常我们说 Python 是用 C 语言编写的，是因为官方下载的解释器 CPython 是使用 C 语言编写的，其实除了 CPython 之外还有很多其他的解释器。 以下内容引用自：https://www.liaoxuefeng.com/wiki/1016959663602400/1016966024263840 IPythonIPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了 IE。CPython 用&amp;gt;&amp;gt;&amp;gt;作为提示符，而 IPython 用In [序号]:作为提示符。 PyPyPyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到 PyPy 下执行，就需要了解 PyPy 和 CPython 的不同点。 JythonJython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。 IronPythonIronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。Python 编辑器(IDE)有很多的编辑器支持编写和调试 Python 程序，以下列出几个比较流行的，可以根据个人喜好进行选择： IDLE ：这个 Python 官方的 IDE，Windows 上安装 Python 后就会有，功能较简单，可以用于学习和测试一些语法。 PyCharm ：这个是由 JetBrains 开发的 Python IDE，功能强大，有专业版和社区版，个人使用可以选择免费的社区版。 VSCode ：这个是微软的 Visual Studio 的精简版，开源且支持大量的插件，通过安装 Python 插件可以用于 Python 开发。 Vim ：如果是 Linux 下也可以使用这 Vim 加一些插件进行 Python 开发。参考资料 [Python 简介] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959735620448 [Whetting Your Appetite] ：https://docs.python.org/3.5/tutorial/appetite.html [Python-wikipedia] ：https://zh.wikipedia.org/wiki/Python#cite_note-python_history-3" } ]
