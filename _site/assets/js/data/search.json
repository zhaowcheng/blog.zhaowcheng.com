[
  
  {
    "title": "GCC 编译过程",
    "url": "/posts/gcc-compilation-process/",
    "categories": "Linux 打包",
    "tags": "gcc",
    "date": "2025-07-17 15:56:00 +0800",
    "content": "概述  GCC 编译 C/C++ 代码的过程主要分为如下图的 4 个步骤（.i 和 .ii 分别是 .c 和 .cpp 源文件预处理后的中间文件后缀名；.o 和 .obj 分别是 Linux 和 Windows 系统上汇编后的目标文件后缀名；.a 和 .lib 分别是 Linux 和 Windows 系统上静态库文件后缀名；.exe 是 Windows 上可执行文件后缀名，Linux 上可执行文件无后缀名；另外，.so 和 .dll 分别是 Linux 和 Windows 系统上动态库文件后缀名；本文只是借用该图所表示的流程，不讨论 Windows 相关内容）：    后续章节我们将以 main.c, utils.h, utils.c 这几个文件（都在同一目录下）为例，分别对这几个步骤进行详细说明，这几个文件的源码分别如下：  // main.c #include &lt;stdio.h&gt; #include \"utils.h\"  int main() {     printf(\"1 + 1 = %d\\n\", add(1, 1));     return 0; }   // utils.h int add(int a, int b); int sub(int a, int b); int mul(int a, int b); int div(int a, int b);   // utils.c #include \"utils.h\"  int add(int a, int b) {     return a + b; }  int sub(int a, int b) {     return a - b; }  int mul(int a, int b) {     return a * b; }  int div(int a, int b) {     return a / b; }   预处理（Preprocessing）  预处理主要做了以下这些方面的工作：    插入头文件（#include）。   展开宏定义（#define）。   处理条件编译（#if, #elif, #else, #endif, #ifdef）。   保留 #pragma 指令，编译器需要使用。   删除注释。   添加行号和文件名标识，比如 # 4 \"main.c\" 2，便于编译报错和调试。   可以使用如下命令对 main.c 做预处理： $ gcc -E -I. -o main.i main.c      -E: 表示只做预处理。   -I.: 表示把当前工作目录 . 添加到头文件搜索目录列表中。   -o main.i: 表示把结果输出到 main.i 文件中。   预处理生成的中间文件 main.i 有很多内容，这里只展示一下最后包含 main.c 源码的部分： # 943 \"/usr/include/stdio.h\" 3 4  # 3 \"main.c\" 2 # 1 \"./utils.h\" 1  int add(int a, int b); int sub(int a, int b); int mul(int a, int b); int div(int a, int b); # 4 \"main.c\" 2  int main() {     printf(\"1 + 1 = %d\\n\", add(1, 1));     return 0; }   C/C++ 语言中包含头文件的写法有如下 2 种：    尖括号形式: #include &lt;stdio.h&gt;，通常用于包含系统头文件。   双引号形式: #include \"mylib.h\"，通常用于包含用户头文件。   可以添加头文件搜索目录列表的 GCC 参数如下（更多细节说明请参考官方手册）：    -I dir: 把 dir 添加到头文件搜索目录列表（用户级）。   -iquote dir: 把 dir 添加到头文件搜索目录列表（用户级），仅适用于双引号形式。   -isystem dir: 把 dir 添加到头文件搜索目录列表（系统级）。   -idirafter dir: 把 dir 添加到头文件搜索目录列表（系统级），优先级低于 isystem。   以上这些参数都可以在命令行里指定多次，GCC 会根据指定的顺序依次都添加到搜索目录列表中。  GCC 对于系统头文件和用户头文件会有不同的处理，比如系统头文件会抑制所有告警（即不打印编译告警信息），关于系统头文件的说明，请参考官方手册。  可以添加头文件搜索目录列表的环境变量如下（更多细节说明请参考官方手册）：    CPATH: 对所有语言有效（除 C/C++ 外，GCC 还可以编译 Go, Objective-C/C++, Fortran, Rust 等），效果等同于 -I 参数，但是优先级低于 -I。   C_INCLUDE_PATH: 仅对 C 语言有效，效果等同于 -isystem 参数，但优先级低于 -isystem，也低于 CPATH。   CPLUS_INCLUDE_PATH: 仅对 C++ 语言有效，效果等同于 -isystem 参数，但优先级低于 -isystem，也低于 CPATH。   以上这些环境变量中可以同时添加多个目录，用 PATH_SEPARATOR 进行分隔，Linux 通常为冒号（:），Windows 为分号（;）。也可以包含空路径（整个为空，或者开头/结尾为空，如 :/my/include），当包含空路径时，相当于添加了当前工作目录（.）。  GCC 在被编译时，会根据编译参数和自身内部逻辑判断，生成一个默认系统头文件搜索目录列表，具体生成逻辑较为复杂，但是我们可以通过如下命令查看具体有哪些目录（前提是没有命令行参数和环境变量指定，如果有，该命令也会同时打印出来，就不仅仅是默认系统头文件搜索目录列表了）：  $ gcc -E -xc -v - &lt; /dev/null  ... #include \"...\" search starts here: #include &lt;...&gt; search starts here:  /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include  /usr/local/include  /usr/include End of search list. ...   GCC 在编译 C/C++ 时头文件搜索目录优先级如下：    如果是双引号形式，搜索被编译源文件所在目录。   如果是双引号形式，搜索 -iquote 参数指定的目录。   搜索 -I 参数指定的目录。   搜索 CPATH 环境变量指定的目录。   搜索 -isystem 参数指定的目录。   搜索 C_INCLUDE_PATH/CPLUS_INCLUDE_PATH 环境变量指定的目录。   搜索默认系统头文件目录。   搜索 -idirafter 参数指定的目录。   编译（Compilation）  编译是把预处理后的中间文件编译为汇编源文件（.s），可使用如下命令进行编译： $ gcc -S -o main.s main.i      -S: 表示只做编译，不进行汇编和链接。   -o main.s: 表示把结果输出到 main.s 文件中。   编译后生成的汇编源文件内容如下： $ cat main.s         .file   \"main.c\"         .section        .rodata .LC0:         .string \"1 + 1 = %d\\n\"         .text         .globl  main         .type   main, @function main: .LFB0:         .cfi_startproc         pushq   %rbp         .cfi_def_cfa_offset 16         .cfi_offset 6, -16         movq    %rsp, %rbp         .cfi_def_cfa_register 6         movl    $1, %esi         movl    $1, %edi         call    add         movl    %eax, %esi         movl    $.LC0, %edi         movl    $0, %eax         call    printf         movl    $0, %eax         popq    %rbp         .cfi_def_cfa 7, 8         ret         .cfi_endproc .LFE0:         .size   main, .-main         .ident  \"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)\"         .section        .note.GNU-stack,\"\",@progbits   汇编（Assemble）  编译是把预处理后的中间文件编译为汇编源文件（.s），可使用如下命令进行汇编： $ gcc -c -o main.o main.s      -c: 表示只做编译和汇编，不进行链接。   -o main.o: 表示把结果输出到 main.o 文件中。   汇编后生成目标机器指令的目标文件 main.o，可以用 readelf -s main.o 查看其符号表： $ readelf -s main.o   Symbol table '.symtab' contains 12 entries:    Num:    Value          Size Type    Bind   Vis      Ndx Name      0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c      2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1       3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3       4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4       5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5       6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7       7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8       8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6       9: 0000000000000000    43 FUNC    GLOBAL DEFAULT    1 main     10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND add     11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf   链接（Linking）  链接过程主要是把目标文件们的代码段和数据段拆分后，再加上引用的库和文件头部信息，最后组装成一个可执行文件。  可使用如下命令进行链接（由于输入的是 main.o 文件，所以 GCC 只需执行链接操作）： $ gcc -o main main.o -L. -lutils      -o main: 表示把结果输出到 main 文件中。   -L.: 表示把当前工作目录 . 添加到库文件搜索目录列表中。   -lutils: 表示需要链接 libutils.a 或 libutils.so 库文件。   可以使用 readelf -h main 查看可执行文件的头部信息： $ readelf -h main ELF Header:   Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00    Class:                             ELF64   Data:                              2's complement, little endian   Version:                           1 (current)   OS/ABI:                            UNIX - System V   ABI Version:                       0   Type:                              EXEC (Executable file)   Machine:                           Advanced Micro Devices X86-64   Version:                           0x1   Entry point address:               0x400470   Start of program headers:          64 (bytes into file)   Start of section headers:          6584 (bytes into file)   Flags:                             0x0   Size of this header:               64 (bytes)   Size of program headers:           56 (bytes)   Number of program headers:         9   Size of section headers:           64 (bytes)   Number of section headers:         30   Section header string table index: 29   GCC 链接库文件时优先查找动态库文件（.so），如果动态库文件不存在则查找静态库文件（.a），但是也可以通过参数 -static 强制只链接静态库文件，或者可以通过参数 -Wl,-Bstatic 或 -Wl,-Bdynamic 指定某些库只链接静态库或只链接动态库（详情请参考链接器参数说明）。  GCC 链接静态库文件时会把静态库文件的内容插入到目标文件中，链接动态库文件时只是在目标文件中记录链接信息，目标文件运行时由动态库链接器（ld.so）根据链接信息去查找和加载对应的动态库，动态库的查找顺序请参考《Linux 上 ELF 文件依赖库的查找顺序》。  GCC 在搜索库文件时的优先级如下：    搜索 -L 参数指定的目录。   搜索 LIBRARY_PATH 环境变量指定的目录。   搜索默认库文件目录。   GCC 在被编译时，会根据编译参数和自身内部逻辑判断，生成一个默认库文件搜索目录列表，具体生成逻辑较为复杂，但是我们可以通过如下命令查看具体有哪些目录（前提是没有命令行参数和环境变量指定，如果有，该命令也会同时打印出来，就不仅仅是默认库文件搜索目录列表了）：  $ gcc -print-search-dirs -o main main.c -L. -lutils | grep libraries | sed 's/libraries: *=//' | tr ':' '\\n' /usr/lib/gcc/x86_64-redhat-linux/4.8.5/ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/lib/x86_64-redhat-linux/4.8.5/ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/lib/../lib64/ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../x86_64-redhat-linux/4.8.5/ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/ /lib/x86_64-redhat-linux/4.8.5/ /lib/../lib64/ /usr/lib/x86_64-redhat-linux/4.8.5/ /usr/lib/../lib64/ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/lib/ /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../ /lib/ /usr/lib/   参考资料     [GCC and Make] : https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html   [Options for Directory Search] : https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Directory-Options.html   [Environment Variables Affecting GCC] : https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Environment-Variables.html   [Installing GCC: Configuration] : https://gcc.gnu.org/install/configure.html   [ld Command-line Options] : https://sourceware.org/binutils/docs/ld/Options.html   《嵌入式C语言自我修养：从芯片、编译器到操作系统》   《程序员的自我修养：链接、装载与库》  "
  },
  
  {
    "title": "GLIBC 与 Linux 内核的兼容性",
    "url": "/posts/compatibility-glibc-and-linux-kernel/",
    "categories": "Linux 打包",
    "tags": "glibc, kernel",
    "date": "2025-07-12 10:19:00 +0800",
    "content": "根据 glibc 的 release history 整理出自 2.17 以来的版本与 linux 内核版本的兼容性：                 glibc 版本       兼容的 linux 内核版本                       2.17 ~ 2.19       &gt;= 2.6.16                 2.20 ~ 2.23       &gt;= 2.6.32                 2.24 ~ 2.25       运行时：x86 上要求 &gt;= 2.6.32，其他架构要求 &gt;= 3.2；编译时：所有架构都要求内核头文件版本 &gt;= 3.2                 2.26 ~ 2.41       &gt;= 3.2           glibc 在编译配置时可通过参数 --enable-kernel 指定兼容的最低内核版本，未指定时则默认按照最低兼容配置，对于已编译好的 glibc，可以直接运行 libc.so.6 查看兼容的最低内核版本： $ /lib/x86_64-linux-gnu/libc.so.6  GNU C Library (Ubuntu GLIBC 2.40-1ubuntu3.1) stable release version 2.40. Copyright (C) 2024 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 14.2.0. libc ABIs: UNIQUE IFUNC ABSOLUTE Minimum supported kernel: 3.2.0 For bug reporting instructions, please see: &lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.  "
  },
  
  {
    "title": "PostgreSQL 配置说明",
    "url": "/posts/postgresql-configuration/",
    "categories": "PostgreSQL",
    "tags": "postgresql, unfinished",
    "date": "2025-04-02 12:58:00 +0800",
    "content": "Preface  Write Ahead Log  synchronous_commit (enum)  设置事务提交时需要等到 WAL 被保存到何种程度才返回，下表描述了可设置的值及其说明（数据安全程度依次递减）：                 值       说明                       remote_apply       等到同步备节点回放了 WAL                 on       等到同步备节点把 WAL 写入了磁盘                 remote_write       等到同步备节点把 WAL 写入了文件系统缓存                 local       等到主节点把 WAL 写入了磁盘                 off       不等待           主节点会在 WAL 写入自己的磁盘之后才发送给备节点。  操作系统上数据的写入是先写入文件系统缓存，再刷新到磁盘，如果操作系统故障，文件系统缓存的数据会丢失，所以已写入磁盘的数据安全程度高于文件系统缓存中的数据。  如果 synchronous_standby_names 设置为空，那么 remote_apply、on 和 remote_write 这几个设置都等同于 local。  该参数可以随时修改，比如可以通过 SET LOCAL synchronous_commit TO OFF 命令来临时为当前事务关闭同步等待。  Replication  synchronous_standby_names (string)  指定同步备节点的数量以及可以作为同步备节点的备节点列表，配置同步备节点后，主节点事务提交时需要等待所有同步备节点保存该事务的 WAL 记录，参数只在主节点上生效，语法如下：  [FIRST] num_sync ( standby_name [, ...] ) ANY num_sync ( standby_name [, ...] ) standby_name [, ...]   下面分别对这几种写法进行说明：          [FIRST] num_sync ( standby_name [, …] ) : 在给出的 standby_name 列表中，从前往后选择 num_sync 个 正常（streaming） 的备节点作为同步备节点，在事务提交时等待这些同步备节点保存该事务的 WAL 记录，剩余的则作为潜在（potential）备节点，当有同步备节点发送故障时，则选择优先级最高的潜在备节点来进行替换，FIRST 可以不写，默认即为 FIRST 规则，这种模式也叫做 基于优先级的（priority-based）。           ANY num_sync ( standby_name [, …] ) : 在给出的 standby_name 列表中，在事务提交时等待任意 num_sync 个备节点保存该事务的 WAL 记录，这种模式也叫做 基于规定数量的（quorum-based）。           standby_name [, …] : 9.6 版本以前的写法，现在仍然有效，等同于 FIRST 1 ( standby_name [, ...] )。           通配符 : 以上 3 种写法中的 standby_name [, ...] 部分可以写成 *，表示所有备节点。也可以只写 *，等同于 FIRST 1 (*)。      关于 FIRST 和 ANY 关键字，有如下注意事项：          大小写不敏感。           如果 standby_name 和这两个关键字重名，则需要把 standby_name 用双引号包裹。      关于 num_sync，有以下注意事项：     正常应该配置为小于等于后面给出的 standby_name 的数量，但是如果配置的超过了也没关系，数据库会自动调整为合适的值。   关于 standby_name，有以下注意事项：     standby_name 默认匹配备节点连接信息中的 application_name 字段，如果备节点连接时未设置该字段，则匹配规则如下：            物理复制：如果备节点配置了 cluster_name，则匹配该字段，否则为固定值 walreceiver。       逻辑复制：订阅者名称（subscription name)                standby_name 用来和备节点连接的 application_name 进行比较时，是 大小写不敏感 的。           standby_name 必须是直连到主节点的备节点，不能是级联复制备节点。      如果备节点重名，具体匹配上哪个节点作为同步备节点是不确定的。   如果该参数配置为空（默认值），则相当于禁用同步复制。但是在配置了的情况下，每个事务也可以通过配置 synchronous_commit 为 off 的方式来关闭当前事务的同步等待。  可以从视图 pg_stat_replication 中查询到复制客户端的 状态（sync_state） 和 优先级（sync_priority），关于这两个字段的说明如下：     在给定备节点列表中（standby_name [, ...]）：            FIRST 模式下：                    sync_priority 根据给定顺序，从 1 开始递增，数字越小，优先级越高；           被选定为同步的 sync_state 为 sync，其他的则为 potential；                       ANY 模式下：                    sync_priority 均为 1；           sync_state 均为 quorum；                           而没在给定列表中的 sync_priority 和 sync_state 则为 0 和 async。   Error Reporting and Logging  cluster_name (string)  为当前数据库实例配置一个名称。  该名称会显示在进程标题（process title）中，比如 Linux 上用 ps aux | grep postgres 命令可以看到。  该名称还会作为物理复制备节点连接时 application_name 参数的默认值（连接时也可以指定其他值）。  References     [Server Configuration] : https://www.postgresql.org/docs/17/runtime-config.html  "
  },
  
  {
    "title": "Patroni 配置说明",
    "url": "/posts/patroni-configuration/",
    "categories": "Patroni",
    "tags": "patroni, postgresql",
    "date": "2025-03-27 18:58:00 +0800",
    "content": "1 配置类型          全局配置（Global Configuration）                      作用范围：所有节点。                       修改方式：初始化（bootstrap）前，修改配置文件中的 bootstrap.dcs 部分；初始化后，通过 patronictl edit-config 命令或 REST 接口 /config 修改。                       配置项：https://patroni.readthedocs.io/en/latest/dynamic_configuration.html#dynamic-configuration                       其他说明：Patroni 官方文档中通常叫做 动态配置（dynamic configuration），初始化以后保存在 DCS 中，修改查询均是访问的 DCS，配置文件中的内容将不再有效。                       本地配置（Local Configuration）                      作用范围：单个节点。                       修改方式：启动前，修改配置文件或配置 环境变量（优先级更高）；启动后，修改配置文件，然后通过 patronictl reload 命令或 REST 接口 /reload，或者直接向 Patroni 进程发送 SIGHUP 信号使其生效。                       配置项：https://patroni.readthedocs.io/en/latest/yaml_configuration.html#yaml-configuration                  2 数据库相关配置  在 Patroni 的 全局配置 和 本地配置 的 postgresql 段落中，都可以配置数据库相关配置项，下面把这些配置项分为 数据库参数配置 和 其他数据库配置 两部分来进行说明。  2.1 数据库参数配置  2.1.1 数据库参数分类  在 Patroni 的 全局配置 和 本地配置 的 postgresql.parameters 段落中都能配置数据库参数，但是并不是都能生效，根据其可配置范围，分类如下：     只能全局配置，本地配置无效的数据库参数（由于集群高可用的需要，Patroni 限制这些参数只能全局配置以此保持主备一致），这些参数及其默认值如下：            max_connections: 100       max_locks_per_transaction: 64       max_worker_processes: 8       max_prepared_transactions: 0       wal_level: hot_standby       track_commit_timestamp: off       max_wal_senders: 10       max_replication_slots: 10       wal_log_hints: on（v3 强制为 on，v4 可修改）       wal_keep_segments: 8（PG13 以前）       wal_keep_size: 128MB（PG13 及以后）           全局配置和本地配置中都不能配置（即使配置了也不生效）的数据库参数，这些参数由 Patroni 自动从一些本地配置项里解析出来或者是固定的值，这些参数及其获取方式如下：            listen_addresses: 从本地配置的 postgresql.listen 字段或环境变量 PATRONI_POSTGRESQL_LISTEN 中解析出来。       port: 从本地配置的 postgresql.listen 字段或环境变量 PATRONI_POSTGRESQL_LISTEN 中解析出来。       cluster_name: 从本地配置的 scope 字段或环境变量 PATRONI_SCOPE 中解析出来。       hot_standby: 固定值 on。           全局配置和本地配置中都可配置的数据库参数，都配置的情况下本地配置优先级更高，这些参数就是除了以上 2 类之外的其他所有数据库参数。   上述分类中的第 1 类和第 2 类统称为 Patroni 托管的数据库参数（PostgreSQL parameters controlled by Patroni），Patroni 把除 wal_keep_segments/wal_keep_size 以外的其他参数在数据库启动时通过命令行选项 --name=value 方式传入，以此保证其最高优先级，而不会被其他配置方式（如 ALTER SYSTEM）所覆盖。  2.1.2 数据库参数优先级  Patroni 会把数据库原有配置文件 postgresql.conf 改名为 postgresql.base.conf（不考虑配置由 custom_conf 情况，关于该配置请参考官方文档），然后创建一个新的 postgresql.conf 并在开头 include 'postgresql.base.conf'，然后写入通过 Patroni 配置的数据库参数（包括托管的），所以数据库参数的优先级如下（越靠后优先级越高）：     postgresql.base.conf 中的参数。   postgresql.conf 中的参数。   postgresql.auto.conf 中的参数（即通过 ALTER SYSTEM 命令设置的参数）。   数据库启动时通过命令行选项 --name=value 方式传入的参数。   当数据库参数有变动时，Patroni 会重写 postgresql.conf 文件，所以建议不要直接修改该文件，而是通过 Patroni 来配置。  2.1.3 修改后对重启顺序有要求的数据库参数  通过 Patroni 修改数据库参数后，Patroni 会自动 reload 数据库使其生效，而如果修改的参数需要重启数据库才能生效，Patroni 则只是把需要重启的节点标记为 pending_restart（可通过 patronictl list 命令查看），直到用户通过 patronictl restart 命令或 REST 接口 /restart 来重启数据库后该标记才消除（注意: 如果直接通过 pg_ctl 重启数据库会导致 Patroni 托管的数据库参数没有在命令行传入而失去最高优先级。如果直接重启 Patroni，则可能发生故障转移）。  Patroni 托管的数据库参数中，有一些参数由于涉及到共享内存的使用，备节点在回放 WAL 的时候，可能会使用到和主节点生成这些 WAL 时一样大小的共享内存，所以需要始终保持备节点的配置值 不小于 主节点的，否则备节点可能发生共享内存耗尽的情况，这些参数如下：     max_connections   max_prepared_transactions   max_locks_per_transaction   max_wal_senders   max_worker_processes   当修改这些涉及共享内存使用的数据库参数时，由于它们都是应用到所有节点的全局配置，所以需要重启所有节点数据库使其生效，但是为了保持备节点配置值不小于主节点，根据其修改后的值是增大还是减小，对于重启的顺序要求如下：     修改后的值 增大：            先重启所有备节点；       然后重启主节点；           修改后的值 减小：            先重启主节点；       然后重启所有备节点；           如果修改后的重启顺序与预期相反时，会发生如下情况：          修改后的值增大，但是却先重启主节点，后重启备节点：如果主备重启间隔较短，则无影响，重启后集群正常如初。如果主备重启间隔较大，那么备节点在主节点重启完成后，自己还未重启前，接收到新的 WAL 时发现 WAL 里记录的参数值（WAL 中会记录这些参数当时的值）比自己的参数值大，则会暂定回放并打印 WARNING 日志（hot_standby 为 on 时会暂停，否则会直接退出，但是 Patroni 强制把所有备节点 hot_standby 都配置为 on），而 Patroni 发现数据库的回放暂停后会去恢复回放，这会导致数据库立即关闭，然后 Patroni 会去拉起关闭的数据库，如果拉起成功，则备节点恢复正常状态（如果 PG &lt; 14，无论 hot_standby 什么配置，都不会暂停回放，而是出现进程 crash 导致数据库关闭）。           修改后的值减小，但是却先重启备节点，后重启主节点：Patroni 在重启备节点时会对比这些参数当前全局配置中的值和数据库 pg_controldata 获取到的值（数据库 control 文件中会记录这些值），如果发现当前全局配置中的值比 pg_controldata 获取到的值小，则会以旧参数值（pg_controldata 获取到的值）重启备节点数据库，这样做是为了避免数据库陷入重启死循环，因为如果直接以新参数值重启数据库，数据库在启动时发现新参数值（全局配置中的值）比 control 文件中记录的小，则会打印 FATAL 日志并退出，而 Patroni 发现数据库停止了则会去拉起数据库，从而陷入重启死循环。待主节点重启完成后再次重启备节点才会以新的参数值进行重启。      下面对不同重启顺序进行验证，验证环境的信息如下：  $ patronitl list + Cluster: batman (7469053056424145047) +-----------+----+-----------+ | Member | Host               | Role    | State     | TL | Lag in MB | +--------+--------------------+---------+-----------+----+-----------+ | node1  | 192.168.1.101:5432 | Leader  | running   | 31 |           | | node2  | 192.168.1.102:5432 | Replica | streaming | 31 |         0 | | node3  | 192.168.1.103:5432 | Replica | streaming | 31 |         0 | +--------+--------------------+---------+-----------+----+-----------+ $ patronitl show-config | grep max_connections     max_connections: 100   (1) 验证增大配置后，先重启备节点，再重启主节点：  $ patronitl edit-config -s \"postgresql.parameters.max_connections=200\" ... $ patronitl restart batman node3 ... $ patronitl restart batman node2 ... $ patronitl restart batman node1 ... $ patronitl list + Cluster: batman (7469053056424145047) +---------+----+-----------+ | Member | Host               | Role    | State   | TL | Lag in MB | +--------+--------------------+---------+---------+----+-----------+ | node1  | 192.168.1.101:5432 | Leader  | running | 31 |           | | node2  | 192.168.1.102:5432 | Replica | running | 31 |         0 | | node3  | 192.168.1.103:5432 | Replica | running | 31 |         0 | +--------+--------------------+---------+---------+----+-----------+   (2) 验证减小配置后，先重启主节点，再重启备节点：  $ patronitl edit-config -s \"postgresql.parameters.max_connections=80\" ... $ patronitl restart batman node1 ... $ patronitl restart batman node2 ... $ patronitl restart batman node3 ... $ patronitl list + Cluster: batman (7469053056424145047) +---------+----+-----------+ | Member | Host               | Role    | State   | TL | Lag in MB | +--------+--------------------+---------+---------+----+-----------+ | node1  | 192.168.1.101:5432 | Leader  | running | 31 |           | | node2  | 192.168.1.102:5432 | Replica | running | 31 |         0 | | node3  | 192.168.1.103:5432 | Replica | running | 31 |         0 | +--------+--------------------+---------+---------+----+-----------+   (3) 验证增大配置后，先重启主节点，再重启备节点：  $ patronitl edit-config -s \"postgresql.parameters.max_connections=200\" ... $ patronitl restart batman node1 ... $ patronitl restart batman node2 ... Failed: restart for member node2, status code=503, (restarting after failure already in progress) $ cat postgres.log  # on node2 ... CONTEXT:  WAL redo at 0/1701CFD0 for XLOG/PARAMETER_CHANGE: max_connections=200 max_worker_processes=8 max_wal_senders=10 max_prepared_xacts=0 max_prepared_foreign_transactions=0max_lockss_per_xact=64 wal_level=replica wal_log_hints=on track_commit_timestamp=off LOG:  recovery has paused DETAIL:  If recovery is unpaused, the server will shut down. HINT:  You can then restart the server after making the necessary configuration changes. CONTEXT:  WAL redo at 0/1701CFD0 for XLOG/PARAMETER_CHANGE: max_connections=200 max_worker_processes=8 max_wal_senders=10 max_prepared_xacts=0 max_prepared_foreign_transactions=0max_lockss_per_xact=64 wal_level=replica wal_log_hints=on track_commit_timestamp=off FATAL:  recovery aborted because of insufficient parameter settings DETAIL:  max_connections = 80 is a lower setting than on the primary server, where its value was 200. HINT:  You can restart the server after making the necessary configuration changes. CONTEXT:  WAL redo at 0/1701CFD0 for XLOG/PARAMETER_CHANGE: max_connections=200 max_worker_processes=8 max_wal_senders=10 max_prepared_xacts=0 max_prepared_foreign_transactions=0max_lockss_per_xact=64 wal_level=replica wal_log_hints=on track_commit_timestamp=off LOG:  startup process (PID 2407) exited with exit code 1 LOG:  terminating any other active server processes LOG:  shutting down due to startup process failure LOG:  database system is shut down ... $ cat patroni.log  # on node2 ... INFO: Resuming paused WAL replay for PostgreSQL 14+ INFO: no action. I am (node2), a secondary, and following a leader (node1) WARNING: Postgresql is not running. ... INFO: starting as a secondary INFO: closed patroni connections to postgres INFO: postmaster pid=2734 INFO: Lock owner: node1; I am node2 INFO: restarting after failure in progress INFO: Lock owner: node1; I am node2 INFO: establishing a new patroni heartbeat connection to postgres INFO: no action. I am (node2), a secondary, and following a leader (node1) ... $ patronitl list + Cluster: batman (7469053056424145047) +---------+----+-----------+ | Member | Host               | Role    | State   | TL | Lag in MB | +--------+--------------------+---------+---------+----+-----------+ | node1  | 192.168.1.101:5432 | Leader  | running | 31 |           | | node2  | 192.168.1.102:5432 | Replica | running | 31 |         0 | | node3  | 192.168.1.103:5432 | Replica | running | 31 |         0 | +--------+--------------------+---------+---------+----+-----------+   (4) 验证减小配置后，先重启备节点，再重启主节点：  $ patronitl edit-config -s \"postgresql.parameters.max_connections=80\" ... $ patronitl restart batman node3 ... $ patronitl restart batman node2 ... $ patronitl restart batman node1 ... $ patronitl list + Cluster: batman (7469053056424145047) +-----------+----+-----------+-----------------+--------------------------+ | Member | Host               | Role    | State     | TL | Lag in MB | Pending restart | Pending restart reason   | +--------+--------------------+---------+-----------+----+-----------+-----------------+--------------------------+ | node1  | 192.168.1.101:5432 | Leader  | running   | 31 |           |                 |                          | | node2  | 192.168.1.102:5432 | Replica | streaming | 31 |         0 | *               | max_connections: 100-&gt;80 | | node3  | 192.168.1.103:5432 | Replica | streaming | 31 |         0 | *               | max_connections: 100-&gt;80 | +--------+--------------------+---------+-----------+----+-----------+-----------------+--------------------------+ $ cat patroni.log  # on node2 ... INFO: max_connections value in pg_controldata: 100, in the global configuration: 80. pg_controldata value will be used. Setting 'Pending restart' flag ... $ patronitl restart batman node3 ... $ patronitl restart batman node2 ... $ patronitl list + Cluster: batman (7469053056424145047) +-----------+----+-----------+ | Member | Host               | Role    | State     | TL | Lag in MB | +--------+--------------------+---------+-----------+----+-----------+ | node1  | 192.168.1.101:5432 | Leader  | running   | 31 |           | | node2  | 192.168.1.102:5432 | Replica | streaming | 31 |         0 | | node3  | 192.168.1.103:5432 | Replica | streaming | 31 |         0 | +--------+--------------------+---------+-----------+----+-----------+   2.2 其他数据库配置  除数据库参数以外的其他数据库配置项，根据其可配置范围，分类如下：     只能全局配置，本地配置无效的配置项：            use_slots           只能本地配置，全局配置无效的配置项：            connect_address       proxy_address       listen       config_dir       data_dir       pgpass       authentication           全局配置和本地配置中都能配置的配置项（本地配置优先级更高），这些是除了以上 2 类和数据库参数（postgresql.parameters）以外的其他数据库配置项。   3 全局配置备份文件  Patroni 在首次启动时会把 DCS 中的全局配置转储到数据库数据目录下的 patroni.dynamic.json 文件中，当全局配置有变化时也会更新该文件，如果 DCS 中的全局配置丢失，主节点会使用该文件来恢复全局配置。  4 配置文件生成与校验  使用 patroni 程序可以进行配置文件的生成和校验，以下是命令示例，具体说明请参考官方文档。  (1) 生成示例文件（用户需要根据实际环境信息进行修改后才可使用）：  $ patroni --generate-sample-config patroni.yml   (2) 生成指定环境的配置文件（可直接使用）：  $ patroni --generate-config --dsn \"host=192.168.1.101 port=5432 dbname=postgres user=postgres password=postgres\" patroni.yml   (3) 校验配置文件：  $ patroni --validate-config patroni.yml    5 参考资料          [Patroni configuration] : https://patroni.readthedocs.io/en/latest/patroni_configuration.html           [Hot Standby Administrator’s Overview] : https://www.postgresql.org/docs/current/hot-standby.html#HOT-STANDBY-ADMIN     "
  },
  
  {
    "title": "PostgreSQL 高可用（high availability)",
    "url": "/posts/postgresql-high-availability/",
    "categories": "PostgreSQL",
    "tags": "postgresql, high-availability, unfinished",
    "date": "2025-03-18 22:40:00 +0800",
    "content": "1 简介  主节点持续归档/传送 WAL，备节点持续恢复/接收 WAL 并回放（replay），以此实现一个高可用集群，这种方式叫做 log shipping，这样的备节点也叫做 warm standby，如果备节点还可以接受 只读查询，则叫做 hot standby。  PostgreSQL 支持 2 种级别的 log shipping：          文件级（file-based）：主节点配置 archive_command 持续归档 WAL 文件，备节点配置 restore_command 持续恢复 WAL 文件并回放。           记录级（record-based）： 主节点持续传送 WAL 记录，备节点持续接收 WAL 记录并回放，即 流复制（streaming replication）。      2 环境要求          硬件：主备节点之间的 CPU 架构必须相同（不同架构下的数据类型长度可能不同，从而导致存储结构的差异）。           版本：主备节点之间的 major 版本必须相同（minor 版本可以不同，通常 minor 版本之间的存储结构不发生变化，但是官方不对此做正式保证，所以建议主备之间版本尽量一致；如果需要升级整个集群的 minor 版本，建议先升级备节点，再升级主节点）。           表空间（TABLESPACE）：主备节点之间必须存在相同的表空间路径。      3 备节点基本原理  当一个数据库实例的数据目录（datadir）下存在 standby.signal 文件时，该实例启动时则进入 备节点模式（standby mode）。  备节点模式下启动，数据库按照如下顺序读取 WAL 并回放：          如果配置了 restore_command，则调用 restore_command 从归档中恢复 WAL 并回放直到 restore_command 失败为止。           然后读取 pg_wal 目录中的所有可用 WAL 并回放直到结束；           然后，如果配置了流复制，则通过流复制从主节点持续接收 WAL 并回放；           如果流复制断开，则重新从第 1 步开始，如此循环往复；      当备节点执行升主操作（pg_ctl promote 或调用 pg_promote() 函数）后，则退出备节点模式，但是在升主前，会把 归档 和 pg_wal 中的可用 WAL 都先回放了。  4 文件级（持续归档和恢复）  4.1 主节点配置          配置 archive_mode 参数为 on。           配置 archive_command 参数来持续归档 WAL 到一个即使主节点挂掉了，备节点也能访问的地方，可以是第三方节点或者就在备节点上。      4.2 备节点配置          使用 pg_basebackup 命令从主节点拉取数据目录，如 pg_basebackup -P -h &lt;PRIMARY_NODE_IP&gt; -U &lt;REPLICATION_USER&gt; -p &lt;DBPORT&gt; -D &lt;DATADIR&gt;。           配置 restore_command 参数来从归档持续恢复 WAL 文件并回放。           配置 archive_mode 和 archive_command 参数和主节点一样，以备当前备节点提升为主节点后能继续归档（除非 archive_mode 为 always，否则备节点模式下不会执行归档命令）。           配置 recovery_target_timeline 为 latest（默认值），以此保证当发生切主到其他备节点时，当前备节点能及时跟随新主。           如果只有一主一备，则可以同时在 archive_cleanup_command 参数中调用 pg_archivecleanup 命令来自动清理当前备节点已不再需要的 WAL 文件。           在数据目录下创建 standby.signal 文件并启动数据库。      4.3 备节点配置持续归档  当 archive_mode 参数配置为 always 时，备节点模式下仍然会执行 archive_command 来归档 WAL 文件。这通常用在级联复制的上游（upstream）备节点中，用于给下游（downstream）备节点提供归档。  5 记录级（流复制）  5.1 主节点配置          配置 listen_addresses 参数为包括备节点 IP 的范围，如 *。           创建一个带 REPLICATION 权限的用户，如 CREATE USER &lt;REPLICATION_USER&gt; PASSWORD '&lt;REPLICATION_PWD&gt;' REPLICATION;。           在 pg_hba.conf 文件中增加允许备节点访问的配置，如 host replication &lt;REPLICATION_USER&gt; &lt;STANDBY_NODE_IP&gt;/32 md5（database 列配置为虚拟数据库名 replication）。           配置 max_wal_senders 参数为足够所有备节点使用的值。           为了防止 WAL 文件在备节点接收前被回收，可以配置 wal_keep_size 参数或 复制槽 来为备节点保留 WAL。           在支持 socket keepalive 的系统上，可以配置 tcp_keepalives_idle、tcp_keepalives_interval 和 tcp_keepalives_count 这几个参数来帮助主节点及时发现流复制连接断开情况。      5.2 备节点配置          使用 pg_basebackup 命令从主节点拉取数据目录，如 pg_basebackup -P -h &lt;PRIMARY_NODE_IP&gt; -U &lt;REPLICATION_USER&gt; -p &lt;DBPORT&gt; -D &lt;DATADIR&gt;。           配置 primary_conninfo 参数连接到主节点，如 primary_conninfo = 'host=&lt;PRIMARY_NODE_IP&gt; port=&lt;DBPORT&gt; user=&lt;REPLICATION_USER&gt; password=&lt;REPLICATION_PWD&gt;'。           在数据目录下创建 standby.signal 文件并启动数据库。           启动并连接成功后，可以在备节点看到一个 walreceiver 进程，还可以在主节点看到一个 walsender 进程。      5.3 复制槽  如果流复制备节点连接断开后过了较长时间才恢复连接，那么有些还没有被备节点接收的 WAL 文件可能在主节点已经被回收，导致备节点无法追赶（catch-up）上主节点。我们可以通过配置 wal_keep_size 参数或 复制槽 来避免该问题。但是配置 wal_keep_size 的方式需要估计一个比实际需要保存更大的值，这样就会又些冗余文件的方式，而 复制槽 的方式则更精确，仅保留未被绑定到该复制槽上的备节点们接收的 WAL 文件。  需要注意的是配置复制槽后，如果备节点长期离线，可能会导致主节点积压过多的 WAL 文件而占用大量空间，为了避免该问题，可以配置 max_slot_wal_keep_size 参数来限制保留的最大值。  可以通过 流复制协议 或 相关 SQL 函数 来创建管理复制槽，比如：  postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');   slot_name  | lsn -------------+-----  node_a_slot |  postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;   slot_name  | slot_type | active -------------+-----------+--------  node_a_slot | physical  | f (1 row)   备节点通过配置 primary_slot_name 参数来绑定复制槽，比如：  primary_slot_name = 'node_a_slot'   5.4 级联复制  备节点可以不连接主节点而连接其他备节点并接收 WAL，这样所组成的多级流复制拓扑就是 级联复制（cascading replication），这样可以减少主节点的连接数量以此减少主节点的带宽占用。  级联复制的层级数量不受限制，更靠近主节点一端备节点被称为 上游节点（upstream），离主节点更远一端的节点则被称为 下游节点（downstream），一个备节点可以有多个下游，但是只能有一个上游（流复制本身也只能连接到一个发送方，即只能配置一个 primary_conninfo）。  级联复制中的上游节点不仅发送自己接收到的 WAL，如果配置了持续恢复（restore_command），还会发送恢复出来的 WAL（主节点不会，因为主节点不会执行 restore_command），所以即使上游节点与更上游节点的连接断开，只要有持续恢复出来的新的可用的 WAL，还是会继续向下游节点发送（也就是说上游节点可以是 file-based 方式的备节点）。  级联复制中只有 直接备节点（直连到主节点） 支持同步，其他 间接备节点 只能是异步的，就算是在主节点 synchronous_standby_names 参数中指定了级联复制中的间接备节点也不会产生作用。  如果级联复制备节点中开启了 hot_standby_feedback 参数，那么该备节点的 feedback 消息会逐级往上传播直到主节点。  如果上游节点提升为了主节点，下游节点在配置 recovery_target_timeline 参数为 latest（默认值）的情况下，会自动跟随新主。  要使用级联复制，上游节点除了需要像主节点一样的相关配置（listen_addresses、pg_hba.conf、max_wal_senders、wal_keep_size 或复制槽）之外，还需要配置 hot_standby 参数为 on（也就是设置为热备），因为备节点的流复制连接需要进行一些必要的只读查询。  5.5 同步复制（synchronous replication）  流复制默认是 异步（asynchronous） 的，即一个事物在主节点提交后如果马上去备节点查询，有可能还查询不到，因为 WAL 记录可能还没有传送到备节点或者备节点还没有回放该记录。  可以把一个或多个备节点指定为 同步（synchronous） 备节点，配置了同步备节点的流复制集群，在事务提交时需要 一直等待 直到收到同步备节点回复的 WAL 记录已保存的消息后，才给客户端返回成功。  以下情况不需要等待同步备节点回复：    只读事务（read-only transactions）   事务回滚（transaction rollbacks）   子事务（subtransaction）   数据载入（data loading）   索引构建（index building）   同步备节点可以是 物理（流）复制备节点（physical/stream replication standby），也可以是 逻辑复制订阅者（logical replication subscriber），也可以是其他一些第三方程序，比如 pg_receivewal 和 pg_recvlogical 等。  发生 fast shutdown 请求时，数据库会将正在等待的同步备节点的事务提交立即返回给客户端让其停止等待，但是仍然会等到 WAL 都已发送到所有备节点后才关闭（异步情况下也是如此）。  启用同步复制，需要在发送节点同时配置参数 synchronous_commit 和 synchronous_standby_names，配置说明请点击对应参数链接查看。  如果因为同步备节点故障导致事务提交被阻塞，可以设置 synchronous_standby_names 参数为空并 reload 来立即关闭同步模式，从而解决阻塞的问题：  ALTER SYSTEM SET synchronous_standby_names TO ''; SELECT pg_reload_conf();   5.6 状态查询  查询流复制状态主要通过以下函数和视图：                 函数/视图       说明       使用范围/条件                       pg_current_wal_flush_lsn()       已刷盘的最新的 LSN       恢复状态下不可用                 pg_current_wal_lsn()       已写入文件系统缓存的最新的 LSN       恢复状态下不可用                 pg_current_wal_insert_lsn()       已插入 WAL 缓存的最新的 LSN       恢复状态下不可用                 pg_last_wal_receive_lsn()       已收到并且已刷盘的最新的 LSN       没有 receiver 进程则返回 NULL                 pg_last_wal_replay_lsn()       恢复状态下已回放的最新的 LSN       非恢复状态下则返回 NULL                 pg_stat_replication       每个 sender 进程对应流复制的状态信息       N/A                 pg_stat_wal_receiver       receiver 进程对应的流复制状态信息       N/A              注：一个数据库实例最多只能有一个 receiver。   6 文件级 + 记录级  同时配置文件级和记录级的 log shipping 可以达到更佳的效果，例如当备节点长时间离线后重新回归时，主节点上有些 WAL 可能已经被回收，但是备节点可以通过持续恢复从归档中获取 WAL，避免了 WAL 缺失导致的备节点回归失败。  7 热备（hot standby）  当数据库 hot_standby 参数配置为 on 时，则在恢复状态下仍然可以接受 只读查询，所以如果备节点开启了该参数，也就可以同时接受只读查询，也就是一个 热备（hot standby）。  8 故障转移（failover）  当主节点故障时，备节点可以通过执行 pg_ctl promote 命令或者 pg_promote() 函数来升级为主节点，以此实现故障转移。  故障切换后，原主节点故障修复后应该配置为备节点跟随新主节点，如果仍然以主节点启动，将会导致脑裂（即存在多个主节点）。  可以使用 pg_rewind 帮助原主节点作为备节点快速同步新主节点的数据。  9 参考资料     [High Availability, Load Balancing, and Replication] : https://www.postgresql.org/docs/17/high-availability.html  "
  },
  
  {
    "title": "PostgreSQL 版本策略（versioning policy)",
    "url": "/posts/postgresql-version-policy/",
    "categories": "PostgreSQL",
    "tags": "postgresql, versioning",
    "date": "2025-03-11 21:52:00 +0800",
    "content": "版本号                 时期       格式       major       minor                       V10 以前       X.Y.Z       X.Y       Z                 V10 及以后       X.Y       X       Y           周期                 版本类型       发布周期       改动范围       生命周期                       major       1 年       不向后兼容的重大改动和新特性等       5 年                 minor       3 个月（除此外如有紧急修复，也以 minor 发布，如 17.2）       向后兼容的 bug 修复、安全修复和小幅改进等       -           升级                 升级路径       升级方式                       跨 major 版本       使用 pg_dumpall、pg_upgrade、logical replication 等工具或方式，详情见 官方文档                 跨 minor 版本       可以通过直接替换安装目录的方式实现           参考资料     [Versioning Policy] : https://www.postgresql.org/support/versioning/   [Roadmap] : https://www.postgresql.org/developer/roadmap/  "
  },
  
  {
    "title": "使用 iptables 为 KVM 虚拟机实现桥接网络",
    "url": "/posts/kvm-bridge-by-iptables/",
    "categories": "计算机网络",
    "tags": "network, kvm, bridge, iptables",
    "date": "2025-02-21 20:59:00 +0800",
    "content": "适用场景  我把一台笔记本电脑安装了 Linux，准备用来作为 KVM 虚拟机服务器，这台笔记本只有无线网卡，当我想把这个无线网卡桥接到虚拟机时，始终无法成功，网上也查了很多资料，始终没有解决。  最终决定放弃桥接网络，改用 NAT 端口转发来实现外部访问虚拟机，然后参考了 Libvirt 文档 通过 iptables 配置了端口转发，用了一段时间后发现把这个配置稍加改造就可以达到和桥接网络一样的效果。  如何实现  笔记本网卡信息如下（wlp0s20f3 是无线网卡，virbr0 是安装 KVM 后自动生成的虚拟网卡）：  $ ip address  1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00     inet 127.0.0.1/8 scope host lo        valid_lft forever preferred_lft forever     inet6 ::1/128 scope host noprefixroute         valid_lft forever preferred_lft forever 2: wlp0s20f3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000     link/ether 74:3a:f4:35:c1:cc brd ff:ff:ff:ff:ff:ff     inet 192.168.1.100/24 brd 192.168.1.255 scope global noprefixroute wlp0s20f3        valid_lft forever preferred_lft forever     inet6 240e:333:2bba:cb00:fb2:52e7:1762:b80f/64 scope global temporary dynamic         valid_lft 213162sec preferred_lft 86001sec     inet6 240e:333:2bba:cb00:4931:9362:97c8:57e9/64 scope global dynamic mngtmpaddr noprefixroute         valid_lft 213162sec preferred_lft 126762sec     inet6 fe80::daca:13ec:24af:c779/64 scope link noprefixroute         valid_lft forever preferred_lft forever 3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000     link/ether 52:54:00:ab:7d:a0 brd ff:ff:ff:ff:ff:ff     inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0        valid_lft forever preferred_lft forever   我安装了 3 台虚拟机：  $ virsh list --all  Id   Name             State ---------------------------------  -    el7-x86_64-101   shut off  -    el7-x86_64-102   shut off  -    el7-x86_64-103   shut off   为这 3 台虚拟机配置静态 IP 地址，信息如下：                 虚拟机       IP       网关       DNS                       el7-x86_64-101       192.168.122.101/24       192.168.122.1       192.168.122.1                 el7-x86_64-102       192.168.122.102/24       192.168.122.1       192.168.122.1                 el7-x86_64-103       192.168.122.103/24       192.168.122.1       192.168.122.1           为了能从其他电脑直接访问这 3 台虚拟机，需要为这 3 台虚拟机分别分配一个外部可以访问的 IP（即与无线网卡 wlp0s20f3 在同一网段内的 IP 地址），分配如下：                 虚拟机       外部 IP                       el7-x86_64-101       192.168.1.101/24                 el7-x86_64-102       192.168.1.102/24                 el7-x86_64-103       192.168.1.103/24           接下来就把分配的这 3 个 外部 IP 都配置到无线网卡 wlp0s20f3 上，配置后信息如下：  $  ip address  1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00     inet 127.0.0.1/8 scope host lo        valid_lft forever preferred_lft forever     inet6 ::1/128 scope host noprefixroute         valid_lft forever preferred_lft forever 2: wlp0s20f3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000     link/ether 74:3a:f4:35:c1:cc brd ff:ff:ff:ff:ff:ff     inet 192.168.1.100/24 brd 192.168.1.255 scope global noprefixroute wlp0s20f3        valid_lft forever preferred_lft forever     inet 192.168.1.101/24 brd 192.168.1.255 scope global secondary noprefixroute wlp0s20f3        valid_lft forever preferred_lft forever     inet 192.168.1.102/24 brd 192.168.1.255 scope global secondary noprefixroute wlp0s20f3        valid_lft forever preferred_lft forever     inet 192.168.1.103/24 brd 192.168.1.255 scope global secondary noprefixroute wlp0s20f3        valid_lft forever preferred_lft forever     inet6 240e:333:2bba:cb00:fb2:52e7:1762:b80f/64 scope global temporary dynamic         valid_lft 213162sec preferred_lft 86001sec     inet6 240e:333:2bba:cb00:4931:9362:97c8:57e9/64 scope global dynamic mngtmpaddr noprefixroute         valid_lft 213162sec preferred_lft 126762sec     inet6 fe80::daca:13ec:24af:c779/64 scope link noprefixroute         valid_lft forever preferred_lft forever 3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000     link/ether 52:54:00:ab:7d:a0 brd ff:ff:ff:ff:ff:ff     inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0        valid_lft forever preferred_lft forever   配置完成后，只需执行如下几条命令就可以实现桥接网络的效果（相当于外部对 192.168.1.101 的访问都会被转发到 192.168.122.101，其他的依此类推）：  $ iptables -t nat -I PREROUTING -d 192.168.1.101 -j DNAT --to-destination 192.168.122.101 $ iptables -t nat -I POSTROUTING -s 192.168.122.101 -j SNAT --to-source 192.168.1.101 $ iptables -I FORWARD -d 192.168.122.101 -m state --state NEW -j ACCEPT  $ iptables -t nat -I PREROUTING -d 192.168.1.102 -j DNAT --to-destination 192.168.122.102 $ iptables -t nat -I POSTROUTING -s 192.168.122.102 -j SNAT --to-source 192.168.1.102 $ iptables -I FORWARD -d 192.168.122.102 -m state --state NEW -j ACCEPT  $ iptables -t nat -I PREROUTING -d 192.168.1.103 -j DNAT --to-destination 192.168.122.103 $ iptables -t nat -I POSTROUTING -s 192.168.122.103 -j SNAT --to-source 192.168.1.103 $ iptables -I FORWARD -d 192.168.122.103 -m state --state NEW -j ACCEPT   通过 iptables 命令配置的规则在系统重启后会失效，为了能够持久生效，可以创建 Libvirt Hook 脚本 /etc/libvirt/hooks/network，这样每次 Libvirt 服务启动时都会自动执行这个脚本，脚本内容如下：  #!/bin/bash # Bridge by iptables.  set -e set -u  bridge() {     internal_ip=\"$1\"     external_ip=\"$2\"      iptables -t nat -I PREROUTING -d ${external_ip} -j DNAT --to-destination ${internal_ip}     iptables -t nat -I POSTROUTING -s ${internal_ip} -j SNAT --to-source ${external_ip}     iptables -I FORWARD -d ${internal_ip} -m state --state NEW -j ACCEPT      echo \"Bridged ${internal_ip} to ${external_ip}\" }  ifname=\"$1\" action=\"$2\" position=\"$3\"  if [ $action == started ]; then     bridge \"192.168.122.101\" \"192.168.1.101\"     bridge \"192.168.122.102\" \"192.168.1.102\"     bridge \"192.168.122.103\" \"192.168.1.103\" fi   参考资料     [Forwarding Incoming Connections] : https://wiki.libvirt.org/Networking.html#forwarding-incoming-connections   [Hooks for specific system management] : https://libvirt.org/hooks.html#etc-libvirt-hooks-network  "
  },
  
  {
    "title": "ETCD 配置 TLS",
    "url": "/posts/etcd-tls/",
    "categories": "ETCD",
    "tags": "etcd, network, ssl, tls",
    "date": "2025-01-25 19:43:00 +0800",
    "content": "前提知识： SSL/TLS 笔记  本文章演示如何在已有 ETCD 集群上同时配置开启 客户端与服务端之间（client-to-server） 和 服务端与服务端之间（server-to-server/peer） 的 TLS。  建议在操作前先备份 data 目录和配置文件！  已有集群信息如下： $ etcdctl member list -w table +------------------+---------+-------+---------------------------+---------------------------+------------+ |        ID        | STATUS  | NAME  |        PEER ADDRS         |       CLIENT ADDRS        | IS LEARNER | +------------------+---------+-------+---------------------------+---------------------------+------------+ | e36d8869dc221ffe | started | node1 | http://192.168.10.11:2380 | http://192.168.10.11:2379 |      false | | 243fcfa74ec0736a | started | node2 | http://192.168.10.12:2380 | http://192.168.10.12:2379 |      false | | c8ad351a3ef67e9e | started | node3 | http://192.168.10.13:2380 | http://192.168.10.13:2379 |      false | +------------------+---------+-------+---------------------------+---------------------------+------------+   生成证书  使用 python 生成  下面示例中使用的 python 脚本 gen_etcd_certs.py 源码在文章末尾附上。  生成 根证书和私钥： $ python gen_etcd_certs.py -c gen_root_cert -s ./certs  Saved: ./certs/root.key Saved: ./certs/root.cert   生成 客户端证书和私钥： $ python gen_etcd_certs.py -c gen_client_cert -s ./certs -k certs/root.key -t certs/root.cert Saved: ./certs/client.key Saved: ./certs/client.cert   生成 节点证书和私钥： $ python gen_etcd_certs.py -c gen_server_cert -s ./certs -k certs/root.key -t certs/root.cert -i 192.168.10.11 Saved: ./certs/192.168.10.11.key Saved: ./certs/192.168.10.11.cert  $ python gen_etcd_certs.py -c gen_server_cert -s ./certs -k certs/root.key -t certs/root.cert -i 192.168.10.12 Saved: ./certs/192.168.10.12.key Saved: ./certs/192.168.10.12.cert  $ python gen_etcd_certs.py -c gen_server_cert -s ./certs -k certs/root.key -t certs/root.cert -i 192.168.10.13 Saved: ./certs/192.168.10.13.key Saved: ./certs/192.168.10.13.cert   使用 openssl 生成  生成 根证书和私钥： $ openssl genrsa -out root.key 2048 Generating RSA private key, 2048 bit long modulus .............................+++ ........................................+++ e is 65537 (0x10001)  $ openssl req -new -sha256 -key root.key -out root.csr -subj \"/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC/CN=CA\"  $ openssl x509 -req -days 3650 -sha256 -signkey root.key -in root.csr -out root.cert Signature ok subject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC/CN=CA Getting Private key   生成 客户端证书和私钥： $ openssl genrsa -out client.key 2048 Generating RSA private key, 2048 bit long modulus .........+++ ......+++ e is 65537 (0x10001)  $ openssl req -new -sha256 -key client.key  -out client.csr -subj \"/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC\"  $ openssl x509 -req -days 3650 -sha256 -CA  root.cert -CAkey root.key  -CAserial root.srl  -CAcreateserial -in client.csr -out client.cert Signature ok subject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC Getting CA Private Key   生成 节点证书和私钥： $ openssl genrsa -out 192.168.10.11.key 2048 Generating RSA private key, 2048 bit long modulus .......................+++ ..................................+++ e is 65537 (0x10001) $ openssl req -new -sha256 -key 192.168.10.11.key -out 192.168.10.11.csr -subj \"/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC\" $ echo \"subjectAltName = @names\\n[names]\\nIP.1 = 127.0.0.1\\nIP.2 = 192.168.10.11\" &gt; 192.168.10.11.ext $ openssl x509 -req -days 3650 -sha256 -CA  root.cert -CAkey root.key  -CAserial root.srl  -CAcreateserial -in 192.168.10.11.csr -out 192.168.10.11.cert -extfile 192.168.10.11.ext Signature ok subject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC Getting CA Private Key  $ openssl genrsa -out 192.168.10.12.key 2048 Generating RSA private key, 2048 bit long modulus .......................+++ ..................................+++ e is 65537 (0x10001) $ openssl req -new -sha256 -key 192.168.10.12.key -out 192.168.10.12.csr -subj \"/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC\" $ echo \"subjectAltName = @names\\n[names]\\nIP.1 = 127.0.0.1\\nIP.2 = 192.168.10.12\" &gt; 192.168.10.12.ext $ openssl x509 -req -days 3650 -sha256 -CA  root.cert -CAkey root.key  -CAserial root.srl  -CAcreateserial -in 192.168.10.12.csr -out 192.168.10.12.cert -extfile 192.168.10.12.ext Signature ok subject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC Getting CA Private Key  $ openssl genrsa -out 192.168.10.13.key 2048 Generating RSA private key, 2048 bit long modulus .......................+++ ..................................+++ e is 65537 (0x10001) $ openssl req -new -sha256 -key 192.168.10.13.key -out 192.168.10.13.csr -subj \"/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC\" $ echo \"subjectAltName = @names\\n[names]\\nIP.1 = 127.0.0.1\\nIP.2 = 192.168.10.13\" &gt; 192.168.10.13.ext $ openssl x509 -req -days 3650 -sha256 -CA  root.cert -CAkey root.key  -CAserial root.srl  -CAcreateserial -in 192.168.10.13.csr -out 192.168.10.13.cert -extfile 192.168.10.13.ext Signature ok subject=/C=CN/ST=CQ/L=YB/O=BC/OU=ZWC Getting CA Private Key   上传证书                 节点       需要上传的文件                       192.168.10.11       root.cert, root.key, client.cert, client.key, 192.168.10.11.cert, 192.168.10.11.key                 192.168.10.12       root.cert, root.key, client.cert, client.key, 192.168.10.12.cert, 192.168.10.12.key                 192.168.10.13       root.cert, root.key, client.cert, client.key, 192.168.10.13.cert, 192.168.10.13.key           更新配置  节点 192.168.10.11 配置文件需要更新的配置： listen-peer-urls: https://0.0.0.0:2380 listen-client-urls: https://0.0.0.0:2379 advertise-client-urls: https://192.168.10.11:2379 client-transport-security:   # 服务端证书，在 TLS 握手过程中提供给客户端。   cert-file: /path/to/192.168.10.11.cert   # 服务端私钥，用来解密客户端使用服务端公钥加密发送的数据。   key-file: /path/to/192.168.10.11.key   # 是否要求客户端访问时提供客户端证书。   client-cert-auth: true   # 受信任的 CA 证书（root 证书/根证书），用来验证客户端证书。   trusted-ca-file: /path/to/root.cert   # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。   auto-tls: false peer-transport-security:   # 本节点证书，在 TLS 握手过程中提供给伙伴节点。   cert-file: /path/to/192.168.10.11.cert   # 本节点私钥，用来解密伙伴节点使用本节点公钥加密发送的数据。   key-file: /path/to/192.168.10.11.key   # 是否要求伙伴节点访问时提供其证书。   client-cert-auth: true   # 受信任的 CA 证书（root 证书/根证书），用来验证伙伴节点证书。   trusted-ca-file: /path/to/root.cert   # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。   auto-tls: false   节点 192.168.10.12 配置文件需要更新的配置： listen-peer-urls: https://0.0.0.0:2380 listen-client-urls: https://0.0.0.0:2379 advertise-client-urls: https://192.168.10.12:2379 client-transport-security:   # 服务端证书，在 TLS 握手过程中提供给客户端。   cert-file: /path/to/192.168.10.12.cert   # 服务端私钥，用来解密客户端使用服务端公钥加密发送的数据。   key-file: /path/to/192.168.10.12.key   # 是否要求客户端访问时提供客户端证书。   client-cert-auth: true   # 受信任的 CA 证书（root 证书/根证书），用来验证客户端证书。   trusted-ca-file: /path/to/root.cert   # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。   auto-tls: false peer-transport-security:   # 本节点证书，在 TLS 握手过程中提供给伙伴节点。   cert-file: /path/to/192.168.10.12.cert   # 本节点私钥，用来解密伙伴节点使用本节点公钥加密发送的数据。   key-file: /path/to/192.168.10.12.key   # 是否要求伙伴节点访问时提供其证书。   client-cert-auth: true   # 受信任的 CA 证书（root 证书/根证书），用来验证伙伴节点证书。   trusted-ca-file: /path/to/root.cert   # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。   auto-tls: false   节点 192.168.10.13 配置文件需要更新的配置： listen-peer-urls: https://0.0.0.0:2380 listen-client-urls: https://0.0.0.0:2379 advertise-client-urls: https://192.168.10.13:2379 client-transport-security:   # 服务端证书，在 TLS 握手过程中提供给客户端。   cert-file: /path/to/192.168.10.13.cert   # 服务端私钥，用来解密客户端使用服务端公钥加密发送的数据。   key-file: /path/to/192.168.10.13.key   # 是否要求客户端访问时提供客户端证书。   client-cert-auth: true   # 受信任的 CA 证书（root 证书/根证书），用来验证客户端证书。   trusted-ca-file: /path/to/root.cert   # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。   auto-tls: false peer-transport-security:   # 本节点证书，在 TLS 握手过程中提供给伙伴节点。   cert-file: /path/to/192.168.10.13.cert   # 本节点私钥，用来解密伙伴节点使用本节点公钥加密发送的数据。   key-file: /path/to/192.168.10.13.key   # 是否要求伙伴节点访问时提供其证书。   client-cert-auth: true   # 受信任的 CA 证书（root 证书/根证书），用来验证伙伴节点证书。   trusted-ca-file: /path/to/root.cert   # 是否自动配置 TLS，开启该配置后则无需上面的其他配置。   auto-tls: false   使用 etcdclt 命令更新所有节点的 peer-urls 为 https（更新时保证所有节点都在线，如果有其他节点是不在线的，更新后这些节点需要作为新节点重新加入）： $ etcdctl member update e36d8869dc221ffe --peer-urls=\"https://192.168.10.11:2380\" Member e36d8869dc221ffe updated in cluster 77feb499f2ffa1c8  $ etcdctl member update 243fcfa74ec0736a --peer-urls=\"https://192.168.10.12:2380\" Member 243fcfa74ec0736a updated in cluster 77feb499f2ffa1c8  $ etcdctl member update c8ad351a3ef67e9e --peer-urls=\"https://192.168.10.13:2380\" Member c8ad351a3ef67e9e updated in cluster 77feb499f2ffa1c8   重启集群  先依次停止所有节点服务，然后再依次启动所有节点服务（在启动第一个节点时会一直等待第二个节点的加入，这时可以直接去启动第二个节点让其加入后，第一个节点也就启动成功了，接着继续去启动第三个节点即可），启动完成后重新查看集群信息如下： $ etcdctl --key=\"/path/to/client.key\" --cert=\"/path/to/client.cert\" --cacert=\"/path/to/root.cert\" member list -w table +------------------+---------+-------+----------------------------+----------------------------+------------+ |        ID        | STATUS  | NAME  |        PEER ADDRS          |       CLIENT ADDRS         | IS LEARNER | +------------------+---------+-------+----------------------------+----------------------------+------------+ | e36d8869dc221ffe | started | node1 | https://192.168.10.11:2380 | https://192.168.10.11:2379 |      false | | 243fcfa74ec0736a | started | node2 | https://192.168.10.12:2380 | https://192.168.10.12:2379 |      false | | c8ad351a3ef67e9e | started | node3 | https://192.168.10.13:2380 | https://192.168.10.13:2379 |      false | +------------------+---------+-------+----------------------------+----------------------------+------------+   TLS 与鉴权  TLS 与鉴权（Authentication）是两个不同的功能，互不影响，不能混为一谈，已知的相互间有关联的情况只有一种：当鉴权和 client-transport-security 都开启的情况下，一个客户端使用设置了 CN 的证书 client.cert 访问服务端，且未提供用户密码时，CN 的值则被当作用户名进行鉴权，但是如果访问时提供了用户密码，则使用提供的用户进行鉴权。  gen_etcd_certs.py 源码  \"\"\" ETCD 证书生成脚本。  @requirements:      cryptography; python_version &gt;= '3.6' @author: zhaowcheng@163.com @changelog:     2025-01-25(v0.1.0): 初版 \"\"\"  import os import sys import argparse import datetime import ipaddress  from cryptography.hazmat.primitives.asymmetric import rsa from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.serialization import (Encoding,                                                            PrivateFormat,                                                           NoEncryption,                                                           load_pem_private_key) from cryptography.x509 import (Name,                                 NameAttribute,                                 SubjectAlternativeName,                                CertificateBuilder,                                 Certificate,                                BasicConstraints,                                IPAddress,                                load_pem_x509_certificate) from cryptography.x509.oid import NameOID from cryptography.x509 import random_serial_number   VERSION = '0.1.0' NAMEATTRS = [     NameAttribute(NameOID.COUNTRY_NAME, \"CN\"),     NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"CQ\"),     NameAttribute(NameOID.LOCALITY_NAME, \"YB\"),     NameAttribute(NameOID.ORGANIZATION_NAME, \"BC\"),     NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, \"ZWC\") ]   def printerr_and_exit(msg: str, rc: int = 1) -&gt; None:     \"\"\"     打印错误消息并退出。      :param msg: 消息     :param rc: 退出码。     \"\"\"     print(f'ERROR: {msg}', file=sys.stderr)     exit(rc)   def save_key(key: rsa.RSAPrivateKey, path: str) -&gt; None:     \"\"\"     保存私钥。      :param key: 私钥。     :param path: 保存路径。     \"\"\"     with open(path, 'wb') as f:         f.write(key.private_bytes(             encoding=Encoding.PEM,             format=PrivateFormat.TraditionalOpenSSL,             encryption_algorithm=NoEncryption()         ))     print(f'Saved: {path}')   def save_cert(cert: Certificate, path: str) -&gt; None:     \"\"\"     保存证书。      :param cert: 证书。     :param path: 保存路径。     \"\"\"     with open(path, 'wb') as f:         f.write(cert.public_bytes(Encoding.PEM))     print(f'Saved: {path}')   def gen_root_cert(savedir: str, days: int) -&gt; None:     \"\"\"     生成根证书。      :param savedir: 保存目录。     :param days: 有效期（天）。     \"\"\"     # 生成根私钥     root_private_key = rsa.generate_private_key(         public_exponent=65537,         key_size=2048     )      # 生成根证书的公钥     root_public_key = root_private_key.public_key()      # 生成根证书的主题     subject = issuer = Name(NAMEATTRS + [NameAttribute(NameOID.COMMON_NAME, \"CA\")])      # 生成根证书     root_cert = CertificateBuilder(     ).subject_name(         subject     ).issuer_name(         issuer     ).public_key(         root_public_key     ).serial_number(         random_serial_number()     ).not_valid_before(         datetime.datetime.now(datetime.timezone.utc)     ).not_valid_after(         datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=days)     ).add_extension(         BasicConstraints(ca=True, path_length=None), critical=True     ).sign(root_private_key, hashes.SHA256())      # 保存     save_key(root_private_key, os.path.join(savedir, 'root.key'))     save_cert(root_cert, os.path.join(savedir, 'root.cert'))  def gen_client_cert(     rootkey: str,      rootcert: str,      savedir: str,      days: int,      cn: str = '' ) -&gt; None:     \"\"\"     生成客户端证书。      :param rootkey: 根私钥。     :param rootcert: 根证书。     :param savedir: 保存目录。     :param days: 有效期（天）。     :param cn: 用户名。     \"\"\"     # 加载根私钥和证书     with open(rootkey, 'rb') as f:         root_private_key = load_pem_private_key(f.read(), None)     with open(rootcert, 'rb') as f:         root_cert = load_pem_x509_certificate(f.read())      # 生成客户端私钥     client_private_key = rsa.generate_private_key(         public_exponent=65537,         key_size=2048     )      # 生成客户端证书的公钥     client_public_key = client_private_key.public_key()      # 生成客户端证书的主题     if cn:         subject = Name(NAMEATTRS + [NameAttribute(NameOID.COMMON_NAME, cn)])     else:         subject = Name(NAMEATTRS)      # 生成客户端证书     client_cert = CertificateBuilder().subject_name(         subject     ).issuer_name(         root_cert.subject     ).public_key(         client_public_key     ).serial_number(         random_serial_number()     ).not_valid_before(         datetime.datetime.now(datetime.timezone.utc)     ).not_valid_after(         datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=days)     ).sign(root_private_key, hashes.SHA256())      # 保存     save_key(client_private_key, os.path.join(savedir, 'client.key'))     save_cert(client_cert, os.path.join(savedir, 'client.cert'))   def gen_server_cert(     rootkey: str,      rootcert: str,      savedir: str,      days: int,     ip: str ) -&gt; None:     \"\"\"     生成服务端证书。      :param rootkey: 根私钥。     :param rootcert: 根证书。     :param savedir: 保存目录。     :param days: 有效期（天）。     :param ip: 服务端 ip。     \"\"\"     # 加载根私钥和证书     with open(rootkey, 'rb') as f:         root_private_key = load_pem_private_key(f.read(), None)     with open(rootcert, 'rb') as f:         root_cert = load_pem_x509_certificate(f.read())      # 生成服务器私钥     server_private_key = rsa.generate_private_key(         public_exponent=65537,         key_size=2048     )      # 生成服务器证书的公钥     server_public_key = server_private_key.public_key()      # 生成服务器证书的主题     subject = Name(NAMEATTRS)      # 生成服务器证书的扩展（包括 IP SAN）     san = SubjectAlternativeName([         IPAddress(ipaddress.IPv4Address('127.0.0.1')),         IPAddress(ipaddress.IPv4Address(ip))     ])      # 生成服务器证书     server_cert = CertificateBuilder().subject_name(         subject     ).issuer_name(         root_cert.subject     ).public_key(         server_public_key     ).serial_number(         random_serial_number()     ).not_valid_before(         datetime.datetime.now(datetime.timezone.utc)     ).not_valid_after(         datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=days)     ).add_extension(         san, critical=False     ).sign(root_private_key, hashes.SHA256())      # 保存     save_key(server_private_key, os.path.join(savedir, f'{ip}.key'))     save_cert(server_cert, os.path.join(savedir, f'{ip}.cert'))   def create_parser() -&gt; argparse.ArgumentParser:     \"\"\"     创建命令行参数解析器。     \"\"\"     parser = argparse.ArgumentParser()     parser.add_argument('-c', '--command', required=True, choices=['gen_root_cert', 'gen_client_cert', 'gen_server_cert'])     parser.add_argument('-s', '--savedir', required=True, default='.', help='Save directory. [default: .]')     parser.add_argument('-d', '--days', type=int,  default=3650,                          help='Certificate validity period. [default: 3650]')     parser.add_argument('-n', '--cn', help='Common name(only used for gen_client_cert).')     parser.add_argument('-k', '--root-key', required=('gen_client_cert' in sys.argv or 'gen_server_cert' in sys.argv),                         help='Root private key.')     parser.add_argument('-t', '--root-cert', required=('gen_client_cert' in sys.argv or 'gen_server_cert' in sys.argv),                         help='Root certificate.')     parser.add_argument('-i', '--ip', required=('gen_server_cert' in sys.argv),                         help='Server IP.')     parser.add_argument('-v', '--version', action='version', version=VERSION)     return parser   def main() -&gt; None:     \"\"\"     入口函数。     \"\"\"     parser = create_parser()     args = parser.parse_args()     if not os.path.exists(args.savedir):         printerr_and_exit(f'Savedir `{args.savedir}` does not exist.')     if args.command == 'gen_root_cert':         gen_root_cert(args.savedir, args.days)     elif args.command == 'gen_client_cert':         gen_client_cert(args.root_key, args.root_cert, args.savedir, args.days, args.cn)     elif args.command == 'gen_server_cert':         gen_server_cert(args.root_key, args.root_cert, args.savedir, args.days, args.ip)   if __name__ == '__main__':     main()   参考资料     [Transport security model] : https://etcd.io/docs/v3.5/op-guide/security/  "
  },
  
  {
    "title": "SSL/TLS 笔记",
    "url": "/posts/ssl-notes/",
    "categories": "计算机网络",
    "tags": "network, ssl, tls",
    "date": "2025-01-25 19:41:00 +0800",
    "content": "密码学基础          对称加密（又称单钥加密、私钥加密、共享密钥加密）：加密和解密使用同一个密钥，常见算法有 AES 和 DES 等。           非对称加密（又称双钥加密、公钥加密）：有一对密钥，私钥和公钥，公钥加密的数据，只能用对应的私钥来解密，反之亦然，常见算法有 RSA, DSA, DH, ECDSA 等。           数字签名（Digital Signature）：本质上就是用私钥对数据的摘要（md5, sha256, ...）进行加密就生成了私钥持有人的签名，然后持有对应公钥的人可以对签名进行解密，如果能解密则证明该签名确实是由持有私钥的人签署的，然后用约定的摘要算法计算数据的摘要并与解密出的摘要对比，如果一样则证明数据没有被篡改。           数字证书（Digital Certificate）：假设 Alice 在有一对密钥 A（公钥 A-pub 和私钥 A-pri）的情况下，使用另外一对密钥 B （公钥 B-pub 和私钥 B-pri）的私钥 B-pri 对 A 密钥的公钥 A-pub 和拥有者信息进行加密就生成了可以用来证明 Alice 身份的证书 Alice-A.cert。然后 Alice 将公钥 B-pub 分发给 Bob，以后 Bob 要和 Alice 通信前先向 Alice 索要证书 Alice-A.cert，Bob 得到证书后使用公钥 B-pub 对证书进行解密，能够解密并且解密后的拥有者信息确实是 Alice 则证明对方确实是 Alice，然后就可以使用解密后得到的公钥 A-pub 加密消息发送给 Alice 了，Alice 收到消息后可以使用私钥 A-pri 对消息进行解密。           证书机构（Certificate Authority，简称 CA）：把数字证书例子中的密钥对 B 改为第三个人 Tom 拥有，并且 Alice 和 Bob 都信任 Tom，那么 Tom 就是一个证书分发机构。Tom 可以分别为 Alice 和 Bob 生成他们的证书，并且向他们提供 CA 证书（或称为根证书，即 Tom 的证书），Bob 可以使用 CA 证书验证 Alice 的证书，Alice 也可以 CA 证书验证 Bob 的证书。      SSL/TLS 简介  SSL: secure socket layer  TLS: transport layer security     1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。    1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。    1996年，SSL 3.0版问世，得到大规模应用。    1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。    2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。    目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。    TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。   SSL/TLS 原理     SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。         参考资料     [密码学笔记] : https://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html   [数字签名] : https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html   [SSL/TLS协议运行机制的概述] : https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html  "
  },
  
  {
    "title": "PostgreSQL 编码支持（character set/encoding)",
    "url": "/posts/postgresql-encoding/",
    "categories": "PostgreSQL",
    "tags": "postgresql, encoding, character-set, codeset",
    "date": "2024-12-22 10:23:00 +0800",
    "content": "编码支持     PostgreSQL 支持的所有编码（包括服务端和客户端）: PostgreSQL Character Sets            客户端支持表中所有编码；       服务端支持表中大部分编码；           在服务端，编码设置必须与 locale 设置 LC_CTYPE 和 LC_COLLATE 兼容：            当 locale 设置为 C 或 POSIX 时，兼容所有支持的编码；       当 locale 设置为 libc 提供程序中的任一个时，只有一个对应的编码是兼容的（有一个例外情况是在 Windows 上，UTF-8 编码兼容所有 locale 设置）；       当 locale 设置为 icu 提供程序中的任一个时，可以与服务端支持的大部分编码兼容，详情见 PostgreSQL Character Sets；           当编码设置为 SQL_ASCII 时，相当于无编码设置，且仅支持 0-127 这部分字符；   编码设置     服务端：            initdb 时设置整个数据库集簇的默认编码：                    可通过 -E/--encoding 选项指定编码（优先级高于 locale 中的编码设置）：                            如果通过该选项指定的编码与 locale 设置不兼容时，会报错；                                   如果未指定则自动从 locale 设置中获取：                            当 locale 设置为 C 或 POSIX 时，自动设置编码为 SQL_ASCII               当 locale 设置为 libc 提供程序中的任一个时，自动设置为对应的兼容编码（有的较老的系统可能不支持）；               当 locale 设置为 icu 提供程序中的任一个时，自动设置编码为 SQL_ASCII；                                               CREATE DATABASE 时可以指定被创建数据库的编码（覆盖 initdb 默认设置）：                    只有使用 template0 作为模板时才可以，详情见 Template Databases；                           客户端（以下优先级依次递增）：            读取服务端的 client_encoding 配置，该配置默认为 SQL_ASCII，即无编码，最终效果则是与服务端编码相同；       读取客户端的环境变量 PGCLIENTENCODING；       通过 SQL 或 psql 命令修改编码设置：                    SQL: ALTER SYSTEM SET client_encoding TO 'VALUE';           SQL: SET client_encoding TO 'VALUE';           SQL: SET NAMES TO 'VALUE';           psql: \\encoding VALUE                           编码查询     服务端：            SQL: SELECT * FROM pg_database;       psql: psql -l 或 \\l；           客户端：            SQL: SHOW client_encoding;       psql: \\encoding           编码转换  PostgreSQL 内置支持很多不同编码之间的转换，具体哪些可以查看文档 All Built-in Character Set Conversions，或者通过 SQL 命令 SELECT * FROM pg_conversion 查看。  如果内置的不能满足需求，还可以使用 SQL 命令 CREATE CONVERSION 命令创建新的转换。  PostgreSQL 支持服务端和客户端之间编码的自动转换，内置支持的所有自动转换可以查看文档 Built-in Client/Server Character Set Conversions，如果一个转换被标记为默认时（CREATE DEFAULT CONVERSION），就会被用于服务端和客户端之间的编码自动化转换，当服务端和客户端之间的编码不支持转换时，则会报错。  参考资料     [Character Set Support] : https://www.postgresql.org/docs/17/multibyte.html  "
  },
  
  {
    "title": "PostgreSQL 区域设置（locale）",
    "url": "/posts/postgresql-locale/",
    "categories": "PostgreSQL",
    "tags": "postgresql, locale",
    "date": "2024-12-21 17:44:00 +0800",
    "content": "locale 分类                 分类       作用                       LC_COLLATE       字符顺序                 LC_CTYPE       字符分类（什么是一个字符？它的大写形式是否等效？）                 LC_MESSAGES       消息语言                 LC_MONETARY       货币符号                 LC_NUMERIC       数字格式                 LC_TIME       日期和时间格式           locale 查询  可通过 SQL 命令 SHOW LC_* 查询对应分类的 locale 设置，如：  SHOW LC_COLLATE;   locale 设置                 分类       设置方式                       LC_COLLATE       initdb 时生成默认值；CREATE DATABASE 时也可以指定其他值（只有使用 template0 作为模板时才可以）；也可以使用 collation 指定某一列或某一次查询使用其他值。                 LC_CTYPE       同 LC_COLLATE                 LC_MESSAGES       initdb 时生成默认值并写入 postgresql.conf 中，后续可以随时通过修改配置来改变。                 LC_MONETARY       同 LC_MESSAGES                 LC_NUMERIC       同 LC_MESSAGES                 LC_TIME       同 LC_MESSAGES           initdb 的 locale 选择策略  initdb 时默认从当前环境变量读取 locale 设置，以 LC_COLLATE 为例，其读取优先级如下：  LC_ALL &gt; LC_COLLATE &gt; LANG   如果以上环境变量都没有设置，则设置为 C。  也可以通过 initdb 命令的相关参数来指定（优先级大于环境变量），--locale 参数为所有 locale 分类设置值，也可以为具体的分类指定值，如 --lc-collate（优先级大于 --locale）。  通过 initdb 参数指定的 locale 必须是当前操作系统支持的设置，Linux 上可通过以下命令查看当前系统支持的所有 locale：  locale -a   locale 提供程序（provider）  PostgreSQL 支持选择不同的 locale 提供程序为 LC_COLLATE 和 LC_CTYPE 分类提供支持，而其他的分类则仍然由操作系统提供支持。  PostgreSQL 提供程序在 initdb, CREATE DATABASE 和 CREATE COLLATION 时均可选择，也就是说可以在不同的维度上进行混用。                 提供程序       说明                       builtin       PostgreSQL 内置，仅支持 C 和 C.UTF-8。                 libc       操作系统自带 C 语言库，Linux 上即为 libc 或 glibc。                 icu       ICU(International Components for Unicode)，需要在编译配置 PostgreSQL 时选择编译该库（默认编译，除非指定 --without-icu 选项）。           locale 格式说明                 提供程序       格式                       builtin       仅支持 C 和 C.UTF-8。                 libc       language_territory.codeset (codeset 是可选项，如 en_US.UTF-8, en_US)                 icu       language-region (如 en-US)           locale 对性能的影响  使用 locale 会对数据库的性能产生一定影响，所以建议在确实需要时才设置，不需要时可设置为 C 或 POSIX。  参考资料     [Locale Support] : https://www.postgresql.org/docs/17/locale.html  "
  },
  
  {
    "title": "xbot: 一个轻量、易用、可扩展的自动化测试框架",
    "url": "/posts/introduction-to-xbot/",
    "categories": "软件测试",
    "tags": "automation-testing",
    "date": "2024-07-04 10:31:00 +0800",
    "content": "   NOTE:  当前文章基于 xbot-0.4.0 编写，最新信息请查看官方仓库。   简介  xbot 是一个 轻量、易用、可扩展 的自动化测试框架。  安装  使用 pip 进行安装:  pip install xbot.framework   安装成功后即可调用 xbot 命令:  $ xbot --help usage: xbot [-h] [-d DIRECTORY] [-b TESTBED] [-s TESTSET] [-f {verbose,brief}] [-v] {init,run}  positional arguments: {init,run}  optional arguments: -h, --help            show this help message and exit -d DIRECTORY, --directory DIRECTORY                         directory to init (required by `init` command) -b TESTBED, --testbed TESTBED                         testbed filepath (required by `run` command) -s TESTSET, --testset TESTSET                         testset filepath (required by `run` command) -f {verbose,brief}, --outfmt {verbose,brief}                         output format (option for `run` command, options: verbose/brief, default: brief) -v, --version         show program's version number and exit   入门  初始化工程目录:  $ xbot init -d ./testproj Initialized ./testproj   工程目录结构如下:  ./testproj ├── README.md ├── lib  # 测试库目录 │   ├── __init__.py │   ├── testbed.py  # 测试床基类 │   └── testcase.py  # 测试用例基类 ├── requirements.txt ├── testbeds  # 测试床目录 │   └── testbed_example.yml  ├── testcases  # 测试用例目录 │   ├── __init__.py │   └── examples │       ├── __init__.py │       ├── nonpass │       │   ├── __init__.py │       │   ├── tc_eg_nonpass_error_clsname.py │       │   ├── tc_eg_nonpass_error_syntax.py │       │   ├── tc_eg_nonpass_fail_setup_with_failfast_false.py │       │   ├── tc_eg_nonpass_fail_setup_with_failfast_true.py │       │   ├── tc_eg_nonpass_fail_step_with_failfast_false.py │       │   ├── tc_eg_nonpass_fail_step_with_failfast_true.py │       │   ├── tc_eg_nonpass_skip_excluded.py │       │   ├── tc_eg_nonpass_skip_not_included.py │       │   └── tc_eg_nonpass_timeout.py │       └── pass │           ├── __init__.py │           ├── tc_eg_pass_create_dirs_and_files.py │           └── tc_eg_pass_get_values_from_testbed.py └── testsets  # 测试套目录     └── testset_example.yml   测试床示例(testbeds/testbed_example.yml):  # Testbed is used to store the information about the test environment. # The information can be accessed by self.testbed.get() in the testcases. example:   key1: value1   key2:      key2-1: value2-1     key2-2: value2-2   key3:     - value3-1     - value3-2     - value3-3   key4:     - name: jack       age: 20     - name: tom       age: 30   测试套示例(testsets/testset_example.yml):  # Testset is used to organize testcases to be executed. tags:  # `exclude` has higher priority than `include`.   include:  # Include testcases with these tags.     - tag1   exclude:  # Exclude testcases with these tags.     - tag2 paths:   - testcases/examples/pass/tc_eg_pass_get_values_from_testbed.py   - testcases/examples/pass/tc_eg_pass_create_dirs_and_files.py   # Recursively include all testcases in the directory,    # only match files with the prefix 'tc_' and suffix '.py'.   - testcases/examples/nonpass/   执行测试(测试工程目录下执行命令):  $ xbot run -b testbeds/testbed_example.yml -s testsets/testset_example.yml  (1/11)   PASS     0:00:01  tc_eg_pass_get_values_from_testbed (2/11)   PASS     0:00:01  tc_eg_pass_create_dirs_and_files (3/11)   ERROR    0:00:00  tc_eg_nonpass_error_clsname (4/11)   ERROR    0:00:00  tc_eg_nonpass_error_syntax (5/11)   FAIL     0:00:01  tc_eg_nonpass_fail_setup_with_failfast_false (6/11)   FAIL     0:00:01  tc_eg_nonpass_fail_setup_with_failfast_true (7/11)   FAIL     0:00:01  tc_eg_nonpass_fail_step_with_failfast_false (8/11)   FAIL     0:00:01  tc_eg_nonpass_fail_step_with_failfast_true (9/11)   SKIP     0:00:00  tc_eg_nonpass_skip_excluded (10/11)  SKIP     0:00:00  tc_eg_nonpass_skip_not_included (11/11)  TIMEOUT  0:00:03  tc_eg_nonpass_timeout  report: /Users/wan/CodeProjects/xbot.framework/testproj/logs/testbed_example/2024-07-02_12-19-43/report.html    执行完成后会在测试工程下根据测试床名称和时间戳生成日志目录保存 html 格式的用例日志和测试报告。  测试报告:    用例日志:    用例开发  测试用例存放在工程目录的 testcases 子目录下，以下为 testcases/examples/pass/tc_eg_pass_create_dirs_and_files.py 用例内容:  import os import tempfile import shutil  from xbot.framework.utils import assertx from lib.testcase import TestCase   class tc_eg_pass_create_dirs_and_files(TestCase):     \"\"\"     Test creating directories and files.     \"\"\"     TIMEOUT = 60     FAILFAST = True     TAGS = ['tag1']      def setup(self):         \"\"\"         Prepare test environment.         \"\"\"         self.workdir = tempfile.mkdtemp()         self.info('Created workdir: %s', self.workdir)      def step1(self):         \"\"\"         Create a subdirectory 'dir' under the temporary working directory and check if it is created successfully.         \"\"\"         self.dir1 = os.path.join(self.workdir, 'dir1')         os.mkdir(self.dir1)         assertx(os.path.exists(self.dir1), '==', True)      def step2(self):         \"\"\"         Create an empty file 'file1' under 'dir1' and check if it is created successfully.         \"\"\"         self.file1 = os.path.join(self.dir1, 'file1')         open(self.file1, 'w').close()         assertx(os.path.exists(self.file1), '==', True)      def step3(self):         \"\"\"         Write 'hello world' to 'file1' and check if it is written successfully.         \"\"\"         with open(self.file1, 'w') as f:             f.write('hello world')         with open(self.file1, 'r') as f:             assertx(f.read(), '==', 'hello world')      def teardown(self):         \"\"\"         Clean up test environment.         \"\"\"         shutil.rmtree(self.workdir)         self.info('Removed workdir: %s', self.workdir)         self.sleep(1)      用例 必须 继承自 TestCase 基类；   用例 必须 在 setup 方法内实现预置步骤，如无具体步骤则写 pass；   用例 必须 在 teardown 方法内实现清理步骤，如无具体步骤则写 pass；   测试步骤以 step1, step2, ... 这样的方式命名，末尾数字为执行顺序；   TIMEOUT 属性定义测试用例最大执行时长(单位：秒)，超过该时长将被强制结束且置结果为 TIMEOUT；   FAILFAST 属性为 True 时，当某个测试步骤失败时，则会跳过后续测试步骤立即执行清理步骤；   TAGS 属性定义用例 标签，可用于测试套中对待执行测试用例列表进行筛选；   测试库开发  测试库存放在工程目录的 lib 子目录下，根据业务开发所需测试库放入该目录下，然后在测试用例中导入使用即可。  插件                 Name       Description                       xbot.plugins.ssh       SSH library for xbot.framework                 xbot.plugins.http(planning)       HTTP library for xbot.framework                 xbot.plugins.wui(planning)       WebUI library for xbot.framework                 xbot.plugins.gui(planning)       GUI library for xbot.framework                 xbot.plugins.pgsql(planning)       PostgreSQL library for xbot.framework          "
  },
  
  {
    "title": "Python 进阶 - deepget 和 deepset",
    "url": "/posts/python-advanced-deepget-and-deepset/",
    "categories": "Python 进阶",
    "tags": "python",
    "date": "2023-05-17 23:16:00 +0800",
    "content": "实现类似于 deepcopy 的 3 个函数 deepget, deepset, deeppop，代码如下：  #!/usr/bin/env python3.10  import re import operator import typing as t  from functools import reduce  T = t.TypeVar('T')   def parse_deepkey(deepkey: str, sep: str = '.') -&gt; list:     \"\"\"     深度路径分割      :param deepkey: 深度路径     :param sep: 分隔符     :return: 列表格式的深度路径      &gt;&gt;&gt; parse_deepkey('a.b1')     ['a', 'b1']     &gt;&gt;&gt; parse_deepkey('a.b2[0]')     ['a', 'b2', 0]     &gt;&gt;&gt; parse_deepkey('a.b2[0].c2')     ['a', 'b2', 0, 'c2']     &gt;&gt;&gt; parse_deepkey('a.b2[x=1].c2')     ['a', 'b2', {'x': 1}, 'c2']     &gt;&gt;&gt; parse_deepkey('a.b2[x=1, y=\"z\"].c2')     ['a', 'b2', {'x': 1, 'y': 'z'}, 'c2']     \"\"\"     keys = []     for k in re.split(r'%s|\\[' % re.escape(sep), deepkey):         if k.endswith(']'):             k = k[:-1]             if k.isdigit():                 keys.append(int(k))             else:                 try:                     keys.append(eval(f'dict({k})'))                 except SyntaxError as e:                     raise SyntaxError(f'Invalid expr `{k}` in deepkey `{deepkey}`: {str(e)}.')         else:             keys.append(k)     return keys   def dump_deepkey(keys: list[str | int | dict], sep: str = '.') -&gt; list:     \"\"\"     深度路径合并      :param keys: 切割后的深度路径     :param sep: 分隔符     :return: 合并后的深度路径      &gt;&gt;&gt; dump_deepkey(['a', 'b1'])     'a.b1'     &gt;&gt;&gt; dump_deepkey(['a', 'b2', 0])     'a.b2[0]'     &gt;&gt;&gt; dump_deepkey(['a', 'b2', 0, 'c2'])     'a.b2[0].c2'     &gt;&gt;&gt; dump_deepkey(['a', 'b2', {'x': 1}, 'c2'])     'a.b2[x=1].c2'     &gt;&gt;&gt; dump_deepkey(['a', 'b2', {'x': 1, 'y': 'z'}, 'c2'])     'a.b2[x=1, y=\"z\"].c2'     \"\"\"     normkeys = []     for key in keys:         if isinstance(key, int):             normkeys.append(f'[{key}]')         elif isinstance(key, dict):             parts = []             for k, v in key.items():                 if isinstance(v, (int, float)):                     parts.append(f'{k}={v}')                 else:                     parts.append(f'{k}=\"{v}\"')             normkeys.append(f'[{\", \".join(parts)}]')         else:             normkeys.append(key)     return sep.join(normkeys).replace('.[', '[')   def deep_getitem(obj: object, key: t.Union[str, int, dict]) -&gt; t.Any:     \"\"\"     专为 deep* 函数设计的获取对象中的值函数。      :param obj: 对象     :param key: 键     :return: 获取到的值     \"\"\"     if obj is None:         return None     if isinstance(obj, list) and isinstance(key, dict):         return GetableList(obj).get(musthave=True, **key)     else:         return operator.getitem(obj, key)   def deepget(obj: object, deepkey: str, sep: str = '.') -&gt; t.Any:     \"\"\"     深度获取对象中的值      :param obj: 对象     :param deepkey: 深度路径     :param sep: 分隔符     :return: 获取到的值      &gt;&gt;&gt; d = {     ...     'a': {     ...         'b1': 'c',     ...         'b2': [1, 2, 3],     ...         'b3': [{'x': 1, 'y': 'h'},      ...                {'x': 2, 'y': 'i'},     ...                {'x': 1, 'y': 'j'}],     ...         'b4': None     ...      }     ... }     &gt;&gt;&gt; deepget(d, 'a.b1')     'c'     &gt;&gt;&gt; deepget(d, 'a.b2[0]')     1     &gt;&gt;&gt; deepget(d, 'a.b3[0].x')     1     &gt;&gt;&gt; deepget(d, 'a.b3[x=1]')     {'x': 1, 'y': 'h'}     &gt;&gt;&gt; deepget(d, 'a.b3[x=1, y=\"j\"]')     {'x': 1, 'y': 'j'}     &gt;&gt;&gt; deepget(d, 'a.b4[999]') == None     True     &gt;&gt;&gt; deepget(d, 'a.b4.x') == None     True     \"\"\"     keys = parse_deepkey(deepkey, sep)     return reduce(deep_getitem, keys, obj)   def deepset(obj: object, deepkey: str, value: any, sep: str = '.') -&gt; None:     \"\"\"     深度设置对象中的值。     如果路径不存在则创建（路径中带索引的情况除外，如 a.b[0]）      :param obj: 对象     :param deepkey: 深度路径     :param value: 待设置的值     :param sep: 分隔符      &gt;&gt;&gt; from pprint import pprint     &gt;&gt;&gt; d = {     ...     'a': {     ...         'b1': 'c',     ...         'b2': [1, 2, 3],     ...         'b3': [{'x': 1, 'y': 'h'},      ...                {'x': 2, 'y': 'i'},     ...                {'x': 1, 'y': 'j'}]     ...      }     ... }     &gt;&gt;&gt; deepset(d, 'a.b1', 'd')     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': [1, 2, 3],            'b3': [{'x': 1, 'y': 'h'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'j'}]}}     &gt;&gt;&gt; deepset(d, 'a.b2[0]', '-1')     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3],            'b3': [{'x': 1, 'y': 'h'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'j'}]}}     &gt;&gt;&gt; deepset(d, 'i.j', 'x')     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3],            'b3': [{'x': 1, 'y': 'h'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'j'}]},      'i': {'j': 'x'}}     &gt;&gt;&gt; deepset(d, 'a.b2[999]', 4)     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3, 4],            'b3': [{'x': 1, 'y': 'h'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'j'}]},      'i': {'j': 'x'}}     &gt;&gt;&gt; deepset(d, 'a.b4[0].c1[0]', 'x')     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3, 4],            'b3': [{'x': 1, 'y': 'h'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'j'}],            'b4': [{'c1': ['x']}]},      'i': {'j': 'x'}}     &gt;&gt;&gt; deepset(d, 'a.b3[x=1].y', 'k')     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3, 4],            'b3': [{'x': 1, 'y': 'k'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'j'}],            'b4': [{'c1': ['x']}]},      'i': {'j': 'x'}}     &gt;&gt;&gt; deepset(d, 'a.b3[x=1, y=\"j\"].y', 'k')     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3, 4],            'b3': [{'x': 1, 'y': 'k'}, {'x': 2, 'y': 'i'}, {'x': 1, 'y': 'k'}],            'b4': [{'c1': ['x']}]},      'i': {'j': 'x'}}     &gt;&gt;&gt; deepset(d, 'a.b3[x=2]', {'x': 2, 'y': 'k'})     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3, 4],            'b3': [{'x': 1, 'y': 'k'}, {'x': 2, 'y': 'k'}, {'x': 1, 'y': 'k'}],            'b4': [{'c1': ['x']}]},      'i': {'j': 'x'}}     &gt;&gt;&gt; deepset(d, 'a.b3[x=8]', {'x': 8, 'y': 'k'})     &gt;&gt;&gt; pprint(d)     {'a': {'b1': 'd',            'b2': ['-1', 2, 3, 4],            'b3': [{'x': 1, 'y': 'k'},                   {'x': 2, 'y': 'k'},                   {'x': 1, 'y': 'k'},                   {'x': 8, 'y': 'k'}],            'b4': [{'c1': ['x']}]},      'i': {'j': 'x'}}     \"\"\"     keys = parse_deepkey(deepkey, sep)     for i, k in enumerate(keys[:-1]):         try:             child = deep_getitem(obj, k)             if child is None:                 v = [] if isinstance(keys[i+1], (int, dict)) else {}                 operator.setitem(obj, k, v)                 child = deep_getitem(obj, k)             obj = child         except KeyError:             obj[k] = [] if isinstance(keys[i+1], (int, dict)) else {}             obj = obj[k]         except (IndexError, AttributeError):             obj.append([] if isinstance(keys[i+1], (int, dict)) else {})             obj = obj[-1]     if isinstance(obj, list) and isinstance(keys[-1], int) and len(obj) &lt;= keys[-1]:         obj.append(value)     elif isinstance(obj, list) and isinstance(keys[-1], dict):         v = GetableList(obj).get(musthave=False, **keys[-1])         if v is None:             obj.append(value)         else:             obj[obj.index(v)] = value     else:         operator.setitem(obj, keys[-1], value)   def deeppop(obj: object, deepkey: str, sep: str = '.') -&gt; t.Any:     \"\"\"     深度删除对象中的值      :param obj: 对象     :param deepkey: 深度路径     :param sep: 分隔符     :return: deepkey 存在时返回删除的值，否则返回 None。      &gt;&gt;&gt; d = {     ...     'a': {     ...         'b1': 'c',     ...         'b2': [1, 2, 3],     ...         'b3': [{'x': 1, 'y': 'h'},      ...                {'x': 2, 'y': 'i'},     ...                {'x': 1, 'y': 'j'}]     ...      }     ... }     &gt;&gt;&gt; deeppop(d, 'a.b1')     'c'     &gt;&gt;&gt; deeppop(d, 'a.b2[0]')     1     &gt;&gt;&gt; deeppop(d, 'a.b2[5]') == None     True     &gt;&gt;&gt; deeppop(d, 'a.b4') == None     True     &gt;&gt;&gt; deeppop(d, 'a.b3[x=1]')     {'x': 1, 'y': 'h'}     &gt;&gt;&gt; deeppop(d, 'a.b3[x=1, y=\"j\"].y')     'j'     &gt;&gt;&gt; deeppop(d, 'a.b3[x=3]') == None     True     \"\"\"     keys = parse_deepkey(deepkey, sep)     if len(keys) == 1:         return obj.pop(keys[0])     else:         v = deepget(obj, dump_deepkey(keys[:-1], sep=sep), sep=sep)         if v is not None:             if isinstance(v, list):                 if isinstance(keys[-1], dict):                     r = GetableList(v).get(musthave=False, **keys[-1])                     if r:                         v.remove(r)                     return r                 else:                     try:                         return v.pop(keys[-1])                     except IndexError:                         return None             else:                 return v.pop(keys[-1], None)               class GetableList(t.Generic[T], list):     \"\"\"     可自定义获取元素的列表。     \"\"\"     def get(self, musthave=True, **attrs) -&gt; t.Optional[T]:         \"\"\"         获取第一个属性都匹配的元素，否则返回 None 或报错。          :param musthave: 如果为 True，无匹配的元素时则报错。         :param attrs: 属性名和属性值。          &gt;&gt;&gt; class Person:         ...     def __init__(self, name, age):         ...         self.name = name         ...         self.age = age         ...          &gt;&gt;&gt; people = GetableList[Person]([         ...     Person(\"Alice\", 30),         ...     Person(\"Bob\", 25),         ...     Person(\"Bob\", 26),         ...     Person(\"Charlie\", 35)         ... ])         &gt;&gt;&gt; people.get(name='Bob').age         25         &gt;&gt;&gt; people.get(name='Tom', musthave=False) == None         True         \"\"\"         for e in self:             for k, v in attrs.items():                 if isinstance(e, dict):                     value = e.get(k)                 else:                     value = getattr(e, k, None)                 if value != v:                     break             else:                 return e         if musthave:             raise AttributeError(f'No such element: {attrs}')              def gets(self, **attrs) -&gt; 'GetableList[T]':         \"\"\"         获取所有属性都匹配的元素。          :param attrs: 属性名和属性值。          &gt;&gt;&gt; class Person:         ...     def __init__(self, name, age):         ...         self.name = name         ...         self.age = age         ...          &gt;&gt;&gt; people = GetableList[Person]([         ...     Person(\"Alice\", 30),         ...     Person(\"Bob\", 25),         ...     Person(\"Bob\", 26),         ...     Person(\"Charlie\", 35)         ... ])         &gt;&gt;&gt; people.gets(name='Bob')[0].age         25         &gt;&gt;&gt; people.gets(name='Tom') == []         True         \"\"\"         elements = []         for e in self:             for k, v in attrs.items():                 if getattr(e, k) != v:                     break             else:                 elements.append(e)         return elements       "
  },
  
  {
    "title": "date 命令使用示例",
    "url": "/posts/date-examples/",
    "categories": "Linux 命令",
    "tags": "date",
    "date": "2022-11-28 22:24:00 +0800",
    "content": "显示  显示当前日期和时间  $ date Mon 28 Nov 2022 10:50:05 PM CST   显示指定格式的当前日期和时间  $ date +\"%Y-%m-%d %H:%M:%S\" 2022-11-28 22:51:10  $ date +\"%y-%m-%d\" 22-11-28  $ date +\"%s\"  # seconds since 1970-01-01 00:00:00 UTC 1669647899   显示指定日期和时间  $ date --date=\"1 day ago\" Sun 27 Nov 2022 10:59:30 PM CST  $ date --date=\"1 day\" Tue 29 Nov 2022 10:59:33 PM CST  # 年 月 日 时 分 秒 -&gt; year month day hour minute second   显示指定格式的指定日期和时间  $ date --date=\"1 day ago\" +\"%Y-%m-%d %H:%M:%S\" 2022-11-27 23:02:43  $ date --date=\"1 day\" +\"%Y-%m-%d %H:%M:%S\" 2022-11-29 23:02:47  "
  },
  
  {
    "title": "sed 命令使用示例",
    "url": "/posts/sed-examples/",
    "categories": "Linux 命令",
    "tags": "sed",
    "date": "2022-11-20 17:17:00 +0800",
    "content": "替换  把 hello 替换为 world  $ sed 's/hello/world/g'   把第 2 到 5 行替换为一行 hello world  $ sed '2,5c hello world'   插入  在第 2 行前面插入一行 hello world  $ sed '2i hello world'   在第 2 行后面插入一行 hello world  $ sed '2a hello world'   在包含 hello 行的前面插入一行 world  $ sed '/hello/i world'   在包含 hello 行的后面插入一行 world  $ sed '/hello/a world'   删除  删除第 2 行  $ sed '2d'   删除第 2 到 5 行  $ sed '2,5d'   删除第 2 到最后行  $ sed '2,$d'   删除包含 hello world 的行  $ sed '/hello world/d'   删除包含 /path/to/sth 的行并使用 # 作为分隔符  $sed '\\#/path/to/sth#d'   打印  打印第 2 行  $ sed '2p'   打印第 2 到 5 行  $ sed '2,5p'   打印第 2 到最后行  $ sed '2,$p'   参考资料          https://www.gnu.org/software/sed/manual/sed.html#Joining-lines           https://www.twle.cn/l/yufei/man/man-basic-sed.html     "
  },
  
  {
    "title": "Linux 上 ELF 文件依赖库的查找顺序",
    "url": "/posts/the-searching-order-of-elf-file-deps/",
    "categories": "Linux 打包",
    "tags": "elf, ld.so, rpath",
    "date": "2022-10-15 13:07:00 +0800",
    "content": "Linux 上的 2 种 ELF 文件类型：可执行文件（Executable file）和 共享对象文件（Shared object file），它们在执行期间需要通过 动态库链接器（ld.so）来查找其依赖的动态库文件，然而系统中可能在不同的目录下存在相同的动态库文件，那么执行时到底链接到哪个目录下的呢，本文将描述其在不同目录间的查找顺序。  如何识别 ELF 文件类型  Linux 上可通过 file 命令来查询文件类型，以 64 位系统为例，可执行文件 的查询结果中将包含如下内容  ELF 64-bit LSB executable   共享对象文件 的查询结果中将包含以下内容：  ELF 64-bit LSB shared object   如何查询依赖库  Linux 上可通过 ldd 命令来查询 可执行文件 或 共享对象文件 的依赖库，例如查询 ls 命令的依赖库：  root@localhost:~# ldd /usr/bin/ls         linux-vdso.so.1 (0x00007ffff2eff000)         /$LIB/libonion.so =&gt; /lib/x86_64-linux-gnu/libonion.so (0x00007fbea7a43000)         libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007fbea7a05000)         libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbea7813000)         libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fbea780d000)         libpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007fbea777d000)         /lib64/ld-linux-x86-64.so.2 (0x00007fbea7b70000)         libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fbea775a000)   依赖库查找顺序  Linux 上查找依赖库是通过 ld.so 程序来完成的，其具体查找顺序如下：          ELF 文件头中 DT_RPATH 字段配置的目录：该字段是可选的，需要注意的是如果 ELF 文件头中同时包含了 DT_RUNPATH 时，则 DT_RPATH 将被忽略，可通过 readelf -d FILENAME 命令来查看是否包含 DT_RPATH 和 DT_RUNPATH。           环境变量 LD_LIBRARY_PATH 中配置的目录。           ELF 文件头中 DT_RUNPATH 字段配置的目录：该字段也为可选的，需要注意的是该字段只会查找 直接依赖 而不查找 间接依赖，而 DT_RPATH 则会查找间接依赖。           文件 /etc/ld.so.cache 中包含的动态库文件列表：该文件是 ldconfig 命令将 /etc/ld.so.conf.d/ 目录下配置的目录列表中的所有动态库搜索后生成的一个缓存列表。           默认系统库目录 /lib 和 /usr/lib：64 位系统则是 /lib64 和 /usr/lib64。      rpath 中的特殊变量  DT_RPATH 和 DT_RUNPATH 统称为 rpath，可以通过在编译时通过编译参数编译进去，也可以在编译后通过其他工具（如 patchelf）来添加修改。  在 rpath 中有一些特殊变量及其含义如下：          $ORIGIN : 表示当前 ELF 文件所在的目录。           $LIB : 表示 /lib 或 lib64 (64 位系统)。      参考资料     https://man7.org/linux/man-pages/man8/ld.so.8.html  "
  },
  
  {
    "title": "fpm: 一个跨平台且支持多种包格式的打包工具",
    "url": "/posts/introduction-to-fpm/",
    "categories": "Linux 打包",
    "tags": "fpm",
    "date": "2022-09-04 20:42:00 +0800",
    "content": "通过《一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式》和《国产操作系统和 CPU 分类》两篇文章，介绍了一种针对 Linux 上的 C/C++ 程序的简化打包数量的方式，从一次打需要适配的操作系统和 CPU 组合数量的包，简化为 CPU 架构数 * 2 的数量，那么在准备编译环境的时候也就需要准备 CPU 架构数 * 2 个。  现在介绍一个打包工具 fpm ，这是一个 跨平台 且 支持多种包格式 的打包工具，通过它可以在一个系统上同时打出 rpm 和 deb 的包，这样就可以把编译环境的数量从 CPU 架构数 * 2 减少到 CPU 架构数，进一步提高打包效率。  fpm 相比 rpm 和 deb 原生的打包方式更简单，且打包时间更短，下面演示使用 fpm 打包 postgresql：  [root@el6-x86_64 fpm_example]# ls pg9 [root@el6-x86_64 fpm_examplej# ls pg9/ bin include lib share [root@el6-x86_64 fpm_example]# fpm -s dir -t rpm -n postgresql -v 9.6.24 --prefix /usr/local ./pg9 Created package {:path=&gt;\"postgresql-9.6.24-1.x86_64.rpm\") [root@el6-x86_64 fpm_example]# fpm -s dir -t deb -n postgresql -v 9.6.24 --prefix /usr/local ./pg9 Created package {:path=&gt;\"postgresql_9.6.24_amd64.deb\") [root@el6-x86_64 fpm_example]# ls pg9 postgresql-9.6.24-1.x86_64.rpm postgresql_9.6.24_and64.deb [root@el6-x86_64 fpm_example]# rpm -ivh postgresql-9.6.24-1.x86_64.rpm Preparing...           ########################################### [100%]     1:postgresql       ########################################### [100%] [root@el6-x86_64 fpm_example]# ls /usr/local/pg9/ bin include lib share [root@el6-x86_64 fpm_example]#    更多关于 fpm 的说明请参考其 官方文档 "
  },
  
  {
    "title": "国产操作系统和 CPU 分类",
    "url": "/posts/classification-of-chinese-os-and-cpu/",
    "categories": "Linux 打包",
    "tags": "os, cpu",
    "date": "2022-09-04 15:32:00 +0800",
    "content": "国产 操作系统 和 CPU 厂商数量繁多，令人眼花缭乱，如果你做一款 C/C++ 软件需要适配国产的各种操作系统和 CPU，打包时针对每一种操作系统和 CPU 的组合都要打一个包的话，那么每一次打包的数量可能会多达数十个，光是编译环境的准备都需要耗费大量的时间，这无疑是令人难以接受的。  但是万变不离其宗，如果经过仔细分析的话，会发现这些操作系统和 CPU 都是从现有的体系中衍生出来的，而不是完全新生事物，比如操作系统都是基于 Linux 的，且按照系统自带的包管理软件的不同，可以分为 2 个系列，分别是使用 rpm 的 redhat 系 和使用 dpkg 的 debian 系，适用于它们的安装包格式分别是 rpm 和 deb。CPU 按照指令架构划分，则可以分为 x86_64、aarch64、mips64el、loongarch64、sw_64 这 5 类，由于叫法的不同，有的会把 x86_64 叫做 amd64，把 aarch64 叫做 arm64，其实本质上它们是一样的。  按照以上这样划分，再结合我的另一篇文章《一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式》中介绍的打包方法，打包工作就可以得到极大的简化，最终就变成了每次只需要打 2 * 5 = 10 个包就可以适配所有的操作系统和 CPU。  以下是我个人接触过的国产操作系统和 CPU 分类：  graph LR     nfs(中科方德 = NFS) --&gt; rpm(redhat系)     isoft(普华 = iSoft) --&gt; rpm     linx(凝思 = Linx) --&gt; rpm     nkyl(中标麒麟 = NeoKylin) --&gt; rpm     kyl(银河麒麟 = Kylin) -- 服务器版 --&gt; rpm     kyl -- 桌面版 --&gt; deb(debian系)     uos(统信 = UOS) --&gt; deb     deepin(深度 = Deepin) --&gt; deb     rpm --&gt; os(操作系统)     deb --&gt; os      hygon(海光 = Hygon) --&gt; x86_64     zhaoxin(兆芯 = Zhaoxin) --&gt; x86_64     phytium(飞腾 = Phytium) --&gt; aarch64(aarch64)     kunpeng(鲲鹏 = Kunpeng) --&gt; aarch64     loongson(龙芯 = Loongson) -- 3000/4000系列 --&gt; mips64el(mips64el)     loongson -- 5000系列 --&gt; loongarch64(loongarch64)     sunway(申威 = Sunway) --&gt; sw_64(sw_64)     x86_64 --&gt; cpu(CPU)     aarch64 --&gt; cpu     mips64el --&gt; cpu     loongarch64 --&gt; cpu     sw_64 --&gt; cpu  "
  },
  
  {
    "title": "一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式",
    "url": "/posts/a-packaging-method-with-its-own-deps/",
    "categories": "Linux 打包",
    "tags": "rpm, deb",
    "date": "2022-09-03 15:34:00 +0800",
    "content": "Linux 上的 C/C++ 程序编译打包后拿到 同 CPU 架构 的其他 Linux 系统上运行时，通常会由于目标系统上缺少该程序所需的库而无法运行。  这个问题在一个连接上互联网的 Linux 系统上可以很容易的通过 yum 或 apt 安装缺少的依赖库来解决，但是如果是在一个无法使用 yum 和 apt 的内网系统上，则非常麻烦。  本文介绍一种打包方式，让打包后的程序自带依赖库，即使在目标系统上没有该程序所需的库时，也能正常运行。  步骤  以下为该方式的详细步骤：  第一步：编译平台的选择  选择一个 libc 版本 小于等于 该程序需要适配的所有系统中 libc 版本最小的系统。  比如该程序需要适配 2 个系统，这两个系统的 libc 版本分别为 2.23 和 2.28，则选择一个 libc 版本 小于等于 2.23 的系统作为编译平台。  第二步：拷贝依赖库  在编译完成后，打包之前，通过 ldd 命令查询该程序中所有 ELF 文件的依赖库，并将查询到的 除 libc 以外的所有依赖库拷贝到该程序的安装目录中（通常是安装目录下的 lib 目录），然后再进行打包。  如果打包方式为 rpm，建议在 spec 文件中添加 AutoReqProv: no 选项。  第三步(可选)：添加 RPATH  在打包之前，给所有该程序中的 ELF 文件添加 RPATH 指向其自带的 lib 目录，让程序在运行时自动优先查找自己的 lib 目录中的库文件，这样程序运行时就不需要目标系统上安装有其依赖库了。  添加 RPATH 需要用到另外一个工具 patchelf，可点击链接下载后进行编译安装。  当然也可以不添加 RPATH，而是在使用时配置 LD_LIBRARY_PATH 环境变量指向其自带的 lib 目录达到同样的效果。  示例  下面以 postgresql 为例对该打包方式进行演示：  第一步：编译平台的选择  选择 CentOS 6 作为编译平台，其 libc 版本为 2.12：  [root@el6-x86_64 ~]# ls -l /lib64/libc.so.6 lrwxrwxrwx 1 root root 12 Jul  8 13:13 /lib64/libc.so.6 -&gt; libc-2.12.so [root@el6-x86_64 ~]# tar xf postgresql-9.6.24.tar.gz [root@el6-x86_64 ~]# cd postgresql-9.6.24/ [root@el6-x86_64 postgresql-9.6.24]# ./configure --prefix=/usr/local/pg9 ... [root@el6-x86_64 postgresql-9.6.24]# make -j`nproc` &amp;&amp; make install ... [root@el6-x86_64 postgresql-9.6.24]# cd /usr/local/pg9 [root@el6-x86_64 pg9]# ls bin include lib share [root@el6-x86_64 pg9]#    第二步：拷贝依赖库  [root@el6-x86_64 ~]# ./copy_deps.sh /usr/local/pg9/ /usr/local/pg9/lib ... Processing /lib64/libc.so.6 Processing /lib64/libdl.so.2  Processing /lib64/1ibm.so.6 Processing /lib64/libpthread.so.0  Processing /lib64/libreadline.so.6 `/lib64/libreadline.so.6' -&gt; `/usr/local/pg9/1ib/libreadline.so.6'  Processing /lib64/1ibrt.so.1 Processing/lib64/libtinfo.so.5 `/lib64/libtinfo.so.5' -&gt; `/usr/local/pg9/1ib/libtinfo.so.5'  Processing /lib64/1ibz.so.1 `/lib64/libz.so.1' -&gt; `/usr/local/pg9/1ib/libz.so.1'  Processing /usr/local/pg9/lib/libecpg.so.6 Processing /usr/local/pg9/1ib/libpgtypes.so.3  Processing /usr/local/pg9/lib/libpq.so.5  [root@el6-x86_64 ~]#    以下为 copy_deps.sh 脚本内容：  #!/bin/bash -e # Copy the deps of all elf files in `ELFDIR` to `LIBDIR`.  PROGNAME=$(basename $0) if [[ $# != 2 ]]; then     echo \"Usage: $PROGNAME ELFDIR LIBDIR\" &gt;&amp;2     exit 1 fi  ELFDIR=$1 LIBDIR=$2  for elf in `find $ELFDIR -type f -exec file {} + | grep ELF | cut -d: -f1`; do      echo \"Analysing $elf\"     ldd $elf     for sopath in `ldd $elf | grep -E '.+.so.* =&gt; /.+.so.* \\(0x.+\\)' | awk '{print $3}'`; do          sopaths+=($sopath)     done done  sopaths=(`for i in ${sopaths[*]}; do echo $i; done | sort -u`)   for sopath in ${sopaths[*]}; do     echo \"Processing $sopath\"      soname=`basename $sopath`     if [[ (! -e $LIBDIR/$soname) ]]; then         if [[ `which dpkg 2&gt; /dev/null` ]]; then             owninfo=`dpkg -S $sopath 2&gt; /dev/null ||:`         else             owninfo=`rpm -qf $sopath 2&gt; /dev/null ||:`         fi         if [[ ! $owninfo =~ ^glibc|^libc6 ]]; then              cp -v $sopath $LIBDIR         fi     fi done   第三步(可选)：添加 RPATH  [root@el6-x86_64 ~]# ./set_relative_rpath.sh /usr/local/pg9/ /usr/local/pg9/lib Set the rpath of /usr/local/pg9/lib/libz.so.1 to $ORIGIN Set the rpath of /usr/local/pg9/1ib/libecpg_compat.so.3.8 to $ORIGIN Set the rpath of /usr/local/pg9/1ib/libreadline.so.6 to $ORIGIN Set the rpath of /usr/local/pg9/1ib/libtinfo.so.5 to $ORIGIN Set the rpath of /usr/local/pg9/1ib/libecpg.so.6.8 to $ORIGIN Set the rpath of/usr/local/pg9/1ib/postgresq1/utf8_and_uhc.so to $ORIGIN/.. Set the rpath of/usr/local/pg9/1ib/postgresq1/latin2_and_win1250.so to $ORIGIN/.. ... Set the rpath of/usr/local/pg9/bin/clusterdb to $ORIGIN/../lib Set the rpath of /usr/local/pg9/bin/postgres to $ORIGIN/../1ib Set the rpath of/usr/local/pg9/bin/pg_restore to $ORIGIN/../1ib Set the rpath of/usr/local/pg9/bin/ecpg to $ORIGIN/../lib  [root@el6-x86_64 ~]#    以下为 set_relative_rpath.sh 脚本内容：  #!/bin/bash -e # Set the rpath of all elf files in `ELFDIR` to relative paths to `LIBDIR`.  PROGNAME=$(basename $0) if [[ $# != 2 ]]; then     echo \"Usage: $PROGNAME ELFDIR LIBDIR\" &gt;&amp;2     exit 1 fi  ELFDIR=$1 LIBDIR=$2  for elf in $(find $ELFDIR -type f -exec file {} + | grep ELF | cut -d: -f1); do     elf_parentdir=$(dirname $elf)     relative_path=$(realpath --relative-to=$elf_parentdir $LIBDIR)     if [[ $relative_path == '.' ]]; then         relative_rpath=\"\\$ORIGIN\"     else         relative_rpath=\"\\$ORIGIN/$relative_path\"     fi     if [[ $(patchelf --print-rpath $elf) != $relative_rpath ]]; then         echo \"Set the rpath of $elf to $relative_rpath\"         patchelf --set-rpath $relative_rpath $elf     fi   done   第四步：验证  将 Centos 6 上的 postgresql 安装目录打包:  [root@el6-x86_64 ~]# cd /usr/local/ [root@el6-x86_64 local]# tar cf pg9.tar ./pg9/ [root@el6-x86_64 local]# ls bin doc etc games include lib lib64 libexec patchelf pg9 pg9.tar pgsql sbin share src ssl [root@el6-x86_64 local]#   将打包的 postgresql 放到另外一个 Ubuntu 20 系统上，该系统 libc 版本为 2.31，验证程序是否可正常使用：  root@ubt20-x86-64:~# ls -l /lib/x86_64-linux-gnu/libc.so.6 lrwxrwxrwx 1 root root 12 Dec 16 2020 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.31.so root@ubt20-x86-64:~# tar xf pg9.tar root@ubt20-x86-64:~# cd pg9/ root@ubt20-x86-64:~/pg9# ldd ./bin/psql         linux-vdso.so.1 (0x00097ffe0ace7000)         libpq.so.5 =&gt; /root/pg9/./bin/../lib/libpq.so.5 (0x00007f374e68a000)         libreadline.so.6 =&gt; /root/pg9/./bin/../lib/libreadline.so.6 (0x0000003fd9200000)         libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f374e52f000)         libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f374e33d090)         libpthread.so.Q =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f374e31a000)         libtinfo.so.5 =&gt; /root/pg9/./bin/../lib/libtinfo.so.5 (0x0000603fdaa00000)         /lib64/ld-linux-x86-64.so.2 (0x00007f374e8b5000) root@ubt20-x86-64:~/pg9# ./bin/psql -V psql (PostgreSQL) 9.6.24 root@ubt20-x86-64:~/pg9#    变更日志     2025-02-21：修改 copy_deps.sh 源码中导致没有拷贝 so 文件的错误。同时发现 patchelf-0.18 修改 so 文件后出现格式错误，建议使用 patchelf-0.13；  "
  },
  
  {
    "title": "Python 入门 - 12 - 模块和包",
    "url": "/posts/python-tutorial-12-modules-and-packages/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2022-03-10 15:16:00 +0800",
    "content": "模块（module）  一个包含 Python 代码的 .py 文件就是一个 模块（module），文件名去除 .py 后缀就是 模块名，模块名也可以通过模块的 __name__ 属性获取。  一个模块可以被 import 引用，也可以当作脚本直接运行，模块中的 定义 和 语句 只在被 import 或直接运行的时候 执行一次。  例如现在有一个名为 fibo.py 的文件，其内容如下：  def fib(n):     a, b = 0, 1     while b &lt; n:         print(b, end=' ')         a, b = b, a+b     print()  def fib2(n):     result = []     a, b = 0, 1     while b &lt; n:         result.append(b)         a, b = b, a+b     return result  # 被当作脚本运行时会进入该 if 分支 if __name__ == \"__main__\":     import sys     fib(int(sys.argv[1]))   导入模块  import 方式导入：  &gt;&gt;&gt; import fibo &gt;&gt;&gt; fibo.fib(1000) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 &gt;&gt;&gt; fibo.fib2(100) [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] &gt;&gt;&gt; fibo.__name__ 'fibo'   from … import 方式导入：  &gt;&gt;&gt; from fibo import fib, fib2 &gt;&gt;&gt; fib(500) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 &gt;&gt;&gt; from fibo import *  # 为避免名称冲突，建议尽量不要使用这种方式 &gt;&gt;&gt; fib(500) 1 1 2 3 5 8 13 21 34 55 89 144 233 377   以脚本方式运行模块  $ python fibo.py 50 1 1 2 3 5 8 13 21 34   内置模块（标准库）  Python 解释器内置了很多的模块（即标准库），这些库提供了很多的便利性，并且单独提供了文档对这些库进行说明：https://docs.python.org/3.5/library/index.html  模块搜索路径  当使用 import 导入模块时，Python 搜索这个模块的路径如下：     内置模块列表   sys.path 列表，其包含如下目录（按顺序）：            包含输入脚本的目录（如果未指定输入脚本直接启动解释器则是当前目录）       PYTHONPATH 环境变量中的目录       其他安装时生成的默认路径（如第三方库安装目录 site-packages）           模块缓存  为了提升模块的 加载 速度，Python 在第一次 import 时会在模块文件所在目录下创建 __pycache__ 目录，并将模块编译后的字节码文件（.pyc），以 modname.version.pyc 文件名格式缓存在该目录下。  例如一个模块文件名为 mymod.py，使用 CPython 3.5 在第一次加载后，会在该文件所在目录下生成路径为 __pycache__/mymod.cpython-35.pyc 的模块缓存文件，那么在下次加载该模块时，如果模块源文件（.py）没有修改（通过 .pyc 文件和对应 .py 文件的修改日期对比进行判断），则直接加载缓存的模块字节文件，如果有修改则重新生成缓存文件。  如果是在命令行以脚本方式直接执行模块文件，则不会生成缓存文件。  缓存模块字节文件还可以在源文件不存在的时候直接加载使用，例如删除 mymod.py 后把 mymod.cpython-35.pyc 从 __pycache__ 中拷贝到上级目录（即原 mymod.py 所在目录），并且去掉文件名中 version 字段（即改名为 mymod.pyc），然后即可直接 import mymod 并使用。这种方式可以方便进行不带源文件分发使用，Python 还提供了 compileall 标准库来进行批量编译源文件后分发使用。  需要注意的是缓存模块文件仅仅提升了 加载 速度，执行速度还是和源文件执行的方式一样的。  查看模块属性  可以使用内置函数 dir() 查看模块中定义的所有名称：  &gt;&gt;&gt; import builtins &gt;&gt;&gt; dir(builtins)   ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',  'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',  'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',  'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',  'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',  'FileExistsError', 'FileNotFoundError', 'FloatingPointError',  'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',  'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',  'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',  'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',  'NotImplementedError', 'OSError', 'OverflowError',  'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',  'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',  'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',  'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',  'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',  'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',  'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',  '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',  'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',  'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',  'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',  'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',  'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',  'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',  'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',  'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',  'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',  'zip']   包（package）  包的目录结构  Python 中当一个目录包含一个 __init__.py 文件（可以是空文件，也可以定义名称）时，这个目录就会被当作一个 包（package），包内可以包含模块文件，也可以包含 子包，不同包内的模块名可以相同而互不冲突，这种机制可以方便对模块分类管理，例如一个处理音频文件的包目录结构如下：  sound/                          Top-level package       __init__.py               Initialize the sound package       formats/                  Subpackage for file format conversions               __init__.py               wavread.py               wavwrite.py               aiffread.py               aiffwrite.py               auread.py               auwrite.py               ...       effects/                  Subpackage for sound effects               __init__.py               echo.py               surround.py               reverse.py               ...       filters/                  Subpackage for filters               __init__.py               equalizer.py               vocoder.py               karaoke.py               ...   包的导入方式  包的用户可以从包中导入单个模块，例如:  import sound.effects.echo   这会加载子模块 sound.effects.echo 。但引用它时必须使用它的全名。  sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)   导入子模块的另一种方法是  from sound.effects import echo   这也会加载子模块 echo ，并使其在没有包前缀的情况下可用，因此可以按如下方式使用:  echo.echofilter(input, output, delay=0.7, atten=4)   另一种形式是直接导入所需的函数或变量:  from sound.effects.echo import echofilter   同样，这也会加载子模块 echo，但这会使其函数 echofilter() 直接可用:  echofilter(input, output, delay=0.7, atten=4)   请注意，当使用 from package import item 时，item 可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 import 语句首先测试是否在包中定义了item，如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。  相反，当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包，最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。  包的 __all__ 属性  包的 __init__.py 文件中可以定义一个名为 __all__ 的列表，用来列出 from package import * 时导入的模块，假如 sound/effects/__init__.py 文件中包含如下定义：  __all__ = [\"echo\", \"surround\", \"reverse\"]   那么在使用 from sound.effects import * 语句时只会导入 echo、surround 和 reverse 三个子模块。  如果没有定义 __all__，当使用 from sound.effects import * 语句时，实际上只导入了 effects 子包。  兄弟包的导入方式  在包中可以使用绝对路径导入兄弟包的模块，比如在上面的 sound 示例包中，在模块 sound.filters.vocoder 中导入 sound.effects.echo 模块的命令如下：  from sound.effects import echo   也可以使用相对路径导入兄弟包的模块，比如在 sound.effects.surround 模块使用相对路径导入其他模块：  from . import echo from .. import formats from ..filters import equalizer   请注意，相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是 __main__ ，因此用作 Python 应用程序主模块的模块必须始终使用绝对导入。  参考资料     [Modules] : https://docs.python.org/3.5/tutorial/modules.html  "
  },
  
  {
    "title": "Python 入门 - 11 - 类",
    "url": "/posts/python-tutorial-11-classes/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2022-02-24 11:05:00 +0800",
    "content": "Python 类源自于 C++ 和 Modula-3 这两种语言的类机制的结合。 Python 中一切皆 对象（Object），类里边又引入了 3 种对象：类对象（Class）、实例对象（Instance） 和 方法对象（Method）  作用域和命名空间  作用域（scope） 指的是 Python 代码中的一个文本区域，分为以下几类：     模块   类   函数   命名空间（namespace） 是一个名字到对象的映射，一个作用域对应会有一个命名空间来保存该作用域中的 名称（name），Python 中按照以下顺序去查找一个名称：     最内部作用域的命名空间（包含局部名称）   最内部作用域与最近的作用域之间的 中间作用域 的命名空间（包含非全局名称 nonlocal）   当前模块的命名空间（包含全局名称 global）   内置名称模块（builtins）的命名空间   命名空间是动态创建的，不同时刻创建的命名空间具有不同的生存期：     包含内置名称的命名空间（builtins）是在 Python 解释器启动时创建的，会持续到解释器退出；   模块的全局命名空间在模块被读入时创建，也会持续到解释器退出（）；   函数的本地命名空间在函数被调用时创建，当函数返回或者抛出异常时被删除（递归调用的函数每次都有自己的本地命名空间）；   以下是一个作用域和命名空间的示例：  def scope_test():     def do_local():         spam = \"local spam\"      def do_nonlocal():         nonlocal spam         spam = \"nonlocal spam\"      def do_global():         global spam         spam = \"global spam\"      spam = \"test spam\"     do_local()     print(\"After local assignment:\", spam)     do_nonlocal()     print(\"After nonlocal assignment:\", spam)     do_global()     print(\"After global assignment:\", spam)  scope_test() print(\"In global scope:\", spam)  # 其输出内容是： ''' After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam '''   类定义  语法格式  类定义语法格式如下：  class ClassName:     &lt;statement-1&gt;     .     .     .     &lt;statement-N&gt;   通常类定义内的语句都是 函数定义，但也可以是其他语句（如属性定义等）。 在进入类定义时，将创建一个 命名空间，用于保存类中的名称。 当（从结尾处）正常离开类定义时，将创建一个 类对象。  类对象支持两种操作：属性引用 和 实例化。  class MyClass:     \"\"\"A simple example class\"\"\"     i = 12345      def f(self):         return 'hello world'   例如以上示例中定义的 MyClass 类，那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类的 实例化 使用函数表示法：  # 创建类的新 实例 并将此对象分配给局部变量 x x = MyClass()   初始化方法  类中可以定义一个 __init__() 方法，用于自定义类的初始化操作：  class MyClass:     def __init__(self):         self.data = []   __init__() 方法定义时还可以有额外的参数：  &gt;&gt;&gt; class Complex: ...     def __init__(self, realpart, imagpart): ...         self.r = realpart ...         self.i = imagpart ... &gt;&gt;&gt; x = Complex(3.0, -4.5) &gt;&gt;&gt; x.r, x.i (3.0, -4.5)   self 参数  类中定义的方法的第一个参数固定被当作类初始化后的 实例本身，通常写作 self，可在方法中使用该变量引用其他 实例属性：  class Complex:     def __init__(self, realpart, imagpart):         self.r = realpart         self.i = imagpart      def get_realpart(self):         return self.r      def get_imagpart(self):         return self.i      # 也可以不定义参数，只是这样就不能在该方法中访问实例属性 r 和 i 了     def get_nothing():         return None   访问限制  如果类中定义的 属性（包括变量和方法） 是以 双下划线（__） 开头，并且以 最多一个下划线结尾，那么即表示该属性是 私有的（Private），不能从外部访问：  &gt;&gt;&gt; class Student(object): ...     def __init__(self, name, score): ...         self.__name = name ...         self.__score = score ...  &gt;&gt;&gt; bart = Student('Bart Simpson', 59) &gt;&gt;&gt; bart.__name Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; AttributeError: 'Student' object has no attribute '__name'   实际上 Python 并没有机制严格的限制对私有属性的访问，只是简单的对私有属性进行了 改名（加上了下划线开头的类名前缀） 而已：  &gt;&gt;&gt; class Student(object): ...     def __init__(self, name, score): ...         self.__name = name ...         self.__score = score ...  &gt;&gt;&gt; bart = Student('Bart Simpson', 59) &gt;&gt;  # 虽然通过下面这种方式可以访问私有属性，但强烈不建议这样做 &gt;&gt;&gt; bart._Student__name 'Bart Simpson'    双下划线开头 并且 双下划线结尾 的名称是 Python 类的一些特殊属性，比如 __name__ 表示类名，__doc__ 表示类注释，还有用于初始化实例的 __init__() 方法等，所以建议也不要自定义这样的属性：  &gt;&gt;&gt; class MyClass(object): ...     \"\"\"my class\"\"\" ...     pass ... &gt;&gt;&gt; MyClass.__name__ 'MyClass' &gt;&gt;&gt; MyClass.__doc__ 'my class' &gt;&gt;&gt;   单下划线 开头的属性也可以直接访问，但是约定俗成的规范是这样的属性表示 保护属性，即能在子类中访问，但不建议从外部访问。  数据属性 会覆盖掉同名的 方法属性，为了避免这种情况发生，建议数据属性使用名词，方法属性使用动词。  类与实例  类是抽象模板，实例是根据类创建出来的具体的对象，每个实例都拥有相同的方法，但各自的数据可能不同。  &gt;&gt;&gt; class Student(object): ...     def __init__(self, name): ...         self.name = name ... &gt;&gt;&gt; student1 = Student('tom') &gt;&gt;&gt; student2 = Student('jack') &gt;&gt;&gt; student1.name 'tom' &gt;&gt;&gt; student2.name 'jack' &gt;&gt;&gt;   在类中直接定义的属性为 类属性，而绑定到实例上的属性是 实例属性，类属性是所有实例 共有 的，实例属性是每个实例 独有 的。  &gt;&gt;&gt; class Student(object): ...     # 类属性 ...     clsname = 'Student' ...     def __init__(self, instname): ...         # 实例属性 ...         self.instname = instname ... &gt;&gt;&gt; student1 = Student('tom') &gt;&gt;&gt; student2 = Student('jack') &gt;&gt;&gt; student1.clsname 'Student' &gt;&gt;&gt; student1.instname 'tom' &gt;&gt;&gt; student2.clsname 'Student' &gt;&gt;&gt; student2.instname 'jack' &gt;&gt;&gt;   类继承  单继承  单继承的语法格式如下：  class DerivedClassName(BaseClassName):     &lt;statement-1&gt;     .     .     .     &lt;statement-N&gt;   其中 BaseClassName 叫做 DerivedClassName 的 基类，也可叫做 父类 或 超类，DerivedClassName 则叫做 BaseClassName 的 子类。  通过继承的方式，子类可以拥有父类的所有属性（包括数据属性和方法属性），当引用类的属性时，搜索顺序是先搜索子类，再搜索父类，然后是父类的父类，依次往上，所以子类如果定义了和父类同名的属性，就相当于覆盖了父类的同名属性。  多重继承  多种继承的语法格式如下：  class DerivedClassName(Base1, Base2, Base3):     &lt;statement-1&gt;     .     .     .     &lt;statement-N&gt;   子类 DerivedClassName 同时从父类 Base1、Base2 和 Base3 继承，这种情况下搜索一个属性的顺序是 深度优先、从左至右、同一个类只搜索一次，比如以上示例中先搜索 DerivedClassName，然后搜索 Base1，然后搜索 Base1 的父类一直搜索到顶，然后再搜索 Base2 依次到顶，依此类推。  关于更详细的搜索顺序见：https://www.python.org/download/releases/2.3/mro/  获取对象信息  type()  使用 type() 函数可以判断一个对象的类型：  &gt;&gt;&gt; type(123) &lt;class 'int'&gt; &gt;&gt;&gt; type('hello') &lt;class 'str'&gt; &gt;&gt;&gt; type(True) &lt;class 'bool'&gt; &gt;&gt;&gt; type(int)  # 类的类型都是 type &lt;class 'type'&gt; &gt;&gt;&gt; type(str) &lt;class 'type'&gt; &gt;&gt;&gt; type(bool) &lt;class 'type'&gt; &gt;&gt;&gt;   types 模块中定义了各种类型，可以方便直观的用于类型判断和比较：  &gt;&gt;&gt; import types &gt;&gt;&gt; def fn(): ...     pass ... &gt;&gt;&gt; type(fn)==types.FunctionType True &gt;&gt;&gt; type(abs)==types.BuiltinFunctionType True &gt;&gt;&gt; type(lambda x: x)==types.LambdaType True &gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType True   isinstance()  isinstance() 函数可以判断一个实例是否为某个 类或其子类 的实例：  &gt;&gt;&gt; isinstance('a', str) True &gt;&gt;&gt; isinstance(123, int) True &gt;&gt;&gt; isinstance(b'a', bytes) True &gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))  # 判断是否某些类型中的一种 True &gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple)) True &gt;&gt;&gt; isinstance(True, int)  # bool 是 int 的子类 True   issubclass()  issubclass() 函数可以判断某个类是否是另一个类的子类：  &gt;&gt;&gt; issubclass(bool, int)  # bool 是 int 的子类 True &gt;&gt;&gt; issubclass(str, int) False   dir()  dir() 函数可以获取一个对象的所有 属性 和 方法:  &gt;&gt;&gt; dir('hello') ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']   getattr(), setattr(), hasattr()  使用 getattr(), setattr(), hasattr() 这三个函数可以操作对象的属性：  &gt;&gt;&gt; class MyObject(object): ...     def __init__(self): ...         self.x = 9 ...     def power(self): ...         return self.x * self.x ... &gt;&gt;&gt; obj = MyObject() &gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？ True &gt;&gt;&gt; obj.x 9 &gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？ False &gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y' &gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？ True &gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y' 19 &gt;&gt;&gt; obj.y # 获取属性'y' 19   类的一些特殊属性  下面只简单介绍一些特殊属性，完整的特性属性详见：https://docs.python.org/3/reference/datamodel.html#special-method-names  __iter__()  如果一个类想被用于 for ... in 循环，类似 list 或 tuple 那样，就必须实现一个 __iter__() 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环。  我们以斐波那契数列为例，写一个 Fib 类，可以作用于 for 循环：  class Fib(object):     def __init__(self):         self.a, self.b = 0, 1 # 初始化两个计数器a，b      def __iter__(self):         return self # 实例本身就是迭代对象，故返回自己      def __next__(self):         self.a, self.b = self.b, self.a + self.b # 计算下一个值         if self.a &gt; 100000: # 退出循环的条件             raise StopIteration()         return self.a # 返回下一个值   现在，试试把 Fib 实例作用于 for 循环：  &gt;&gt;&gt; for n in Fib(): ...     print(n) ... 1 1 2 3 5 ... 46368 75025   __len__  如果想要让对象适用于 len() 函数，即像 list 或 tuple 那样，可以自定义一个 __len__() 方法：  &gt;&gt;&gt; class MyList(object): ...     def __init__(self, datas): ...         self.datas = datas ...     def __len__(self): ...         return len(self.datas) ... &gt;&gt;&gt; mylist = MyList([1, 2, 3]) &gt;&gt;&gt; len(mylist) 3   参考资料     [Classes] : https://docs.python.org/3.5/tutorial/classes.html   [Special method names] : https://docs.python.org/3/reference/datamodel.html#special-method-names   [面向对象编程] : https://www.liaoxuefeng.com/wiki/1016959663602400/1017495723838528   [面向对象高级编程] : https://www.liaoxuefeng.com/wiki/1016959663602400/1017501628721248  "
  },
  
  {
    "title": "Python 入门 - 10 - 异常",
    "url": "/posts/python-tutorial-10-exceptions/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2022-02-11 14:12:00 +0800",
    "content": "异常简介  异常（Exception） 即程序执行过程中产生的预期以外的错误，例如有一个脚本 test.py，其内容如下：  #!/bin/python3  print('2' + 2)   当执行该脚本时会产生如下异常：  [root@localhost ~] python3 test.py  Traceback (most recent call last):   File \"test.py\", line 3, in &lt;module&gt;     print('2' + 2) TypeError: can only concatenate str (not \"int\") to str   上面打印的内容称为 异常栈，以 File 开头的那一行指明了产生异常的位置（即 test.py 的第 3 行），接下来一行即产生异常的语句（即 print(‘2’ + 2)），最后一行为异常类型以及异常消息，通过查看异常栈可以准确定位到产生异常的代码位置并进行修复。  异常处理  try  Python 中使用 try 语句进行异常处理，其语法定义如下：  try_stmt  ::=  try1_stmt | try2_stmt try1_stmt ::=  \"try\" \":\" suite                (\"except\" [expression [\"as\" identifier]] \":\" suite)+                [\"else\" \":\" suite]                [\"finally\" \":\" suite] try2_stmt ::=  \"try\" \":\" suite                \"finally\" \":\" suite   以下是一个简单的示例，该示例会一直等到用户输入一个整数为止，如果输入的不是整数，就会进入到 except 子句中执行 print 打印错误提示：  &gt;&gt;&gt; while True: ...     try: ...         x = int(input(\"Please enter a number: \")) ...         break ...     except ValueError: ...         print(\"Oops!  That was no valid number.  Try again...\") ...   except  except 后面的异常类型可以是多个，使用圆括号括起来，表示捕获其中任一异常类型：  except (RuntimeError, TypeError, NameError):   except 后面也可以不接异常类型，表示捕获任意异常：  except:     print(\"Some error occurred.\")   except 后面还可以接一个 as 子句来保存异常实例，以便后续进行处理：  except OSError as err:     print(\"OS error: {0}\".format(err))   try 后面也可以同时接多个 except 子句，当发生异常时会按照顺序从上往下匹配，如果其中某个 except 子句匹配上了，后面的 except 子句就会跳过:  import sys  try:     f = open('myfile.txt')     s = f.readline()     i = int(s.strip()) except OSError as err:     print(\"OS error: {0}\".format(err)) except ValueError:     print(\"Could not convert data to an integer.\") except:     print(\"Unexpected error:\", sys.exc_info()[0])     raise   当产生的异常属于某个 except 子句后面的异常类的子类时，也会被捕获，比如以下示例中由于 C 和 D 都是 B 的子类，所以最终打印结果将是 B B B：  class B(Exception):     pass  class C(B):     pass  class D(C):     pass  for cls in [B, C, D]:     try:         raise cls()     except B:         print(\"B\")     except C:         print(\"C\")     except D:         print(\"D\")   else  在 except 子句后面还可以接一个 else 子句（如果有多个 except，else 必须放在所有 except 后面），当没有异常发生时，才会进入到 else 子句：  try:     print('hello, world') except:     print('error') else:     print('no error')   finally  在 try 语句的最后（即 except 和 else 后面）还可以接一个 finally 子句，无论是否发生异常，最终都会进入 finally 子句，所以通常可以在 finally 子句中进行一些清理工作：  try:     print('hello, world') except:     print('error') else:     print('no error') finally:     print('finished')   抛出异常  raise 语句可以主动抛出异常：  &gt;&gt;&gt; raise NameError('HiThere') Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; NameError: HiThere   raise 后面可以是一个异常类或者一个异常实例，如果接的是一个异常类则相当于无参数的异常类实例：  raise ValueError  # 相当于 'raise ValueError()'   在 except 子句中还可以使用不接任何参数的 raise 语句，这样表示直接将 except 捕获的异常再次原样抛出：  &gt;&gt;&gt; try: ...     raise NameError('HiThere') ... except NameError: ...     print('An exception flew by!') ...     raise ... An exception flew by! Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 2, in &lt;module&gt; NameError: HiThere   自定义异常  Python 提供了很多了内置异常类，其继承关系如下：  BaseException  +-- SystemExit  +-- KeyboardInterrupt  +-- GeneratorExit  +-- Exception       +-- StopIteration       +-- StopAsyncIteration       +-- ArithmeticError       |    +-- FloatingPointError       |    +-- OverflowError       |    +-- ZeroDivisionError       +-- AssertionError       +-- AttributeError       +-- BufferError       +-- EOFError       +-- ImportError       +-- LookupError       |    +-- IndexError       |    +-- KeyError       +-- MemoryError       +-- NameError       |    +-- UnboundLocalError       +-- OSError       |    +-- BlockingIOError       |    +-- ChildProcessError       |    +-- ConnectionError       |    |    +-- BrokenPipeError       |    |    +-- ConnectionAbortedError       |    |    +-- ConnectionRefusedError       |    |    +-- ConnectionResetError       |    +-- FileExistsError       |    +-- FileNotFoundError       |    +-- InterruptedError       |    +-- IsADirectoryError       |    +-- NotADirectoryError       |    +-- PermissionError       |    +-- ProcessLookupError       |    +-- TimeoutError       +-- ReferenceError       +-- RuntimeError       |    +-- NotImplementedError       |    +-- RecursionError       +-- SyntaxError       |    +-- IndentationError       |         +-- TabError       +-- SystemError       +-- TypeError       +-- ValueError       |    +-- UnicodeError       |         +-- UnicodeDecodeError       |         +-- UnicodeEncodeError       |         +-- UnicodeTranslateError       +-- Warning            +-- DeprecationWarning            +-- PendingDeprecationWarning            +-- RuntimeWarning            +-- SyntaxWarning            +-- UserWarning            +-- FutureWarning            +-- ImportWarning            +-- UnicodeWarning            +-- BytesWarning            +-- ResourceWarning   但是用户也可以自定义异常类，自定义异常类必须直接或间接的继承自 Exception，通常一个异常类里边什么都不做，或者最多定义几个属性用于保存异常相关的信息：  class Error(Exception):     \"\"\"Base class for exceptions in this module.\"\"\"     pass  class InputError(Error):     \"\"\"Exception raised for errors in the input.      Attributes:         expression -- input expression in which the error occurred         message -- explanation of the error     \"\"\"      def __init__(self, expression, message):         self.expression = expression         self.message = message  class TransitionError(Error):     \"\"\"Raised when an operation attempts a state transition that's not     allowed.      Attributes:         previous -- state at beginning of transition         next -- attempted new state         message -- explanation of why the specific transition is not allowed     \"\"\"      def __init__(self, previous, next, message):         self.previous = previous         self.next = next         self.message = message   参考资料     [Errors and Exceptions] : https://docs.python.org/3.5/tutorial/errors.html   [Exception hierarchy] : https://docs.python.org/3.5/library/exceptions.html#bltin-exceptions  "
  },
  
  {
    "title": "Python 入门 - 9 - 输入输出",
    "url": "/posts/python-tutorial-9-input-and-output/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2021-02-24 20:44:30 +0800",
    "content": "终端的输入输出  input  Python 提供了一个 input 函数供终端的输入使用，当程序执行到 input 处时会暂停并等待用户输入，用户输入完成并敲击回车后才会继续执行后续的代码。input 的返回值就是读取到的用户输入内容，还可以在调用 input 时传入一个字符串参数作为等待输入的提示信息显示。  ## 用 var 保存用户输入内容 &gt;&gt;&gt; var = input() 'hello, world' &gt;&gt;&gt; var 'hello, world' &gt;&gt;&gt;   ## 等待输入时显示提示信息 &gt;&gt;&gt; name = input('Please input your name:') Please input your name:'tom' &gt;&gt;&gt; name 'tom' &gt;&gt;&gt;    print  Python 提供一个 print 函数，可用于向终端打印内容，print 函数的定义如下：  print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)   根据定义：print 会把任意多个 object 使用 str() 方法转换为字符串，并且在多个 object 之间使用 sep 进行分割，并且在最后增加 end，sep 和 end 必须是字符串，然后将这些内容输出到 file 参数所指定的对象，file 参数指定的对象必须要有 write(string) 方法，默认 file 参数为 sys.stdout，即当前终端。  ## 向终端输出两个字符 a 和 b &gt;&gt;&gt; print('a', 'b') a b ## 向终端输出 a 和 b，并且将 a 和 b 使用 - 进行分割 &gt;&gt;&gt; print('a', 'b', sep='-') a-b ## 向终端输出 a 和 b，并且在最后输出两个换行(\\n) &gt;&gt;&gt; print('a', 'b', end='\\n\\n') a b  &gt;&gt;&gt;   需要注意的是 print 函数的 sep、end、file 和 flush 参数必须使用关键字参数的方式传入(即使用 name=value 的形式)，否则会被当作待打印的 object 对象。  文件的输入输出  文件的输入输出即为文件的读写，Python 中文件的读写分别使用 read 和 write 函数，但是在进行文件读写前必须使用 open 函数打开文件。  open  open 函数定义如下：  open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)   下面分别对其各参数进行说明：          file      可以是表示 文件路径（相对路径或绝对路径）的字符串（string）或者字节类型（bytes）。   也可以是表示 文件描述符 的数字（Integer），如果是文件描述符，那么默认情况下当 open 返回的文件对象被关闭时，文件描述符也会同时被关闭，除非调用 open 时传入 closefd 参数为 False。           mode      由固定的字符组成的表示文件打开模式的字符串，所有可选字符模式如下：                                 字符           含义                                           r           读模式                             w           写模式，如果文件已存在则清空文件内容                             x           写模式，如果文件已存在则报错                             a           追加写模式，如果文件已存在则从文件末尾开始写入                             b           二进制模式                             t           文本模式                             +           更新模式（可读可写）                           以上字符又可以按照如下规则进行组合：        (r|w|x|a)[b|t][+]      共 3 部分组成，圆括号表示必选参数，方括号表示可选参数   第一部分为必选参数，从 r、w、x、a 中任选一个   第二部分为可选参数，从 b 和 t 中任选一个，默认为 t   第三部分也为可选参数，只有一个可选项 +           根据组合规则，最终完整的模式及含义如下：                                 模式           含义                                           r           只读模式，进行写操作会报错                             w           只写模式，如果文件不存在则创建新文件，如果已存在则清空文件内容，进行读操作会报错                             x           只写模式，如果文件不存在则创建新文件，如果已存在则报错，进行读操作会报错                             a           追加写模式，如果文件不存在则创建新文件，如果已存在则从文件末尾开始写                             r+           读写模式，相当于对 r 模式增加了写操作                             w+           读写模式，相当于对 w 模式增加了读操作                             x+           读写模式，相当于对 x 模式增加了读操作                             a+           读写模式，相当于对 a 模式增加了读操作                             rb           与 r 模式相比，不同点在于以二进制模式打开文件                             wb           与 w 模式相比，不同点在于以二进制模式打开文件                             xb           与 x 模式相比，不同点在于以二进制模式打开文件                             ab           与 a 模式相比，不同点在于以二进制模式打开文件                             rb+           与 r+ 模式相比，不同点在于以二进制模式打开文件                             wb+           与 w+ 模式相比，不同点在于以二进制模式打开文件                             xb+           与 x+ 模式相比，不同点在于以二进制模式打开文件                             ab+           与 a+ 模式相比，不同点在于以二进制模式打开文件                             rt           与 r 模式相同                             wt           与 w 模式相同                             xt           与 x 模式相同                             at           与 a 模式相同                             rt+           与 r+ 模式相同                             wt+           与 w+ 模式相同                             xt+           与 x+ 模式相同                             at+           与 a+ 模式相同                                buffering      缓存策略，可选值即含义如下：                                 值           含义                                           -1           二进制模式: 自动检测存储设备的块大小（即 io.DEFAULT_BUFFER_SIZE，通常是 4096 或 8192，单位字节），并以此作为缓存大小。 交互式文本模式: 即 isatty() 为 True 的文件对象，该情况下将缓存 一行。  其他文本模式: 与二进制模式相同。                             0           不使用缓存，仅适用于二进制模式                             1           缓存 一行，仅适用于文本模式                             &gt;1           以该值（单位字节）作为固定大小进行缓存                                encoding      文件编码和解码格式，仅适用于文本模式，完整的可选编码格式列表见 standard-encodings           errors      当编码或者解码文件内容出现错误时的处理方式，仅适用于文本模式，常用的处理方式如下                                 值           含义                                           strict           当出现编码错误时报 ValueError，默认值                             ignore           忽略错误                           完整的处理方式见 error-handlers           newline      该参数控制读和写的换行符，仅适用于文本模式，可选值及其作用如下：                                 值           读操作时           写操作时                                           None           ‘\\n’、’\\r’ 和 ‘\\r\\n’ 都会被当作换行符，并且统一转换为 ‘\\n’           ‘\\n’ 会被转换为当前系统默认换行符，即 os.linesep                             ’’           ‘\\n’、’\\r’ 和 ‘\\r\\n’ 都会被当作换行符，但是均保持原样，不做转换           对换行符保持原样，不做转换                             ‘\\n’           只有 ‘\\n’ 会被当作换行符，但是不会做转换           对换行符保持原样，不做转换                             ‘\\r’           只有 ‘\\r’ 会被当作换行符，但是不会做转换           ‘\\n’ 会被转换为 ‘\\r’                             ‘\\r\\n’           只有 ‘\\r\\n’ 会被当作换行符，但是不会做转换           ‘\\n’ 会被转换为 ‘\\r\\n’                           io  open 方法返回的所有对象都定义在 io 模块中，其类图如下：  classDiagram     IOBase &lt;|-- RawIOBase     RawIOBase &lt;|-- FileIO     IOBase &lt;|-- BufferedIOBase     BufferedIOBase &lt;|-- BufferedReader     BufferedIOBase &lt;|-- BufferedWriter     BufferedIOBase &lt;|-- BufferedRWPair     BufferedIOBase &lt;|-- BufferedRandom     BufferedIOBase &lt;|-- BytesIO     IOBase &lt;|-- TextIOBase     TextIOBase &lt;|-- TextIOWrapper     TextIOBase &lt;|-- StringIO     class IOBase{         +closed         +close()         +fileno()         +flush()         +isatty()         +readable()         +readline(size=-1)         +readlines(hint=-1)         +seek(offset[, whence])         +seekable()         +tell()         +truncate(size=None)         +writable()         +writelines(lines)     }     class RawIOBase{         +read(size=-1)         +readall()         +readinto(b)         +write(b)     }     class FileIO{         +mode         +name     }     class BufferedIOBase{         +raw         +detach()         +read(size=-1)         +read1(size=-1)         +readinto(b)         +readinto1(b)         +write(b)     }     class BufferedReader{         +peek([size])         +read([size])         +read1(size)     }     class BufferedWriter{         +flush()         +write(b)     }     class BytesIO{         +getbuffer()         +getvalue()         +read1()         +readinto1()     }     class TextIOBase{         +encoding         +errors         +newlines         +buffer         +detach()         +read(size)         +readline(size=-1)         +seek(offset[, whence])         +tell()         +write(s)     }     class TextIOWrapper{         +line_buffering     }     class StringIO{         +getvalue()     }   open 方法在不同模式和缓存策略下返回的文件对象类型如下：                 模式       buffering == 0       buffering != 0                       r       N/A       TextIOWrapper                 w       N/A       TextIOWrapper                 x       N/A       TextIOWrapper                 a       N/A       TextIOWrapper                 r+       N/A       TextIOWrapper                 w+       N/A       TextIOWrapper                 x+       N/A       TextIOWrapper                 a+       N/A       TextIOWrapper                 rb       FileIO       BufferedReader                 wb       FileIO       BufferedWriter                 xb       FileIO       BufferedWriter                 ab       FileIO       BufferedWriter                 rb+       FileIO       BufferedRandom                 wb+       FileIO       BufferedRandom                 xb+       FileIO       BufferedRandom                 ab+       FileIO       BufferedRandom                 rt       与 r 模式相同       与 r 模式相同                 wt       与 w 模式相同       与 w 模式相同                 xt       与 x 模式相同       与 x 模式相同                 at       与 a 模式相同       与 a 模式相同                 rt+       与 r+ 模式相同       与 r+ 模式相同                 wt+       与 w+ 模式相同       与 w+ 模式相同                 xt+       与 x+ 模式相同       与 x+ 模式相同                 at+       与 a+ 模式相同       与 a+ 模式相同           文件读写示例  通常文件读写的流程是先使用 open() 打开文件，然后进行读写操作，最后使用 close() 方法关闭文件：  &gt;&gt;&gt; f = open('testfile', 'r+') &gt;&gt;&gt; f.read() 'hello' &gt;&gt;&gt; f.write('world') 5 &gt;&gt;&gt; f.seek(0) 0 &gt;&gt;&gt; f.read() 'helloworld' &gt;&gt;&gt; f.close()   但是更推荐的方法是使用 with 子句来进行文件读写操作，这样在 with 结束后会自动关闭文件，避免因忘记关闭而占用文件的情况：  &gt;&gt;&gt; data = '' &gt;&gt;&gt; with open('testfile') as f: ...     data = f.read() ... &gt;&gt;&gt; f.closed True &gt;&gt;&gt; data 'hello'   参考资料     [Input and Output] : https://docs.python.org/3.5/tutorial/inputoutput.html   [input] : https://docs.python.org/3.5/library/functions.html#input   [print] : https://docs.python.org/3.5/library/functions.html#print   [open] : https://docs.python.org/3.5/library/functions.html#open   [io] : https://docs.python.org/3.5/library/io.html#i-o-base-classes  "
  },
  
  {
    "title": "Python 入门 - 8 - 函数定义",
    "url": "/posts/python-tutorial-8-function-definition/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-11-24 10:45:50 +0800",
    "content": "函数定义  先看一个简单的函数定义的例子，以 def 语句开头，定义一个名为 add 的函数，接收两个参数 a 和 b，然后返回这两个参数的 和：  &gt;&gt;&gt; def add(a, b): ...     return a + b ... &gt;&gt;&gt; add(1, 2) 3 &gt;&gt;&gt;   在 Python 中，一个定义好的函数可以把函数名赋值给其他变量，然后通过其他变量也可以调用该函数：  &gt;&gt;&gt; def add(a, b): ...     return a + b ... &gt;&gt;&gt; plus = add &gt;&gt;&gt; plus(1, 2) 3 &gt;&gt;&gt;   如果定义的函数体中没有明确使用 return 语句返回值，那么默认返回值是 None：  &gt;&gt;&gt; def nothing(): ...     pass ... &gt;&gt;&gt; r = nothing() &gt;&gt;&gt; r is None True &gt;&gt;&gt;   函数参数  参数默认值  定义函数时可以指定参数的默认值，调用函数时可以不给默认参数传值，不传值则会使用默认值：  ## 定义一个有两个参数有默认值的函数 &gt;&gt;&gt; def introduce(name, age=18, city='beijing'): ...     print('My name is %s, I am %d years old and I am from %s' % (name, age, city)) ... &gt;&gt;&gt; introduce('tom')  # age 和 city 都使用默认值 My name is tom, I am 18 years old and I am from beijing &gt;&gt;&gt; introduce('liubei', city='chengdu')  # city 不使用默认值 My name is liubei, I am 18 years old and I am from chengdu &gt;&gt;&gt; introduce('sanmao', 30, 'chongqin' )  # age 和 city 都不使用默认值 My name is sanmao, I am 30 years old and I am from chongqin &gt;&gt;&gt;   需要注意的是如果参数默认值使用变量的话，那在函数定义时值就已经确定了，即使后面再改变变量的值不会影响参数的默认值：  &gt;&gt;&gt; i = 5 &gt;&gt;&gt; def f(arg=i): ...     print(arg) ... &gt;&gt;&gt; f() 5 &gt;&gt;&gt; i = 6 &gt;&gt;&gt; f()  # i 已经变为 6，但是 arg 参数的默认值仍然是 5 5 &gt;&gt;&gt;   如果参数默认值是一个可变类型的话，可能会有一些意想不到的结果：  &gt;&gt;&gt; def f(a, L=[]): ...     L.append(a) ...     return L ... &gt;&gt;&gt; print(f(1)) [1] &gt;&gt;&gt; print(f(2)) [1, 2] &gt;&gt;&gt; print(f(3))  # 因为 L 是对一个列表的引用，多次调用都是操作的同一个列表 [1, 2, 3] &gt;&gt;&gt;  ## 如果想要避免上面的情况，应该像下面这样写 &gt;&gt;&gt; def f(a, L=None): ...     if L is None: ...         L = [] ...     L.append(a) ...     return L ... &gt;&gt;&gt; print(f(1)) [1] &gt;&gt;&gt; print(f(2)) [2] &gt;&gt;&gt; print(f(3)) [3] &gt;&gt;&gt;   *args 和 **kwargs  有两种比较特殊的形式 *args 和 **kwargs 在函数定义和其他情况下使用时有着不同的作用，在函数定义时使用，相当于定义了个数不确定的参数：  ## 此函数的 nums 相当于是一个序列 &gt;&gt;&gt; def sum(*nums): ...     s = 0 ...     for i in nums: ...         s += i ...     return s ... ## 调用时可以传入任意多个位置参数（按位置传入的参数即为位置参数） &gt;&gt;&gt; sum(1)  1 &gt;&gt;&gt; sum(1, 2) 3 &gt;&gt;&gt; sum(1, 2, 3) 6 &gt;&gt;&gt; sum()  0 &gt;&gt;&gt;   ## 此函数的 kwargs 相当于一个字典 &gt;&gt;&gt; def fun(**kwargs): ...     for k, v in kwargs.items(): ...         print('%s: %s' % (k, v)) ... ## 调用时可以传入任意多个关键字参数（以 name=value 形式传入的参数即为关键字参数） &gt;&gt;&gt; fun(name='tom', age=18, city='beijing') name: tom age: 18 city: beijing &gt;&gt;&gt; fun() &gt;&gt;&gt;   当 *args 和 **kwargs 在其他地方使用时，其作用相当于对一个序列和字典进行 解包 操作：  &gt;&gt;&gt; def add(a, b): ...     return a + b ... &gt;&gt;&gt; nums = [1, 2] &gt;&gt;&gt; add(*nums)  # 函数调用时在 nums 前面加 * 相当于解包 nums 3 &gt;&gt;&gt;   &gt;&gt;&gt; def introduce(name, age): ...     print('My name is %s, I am %d years old.' % (name, age)) ... &gt;&gt;&gt; d = {'name': 'tom', 'age': 18} &gt;&gt;&gt; introduce(**d)  # 函数调用时在字典 d 前面加 ** 相当于解包 d My name is tom, I am 18 years old. &gt;&gt;&gt;   匿名函数（lambda）  Python 中运行使用 lambda 语句定义一个匿名函数，通常用在只需要一行代码即可完成定义的函数：  ## 以下使用 lambda 定义一个匿名函数，函数有两个参数 a 和 b，函数体返回 a + b &gt;&gt;&gt; add = lambda a, b: a + b &gt;&gt;&gt; add(1, 2) 3 &gt;&gt;&gt;   函数文档字符串（docstr）  定义函数时可以在文档字符串中对函数进行简介或详细说明，同时文档字符串还可以方便其他文档生成工具自动生成代码的函数说明文档。文档字符串在函数定义 def 语句的下一行开始写，以三个双引号（\"\"\"）进行包裹，可以是一行或多行：  ## 只有一行文档字符串进行简要介绍 def add(a, b):     \"\"\"This is an add function.\"\"\"     return a + b  ## 多行文档字符串对函数进行详细说明 def add(a, b):     \"\"\"This is an add function.      :param a: number a     :type a: int     :param b: number b     :type b: int     :return: The sum of a and b.     \"\"\"     return a + b   函数注解（Function Annotations）  从 Python3 开始支持定义函数时使用 注解 方式说明参数和返回值类型：  ## 使用注解说明参数 a, b 和返回值类型都是 int &gt;&gt;&gt; def add(a: int, b: int) -&gt; int: ...     return a + b ... &gt;&gt;&gt; add(1, 2) 3 &gt;&gt;&gt;   更多关于函数注解说明可以参考 PEP 484  参考资料     [Defining Functions] : https://docs.python.org/3.5/tutorial/controlflow.html#defining-functions   [More on Defining Functions] : https://docs.python.org/3.5/tutorial/controlflow.html#more-on-defining-functions   [Function definitions] : https://docs.python.org/3.5/reference/compound_stmts.html#function-definitions   [PEP 484] : https://www.python.org/dev/peps/pep-0484/  "
  },
  
  {
    "title": "Python 入门 - 7 - 流程控制",
    "url": "/posts/python-tutorial-7-flow-control/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-10-18 15:58:25 +0800",
    "content": "if  if 是条件控制语句，其语法定义如下：  if_stmt ::=  \"if\" expression \":\" suite              ( \"elif\" expression \":\" suite )*              [\"else\" \":\" suite]   if 是固定格式，当 if 后面的 expression 为 真 时执行其后面的 suite，然后可以在后面接 0 或任意多个 elif 语句，最后一条 else 语句为 可选。  &gt;&gt;&gt; x = 8 &gt;&gt;&gt; if x &lt; 0: ...     print('negative') ... elif x == 0: ...     print('zero') ... else: ...     print('positive') ...  positive &gt;&gt;&gt;    Python 中没有像 C 语言的 switch...case 这样的结构，因为使用 elif 就能达到这样的效果。  真值计算  对于 if 语句后面的表达式 expression 的计算结果，除了以下几种情况为 假 之外，其他情况均为 真：     None   False   数字类型零：0, 0.0, 0j   空序列：'', (), []   空字典：{}   如果是用户自定义类，然后实现了 __bool__ 或 __len__ 方法，并且其返回结果为 False 或者 0，那么也被当作 假   ## None &gt;&gt;&gt; if None: ...     print('should not print') ... else: ...     print('should print') ...  should print &gt;&gt;&gt;   ## 整数0 &gt;&gt;&gt; if 0: ...     print('should not print') ... else: ...     print('should print') ...  should print &gt;&gt;&gt;  ## 空字符串 &gt;&gt;&gt; if '': ...     print('should not print') ... else: ...     print('should print') ...  should print &gt;&gt;&gt;   ## 空字典 &gt;&gt;&gt; if {}: ...     print('should not print') ... else: ...     print('should print') ...  should print &gt;&gt;&gt;    布尔运算符  有时在 if 后面的 expression 中会是一个由 布尔运算符 连接多个部分所组成的表达式，比如：  &gt;&gt;&gt; p = '/home/user1/' &gt;&gt;&gt; if p.startswith('/') and p.endswith('/'): ...     print('The absolute path of a directory') ...  The absolute path of a directory &gt;&gt;&gt;    对于包含 布尔运算符 的表达式的真假值判断遵循以下规范：                 操作符       结果                       x or y       如果 x 为假，则结果为 y，否则为 x                 x and y       如果 x 为假，则结果为 x，否则为 y                 not x       如果 x 为假，则结果为 True，否则为 False           (1) or 是一个 短路运算符，只有当 x 为 假 时才会计算 y。 (2) and 也是一个 短路运算符，只有当 x 为 真 时才会计算 y。 (3) 这 3 个布尔运算符的优先级关系为：not &gt; and &gt; or  &gt;&gt;&gt; 1 or 2 1 &gt;&gt;&gt; 0 or 2 2 &gt;&gt;&gt;   &gt;&gt;&gt; 1 and 2 2 &gt;&gt;&gt; 0 and 1 0   比较运算符  比较运算符也常用于 if 后面的 expression 表达式，比较运算符总是返回 bool 类型的结果，即 True 或 Flase，所有比较运算符如下：                 运算符       说明                       &lt;       小于                 &lt;=       小于等于                 &gt;       大于                 &gt;=       大于等于                 ==       等于                 !=       不等于                 is       判断是否是某个对象                 is not       判断是否不是某个对象           for  for 语句的定义如下：  for_stmt ::=  \"for\" target_list \"in\" expression_list \":\" suite               [\"else\" \":\" suite]   Python 中的 for 循环只有 for...in 的形式，它遍历序列 expression_list，每次遍历取出的元素赋值给 target_list，第一个 suite 是循环体，然后还可以使用一个 else 子句，else 只有在 for 循环正常结束之后才会执行，如果在 for 循环中被 break 打断了，则会跳过 else 子句。  ## 遍历一个 list &gt;&gt;&gt; for c in ['a', 'b', 'c']: ...     print(c) ...  a b c &gt;&gt;&gt;   ## 如果想要类似 C 语言中的 for 循环，可以使用 range ## 关于 range 的详细说明可参考前面《列表与元组》章节 &gt;&gt;&gt; for i in range(5): ...     print(i) ...  0 1 2 3 4 &gt;&gt;&gt;   ## 如果使用了 else 子句，那么会在循环正常结束后再执行 else 子句 &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; for i in (1, 2, 3): ...     sum += i ... else: ...     print('sum = %d' % sum) ...  sum = 6 &gt;&gt;&gt;   ## 如果 for 循环体中使用了 break，那么则不会执行 else 子句 &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; for i in (1, 2, 3): ...     sum += i ...     if i == 2: ...         break ... else: ...     print('sum = %d' % sum) ...  &gt;&gt;&gt; print(sum) 3 &gt;&gt;&gt;    如果需要在 for 循环时同时取序列中元素的下标和值，可以使用 enumerate 函数：  &gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']): ...     print(i, v) ... 0 tic 1 tac 2 toe   如果需要在 for 循环遍历一个序列的同时修改该序列，建议是对该序列做一个拷贝然后再遍历该拷贝，如果不用拷贝的方式，直接在遍历该序列的同时修改该序列，可能会出现一些不可意料的情况：  ## 想要去除 nums 中的偶数 &gt;&gt;&gt; nums = [1, 2, 4, 3] &gt;&gt;&gt; for n in nums: ...     if n % 2 == 0: ...         nums.remove(n) ...  &gt;&gt;&gt; nums ## python 在循环时内部会有一个计数器记录当前循环下标(从 0 开始)，并且每次自动加 1 ## 所以当循环到元素 2 时，记录的当前下标为 1，然后判断 2 为偶数并移除了它，然后后面 ## 的元素依次往前挪一位，当进入下一次循环时自动取下标为 2 的元素，则取到了元素 3，这 ## 样就把元素 4 给漏掉了。 [1, 4, 3] &gt;&gt;&gt;   ## 这种情况一般建议拷贝一份序列后再对其进行遍历 &gt;&gt;&gt; nums = [1, 2, 4, 3] &gt;&gt;&gt; for n in nums.copy(): ...     if n % 2 == 0: ...         nums.remove(n) ...  &gt;&gt;&gt; nums [1, 3] &gt;&gt;&gt;  ## 还可以使用切片方式 nums[:] 创建一个拷贝，比 copy 的方式更简洁 &gt;&gt;&gt; nums = [1, 2, 4, 3] &gt;&gt;&gt; for n in nums[:]: ...     if n % 2 == 0: ...         nums.remove(n) ...  &gt;&gt;&gt; nums [1, 3] &gt;&gt;&gt;    使用 for 循环对字典遍历时默认遍历其 key，但是也可以使用字典的 .items() 方法同时遍历其 key 和 value，或者使用字典的 .values() 方法只遍历其 value：  ## 遍历字典的 key &gt;&gt;&gt; d = {'name': 'tom', 'age': 18} &gt;&gt;&gt; for k in d: ...     print(k) ...  name age &gt;&gt;&gt;   ## 同时遍历 key 和 value &gt;&gt;&gt; for k, v in d.items(): ...     print(k, v) ...  name tom age 18 &gt;&gt;&gt;   ## 只遍历 value &gt;&gt;&gt; for v in d.values(): ...     print(v) ...  tom 18 &gt;&gt;&gt;    如果需要使用 for 循环同时遍历多个长度相同的序列时可以使用 zip 函数：  ## 同时遍历 2 个序列 &gt;&gt;&gt; keys = ['name', 'age'] &gt;&gt;&gt; values = ['tom', 18] &gt;&gt;&gt; for k, v in zip(keys, values): ...     print(k, v) ...  name tom age 18 &gt;&gt;&gt;   ## 同时遍历 3 个序列 &gt;&gt;&gt; for i, j, k in zip([1, 2], [3, 4], [5, 6]): ...     print(i, j, k) ...  1 3 5 2 4 6 &gt;&gt;&gt;    如果需要使用 for 循环反向遍历一个序列时，可以使用 reversed 函数：  &gt;&gt;&gt; for i in reversed([1, 2, 3]): ...     print(i) ...  3 2 1 &gt;&gt;&gt;    while  while 语句的定义如下：  while_stmt ::=  \"while\" expression \":\" suite                 [\"else\" \":\" suite]   当表达式 expression 为 真 时执行 suite，后边还可以跟一个可选的 else 子句，当表达式 expression 为 假 时执行 else 子句中的 suite，如果在第一个 suite 中执行了 break，则退出循环，并且不会执行 else 子句。  ## 使用 while 循环计算 1 ~ 10 的和 &gt;&gt;&gt; i = 1 &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; while i &lt;= 10: ...     sum += i ...     i += 1 ...  &gt;&gt;&gt; sum 55 &gt;&gt;&gt;   ## else 子句在 while 的 expression 为假时执行 &gt;&gt;&gt; i = 1 &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; while i &lt;= 10: ...     sum += i ...     i += 1 ... else: ...     print('loops over') ...  loops over &gt;&gt;&gt; sum 55  ## while 的循环体中执行了 break，所以子句 else 被跳过不执行 &gt;&gt;&gt; i = 1 &gt;&gt;&gt; sum = 0 &gt;&gt;&gt; while i &lt;= 10: ...     sum += i ...     i += 1 ...     if i == 9: ...         break ... else: ...     print('loop over') ...  &gt;&gt;&gt; sum 36 &gt;&gt;&gt;    break  break 语句用于 for 或者 while 循环体中，执行后直接退出循环，并且不会执行循环的 else 子句，具体示例请见上面的 for 和 while 小节内容，这里不再重复举例。  continue  continue 语句用在 for 或者 while 循环体中，跳过本次循环中后续的内容，然后进入下一次循环，它不会结束整个循环，并且不影响循环的 else 子句。  ## 使用 continue 跳过 for 循环中偶数的打印步骤，并且不会影响到 else 子句 &gt;&gt;&gt; for i in range(1, 11): ...     if i % 2 == 0: ...         continue ...     print(i) ... else: ...     print('loops over') ...  1 3 5 7 9 loops over &gt;&gt;&gt;   ## 使用 continue 跳过 while 循环中偶数的打印步骤，并且不会影响到 else 子句 &gt;&gt;&gt; i = 0 &gt;&gt;&gt; while i &lt;= 10: ...     i += 1 ...     if i % 2 == 0: ...         continue ...     print(i) ... else: ...     print('loops over') ...  1 3 5 7 9 11 loops over &gt;&gt;&gt;    pass  pass 语句不做任何事情，通常用于一些在语法上需要写内容，但是实际没有内容可写的情况下进行占位。  ## 自定义异常类 class MyException(Exception):     pass  ## 先定好函数名，函数体还需进一步思考后编写 def myfun():     pass   参考资料     [More Control Flow Tools] : https://docs.python.org/3.5/tutorial/controlflow.html   [Truth Value Testing] : https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing   [Boolean Operations] : https://docs.python.org/3.5/library/stdtypes.html#boolean-operations-and-or-not   [Comparisons] : https://docs.python.org/3.5/library/stdtypes.html#comparisons   [The if statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-if-statement   [The while statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-while-statement   [The for statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-for-statement  "
  },
  
  {
    "title": "Python 入门 - 6 - 字典与集合",
    "url": "/posts/python-tutorial-6-dict-and-set/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-08-06 10:31:58 +0800",
    "content": "字典（dict）  字典通过 键值对(key: value) 的方式，把 key 映射到 value。key 必须是 可 hash 的(hashable)，由于 Python 中所有内置的 不可变类型(immutable) 都是可 hash 的，所以都可用作字典的 key，比如 字符串(str)、数字(int, float) 和 只包含不可变类型元素的元组(tuple)，如果元组直接或间接的包含了 可变类型 的元素，也不能作为字典的 key。value 则可以是任意类型。  字典中元素是无序的，并不会按照插入的顺序排列，可能会是任意的顺序，如果想要有序的字典，可以使用 collections.OrderedDict。但是从 Python 3.7 开始，字典默认是按照插入顺序排序的了。  字典创建  创建一个字典可以通过以下 3 种方式：          大括号 {} 方式：        &gt;&gt;&gt; d = {'name': 'lilei', 'age': 18}   &gt;&gt;&gt; d   {'age': 18, 'name': 'lilei'}                dict 关键字方式：      dict 的定义如下：        class dict(**kwarg)   class dict(mapping, **kwarg)   class dict(iterable, **kwarg)           根据定义 dict 接受如下形式的参数进行初始化：        &gt;&gt;&gt; dict(one=1, two=2)   # 关键字参数形式(**kwargs)   {'one': 1, 'two': 2}   &gt;&gt;&gt; dict({'one': 1, 'two': 2})  # 字典形式(mapping)   {'one': 1, 'two': 2}   &gt;&gt;&gt; dict([('one', 1), ['two', 2]])  # 可迭代类型中内嵌2个元素的可迭代类型(iterable)   {'one': 1, 'two': 2}    &gt;&gt;&gt; dict({'one': 1}, two=2)  # 字典+关键字参数形式(mapping + **kwargs)   {'one': 1, 'two': 2}   &gt;&gt;&gt; dict([('one', 1)], two=2)  # 可迭代类型+关键字参数形式(iterable + **kwargs)   {'one': 1, 'two': 2}                字典推导式(dict comprehension)：        &gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}   {2: 4, 4: 16, 6: 36}           字典操作          len(d)      返回字典 d 的长度，即包含多少个键值对        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; len(d)   2                d[key]      返回 key 对应的 value，如果 key 不存在，则抛出 KeyError 异常        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d['one']   1   &gt;&gt;&gt; d['three']   Traceback (most recent call last):       File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   KeyError: 'three'                d[key] = value      设置 key 对应的 value，如果 key 不存在则自动添加        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d['two'] = 2.0   &gt;&gt;&gt; d['three'] = 3   &gt;&gt;&gt; d   {'one': 1, 'two': 2.0, 'three': 3}                del d[key]      删除 key 对应的项，如果 key 不存在则抛出 KeyError 异常        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; del d['two']   &gt;&gt;&gt; d   {'one': 1}                pop(key[, default])      删除 key 对应的项并且返回对应的 value，如果 key 不存在并且传入了 default 参数，那么返回 default，否则抛出 KeyError 异常        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d.pop('two')   2   &gt;&gt;&gt; d.pop('three', 0)  # 不存在 key 为 'three' 的项则返回 0   0   &gt;&gt;&gt; d   {'one': 1}                popitem()      任意删除并返回一个项，由于字典是无序的，所以删除的项是不确定的        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d.popitem()   ('one', 1)   &gt;&gt;&gt; d   {'two': 2}           从 Python 3.7 开始字典是有序的（按照插入顺序排序），所以 popitem() 会按照 LIFO 规则删除，即相当于删除最后一个项           key in d      如果 key 存在于字典 d 中，则返回 True，否则返回 False        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; 'one' in d   True   &gt;&gt;&gt; 'three' in d   False                key not in d      如果 key 不存在于字典 d 中，则返回 True，否则返回 False        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; 'one' not in d   False   &gt;&gt;&gt; 'three' not in d   True                iter(d)      返回一个包含字典 d 的所有 key 的迭代器（iterator）        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; for k in iter(d):   ...     print(k)   ...   one   two                clear()      清空字典        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d.clear()   &gt;&gt;&gt; d   {}                copy()      返回字典的 浅拷贝，关于 浅拷贝 与 深拷贝 可以参考 《列表与元组》 章节        &gt;&gt;&gt; d1 = {'one': 1, 'two': 2}   &gt;&gt;&gt; d2 = d1.copy()   &gt;&gt;&gt; d2   {'one': 1, 'two': 2}                classmethod fromkeys(seq[, value])      返回一个新的字典，字典的 keys 来自参数 seq，并且所有 key 的 value 为参数 value，value 参数默认值为 None。   这是一个 类方法，用于以其他形式创建字典。        &gt;&gt;&gt; dict.fromkeys(['three', 'four'])   {'four': None, 'three': None}   &gt;&gt;&gt; dict.fromkeys(['three', 'four'], 0)  # 初始值为 0   {'four': 0, 'three': 0}   &gt;&gt;&gt;                get(key[, default])      返回 key 对应的 value，如果 key 不存在则返回 default，default 默认为 None        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d.get('one')   1   &gt;&gt;&gt; d.get('three', 0)  # 不存在则返回 0   0                items()      返回一个包含所有项的 字典视图(view)，每一项是一个 2 个元素的 tuple，分别为 key 和 value        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; for k, v in d.items():   ...     print('%s = %s' % (k, v))   ...   one = 1   two = 2                keys()      返回一个包含所有 key 的 字典视图(view)        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; for k in d.keys():   ...     print(k)   ...   one   two                values()      返回一个包含所有 value 的 字典视图(view)        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; for v in d.values():   ...     print(v)   ...   1   2                setdefault(key[, default])      如果 key 存在于字典中，则返回其对应的 value，否则插入 key ，并且将其 value 设置为 default，default 默认为 None        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d.setdefault('two')   2   &gt;&gt;&gt; d.setdefault('three', 3)   3   &gt;&gt;&gt; d   {'one': 1, 'two': 2, 'three': 3}                update([other])      更新字典中的项，可接受参数类型与 dict 关键字一样        &gt;&gt;&gt; d = {'one': 1, 'two': 2}   &gt;&gt;&gt; d.update({'two': 2.0, 'three': 3})  # mapping 形式   &gt;&gt;&gt; d   {'one': 1, 'two': 2.0, 'three': 3}   &gt;&gt;&gt; d.update([('three', 3.0), ('four', 4)])  # iterable 形式   &gt;&gt;&gt; d   {'one': 1, 'two': 2.0, 'three': 3.0, 'four': 4}   &gt;&gt;&gt; d.update(five=5, six=6)  # **kwargs 形式   &gt;&gt;&gt; d   {'four': 4, 'two': 2.0, 'three': 3.0, 'six': 6, 'one': 1, 'five': 5}   &gt;&gt;&gt; d.update({'six': 6.0}, seven=7)  # mapping + **kwargs 形式   &gt;&gt;&gt; d   {'four': 4, 'two': 2.0, 'three': 3.0, 'six': 6.0, 'one': 1, 'seven': 7, 'five': 5}   &gt;&gt;&gt; d.update([('one', 1.0), ('four', 4.0)], five=5.0, seven=7.0)  # iterable + **kwargs 形式   &gt;&gt;&gt; d   {'four': 4.0, 'two': 2.0, 'three': 3.0, 'six': 6.0, 'one': 1.0, 'seven': 7.0, 'five': 5.0}           字典视图  上面提到的 d.keys()、d.values() 和 d.items() 等方法返回的都是一个 视图类型(view object)，通过这些视图可以访问字典 d 的 keys、values 或 items，并且视图会随着字典的变化而自动更新。  &gt;&gt;&gt; d = {'one': 1, 'two': 2} &gt;&gt;&gt; keys = d.keys() &gt;&gt;&gt; values = d.values() &gt;&gt;&gt; items = d.items() &gt;&gt;&gt; keys dict_keys(['one', 'two']) &gt;&gt;&gt; values dict_values([1, 2]) &gt;&gt;&gt; items dict_items([('one', 1), ('two', 2)])  ## 视图随着字典变化而动态更新 &gt;&gt;&gt; d.update(three=3) &gt;&gt;&gt; keys dict_keys(['one', 'two', 'three']) &gt;&gt;&gt; values dict_values([1, 2, 3]) &gt;&gt;&gt; items dict_items([('one', 1), ('two', 2), ('three', 3)])  ## 可以对视图进行迭代(iteration) &gt;&gt;&gt; for k in keys: ...     print(k) ... one two three   字典比较  字典只支持 == 比较操作符，当且仅当所有项都相等时才相等。对于 &lt;、&gt;、&lt;= 和 &gt;= 比较操作符都不支持，如果使用会抛 TypeError 错误。  集合（set）  集合(set) 是一些 无序(unordered)、无重复(no duplicate) 并且 可hash(hashable) 元素的组合。通常用于 是否包含某个成员的检测、去除重复元素 等操作。同时也支持数学上的集合运算，比如 交集(intersection)、并集(union)、差集(difference) 和 对称差集(symmetric difference)。  Python 内置两种类型集合，set 和 frozenset，set 是可变类型(mutable)，frozenset 是不可变类型(immutable)。  集合创建  集合创建可以通过以下 3 种方式：          大括号 {} 方式：        &gt;&gt;&gt; s = {'a', 'b', 'c', 'a'}   &gt;&gt;&gt; s   {'c', 'b', 'a'}  # 相等元素只保留第一个                set 或 frozenset 关键字方式：      set 和 frozenset 的定义如下：        class set([iterable])   class frozenset([iterable])           根据以上定义可以通过下面的方式创建集合：        &gt;&gt;&gt; s = set(['a', 'b', 'c'])   &gt;&gt;&gt; fs = frozenset(['a', 'b', 'c'])   &gt;&gt;&gt; s   {'c', 'b', 'a'}   &gt;&gt;&gt; fs   frozenset({'c', 'b', 'a'})   &gt;&gt;&gt; s.add('d')  # set 是可变类型   &gt;&gt;&gt; s   {'c', 'b', 'd', 'a'}   &gt;&gt;&gt; fs.add('d')  # frozenset 是不可变类型   Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   AttributeError: 'frozenset' object has no attribute 'add'   &gt;&gt;&gt;                集合推导式(set comprehension):        &gt;&gt;&gt; {x for x in range(1, 11)}   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}           集合中的元素必须是 可hash的(hashable)  ## str、numeric 和 tuple 类型都是可hash的 &gt;&gt;&gt; {'one', 2, (3, 4)} {'one', 2, (3, 4)}  ## list 是 unhashable 类型 &gt;&gt;&gt; {1, [2]} Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: unhashable type: 'list'  ## 间接包含 unhashable 类型也不行 &gt;&gt;&gt; {1, (2, [3])} Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: unhashable type: 'list'   如果要创建空集合，必须使用 set 或 frozenset 关键字，不能使用大括号，因为 {} 创建的是一个空字典。  &gt;&gt;&gt; s = set() &gt;&gt;&gt; s set() &gt;&gt;&gt; fs = frozenset() &gt;&gt;&gt; fs frozenset() &gt;&gt;&gt; d = {} &gt;&gt;&gt; d {} &gt;&gt;&gt; type(d) &lt;class 'dict'&gt;   集合操作  以下是 set 和 frozenset 都支持的操作：          len(s)      返回结合中元素的个数        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; len(s)   2                x in s      判断 x 是否被包含于集合 s 中        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; 1 in s   True   &gt;&gt;&gt; 3 in s   False                x not in s      判断 x 是否不被包含于集合 s 中        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; 1 not in s   False   &gt;&gt;&gt; 3 not in s   True                isdisjoint(other)      判断当前集合是否与其他集合 other 没有交集        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.isdisjoint({3, 4})   True   &gt;&gt;&gt; s.isdisjoint({2, 3})   False                issubset(other) set &lt;= other      判断当前集合是否为其他集合 other 的 子集        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {1, 2, 3}   &gt;&gt;&gt; s.issubset(other)   True   &gt;&gt;&gt; s &lt;= other   True   &gt;&gt;&gt; other = {1, 4, 3}   &gt;&gt;&gt; s.issubset(other)   False   &gt;&gt;&gt; s &lt;= other   False                set &lt; other      判断当前集合是否为其他集合 other 的 真子集        &gt;&gt;&gt; {1, 2} &lt; {1, 2, 3}   True   &gt;&gt;&gt; {1, 2} &lt; {1, 2}   False                issuperset(other) set &gt;= other      判断当前集合是否为其他集合 other 的 超集        &gt;&gt;&gt; s = {1, 2, 3}   &gt;&gt;&gt; other = {1, 2}   &gt;&gt;&gt; s.issuperset(other)   True   &gt;&gt;&gt; s &gt;= other   True                set &gt; other      判断当前集合是否其他集合 other 的 真超集        &gt;&gt;&gt; {1, 2, 3} &gt; {1, 2}   True   &gt;&gt;&gt; {1, 2} &gt; {1, 2}   False                union(*others) set | other | …      当前集合与其他一个或多个集合求 并集        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.union(other)   {1, 2, 3}   &gt;&gt;&gt; s | other   {1, 2, 3}                intersection(*others) set &amp; other &amp; …      当前集合与其他一个或多个集合求 交集        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.intersection(other)   {2}   &gt;&gt;&gt; s &amp; other   {2}                difference(*others) set - other - …      当前集合与其他一个或多个集合求 差集        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.difference(other)   {1}   &gt;&gt;&gt; s - other   {1}                symmetric_difference(other) set ^ other      当前集合与其他集合 other 求 对称差集        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s ^ other   {1, 3}   &gt;&gt;&gt; s.symmetric_difference(other)   {1, 3}                copy()      返回当前集合的一个 浅拷贝        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.copy()   {1, 2}           需要注意的是以上的 比较方法 union()、intersection()、difference()、symmetric_difference()、issubset() 和 issuperset()，接受的参数除了集合类型外，还可以是 可迭代类型(iterable)。相比之下，对应的 比较运算符 则只能接受集合类型参数。  &gt;&gt;&gt; {1, 2}.union([3, 4])  # union 方法可以接受 iterable 类型 {1, 2, 3, 4} &gt;&gt;&gt; {1, 2} | [3, 4]  # | 运算符不能接受 iterable 类型 Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: unsupported operand type(s) for |: 'set' and 'list'   以下是只有 set 支持的操作：          update(*others) set |= other | …      将当前集合与其他一个或多个集合求 并集 然后更新到当前集合        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.update(other)   &gt;&gt;&gt; s   {1, 2, 3}   &gt;&gt;&gt; s |= {3, 4}   &gt;&gt;&gt; s   {1, 2, 3, 4}                intersection_update(*others) set &amp;= other &amp; …      将当前集合与其他一个或多个集合求 交集 然后更新到当前集合        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.intersection_update(other)   &gt;&gt;&gt; s   {2}   &gt;&gt;&gt; s &amp;= {3, 4}   &gt;&gt;&gt; s   set()                difference_update(*others) set -= other | …      将当前集合与其他一个或多个集合求 差集 然后更新到当前集合        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.difference_update(other)   &gt;&gt;&gt; s   {1}   &gt;&gt;&gt; s -= {3, 4}   &gt;&gt;&gt; s   {1}                symmetric_difference_update(other) set ^= other      将当前集合与其他集合 other 求 对称差集 然后更新到当前集合        &gt;&gt;&gt; other = {2, 3}   &gt;&gt;&gt; s.symmetric_difference_update(other)   &gt;&gt;&gt; s   {1, 3}   &gt;&gt;&gt; s ^= {3, 4}   &gt;&gt;&gt; s   {1, 4}                add(elem)      添加一个元素 elem 到当前集合        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.add(3)   &gt;&gt;&gt; s   {1, 2, 3}                remove(elem)      从当前集合删除元素 elem ，如果 elem 不存在则抛 KeyError 异常        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.remove(2)   &gt;&gt;&gt; s   {1}   &gt;&gt;&gt; s.remove(2)   Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   KeyError: 2                discard(elem)      从当前集合删除元素 elem ，如果 elem 不存在也不抛异常        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.discard(2)   &gt;&gt;&gt; s   {1}   &gt;&gt;&gt; s.discard(2)   &gt;&gt;&gt; s   {1}                pop()      从当前集合任意删除一个元素并返回，由于集合是无序的，所以删除哪个元素不确定，如果当前集合为空，则抛 KeyError 异常        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.pop()   1   &gt;&gt;&gt; s.pop()   2   &gt;&gt;&gt; s.pop()   Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   KeyError: 'pop from an empty set'                clear()      清空当前集合        &gt;&gt;&gt; s = {1, 2}   &gt;&gt;&gt; s.clear()   &gt;&gt;&gt; s   set()           同样的以上的 update()、intersection_update()、difference_update() 和 symmetric_difference_update() 也接受可迭代类型参数，但是对应的 运算符 则只能接受集合类型参数。  immutable 与 hashable  Python 中不可变类型 immutable 都是 hashable 类型的，但是 hashable 类型并不一定都是 immutable 的，因为默认所有 自定义类的实例 都是 hashable 类型的，其 hash 值通常就是 id() 函数的计算结果，由于用户自定义类不一定是不可变类型的，所以 hashable 类型不一定都是 immutable 类型。  关于 hashable 可参考：https://docs.python.org/3.5/glossary.html#term-hashable 关于 immutable 可参考：https://docs.python.org/3.5/glossary.html#term-immutable  参考资料     [Sets] : https://docs.python.org/3.5/tutorial/datastructures.html#sets   [Dictionaries] : https://docs.python.org/3.5/tutorial/datastructures.html#dictionaries   [Set Types — set, frozenset] : https://docs.python.org/3.5/library/stdtypes.html#set-types-set-frozenset   [Mapping Types — dict] : https://docs.python.org/3.5/library/stdtypes.html#mapping-types-dict  "
  },
  
  {
    "title": "Python 入门 - 5 - 列表与元组",
    "url": "/posts/python-tutorial-5-list-and-tuple/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-07-15 15:16:00 +0800",
    "content": "序列（Sequence）  在前面已经介绍过的 字符串(str)，以及接下来要学习的 列表(list) 和 元组(tuple) 都属于 序列(Sequence) 类型。 序列又分为 可变序列(mutable) 和 不可变序列(immutable)，可变指的是可修改序列的元素，列表属于可变序列，字符串和元组都属于不可变序列。  ## 列表使用中括号表示 &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; type(nums) &lt;class 'list'&gt; &gt;&gt;&gt; nums[1] = 0  # 列表是可变序列 &gt;&gt;&gt; nums [1, 0, 3]  ## 元组使用圆括号表示 &gt;&gt;&gt; seqs = (4, 5, 6) &gt;&gt;&gt; type(seqs) &lt;class 'tuple'&gt; &gt;&gt;&gt; seqs[1] = 0  # 元组是不可变序列 Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignment &gt;&gt;&gt; seqs (4, 5, 6)   序列操作  序列类型支持的一些通用操作（即可变和不可变序列均支持）如下表：                 Operation       Result                       x in s       如果 s 中的某项等于 x 则结果为 True，否则为 False                 x not in s       如果 s 中的某项等于 x 则结果为 False，否则为 True                 s + t       s 与 t 相拼接                 s * n 或 n * s       相当于 s 与自身进行 n 次拼接                 s[i]       s 的第 i 项，起始为 0                 s[i:j]       s 从 i 到 j 的切片                 s[i:j:k]       s 从 i 到 j 步长为 k 的切片                 len(s)       s 的长度                 min(s)       s 的最小项                 max(s)       s 的最大项                 s.index(x[, i[, j]])       x 在 s 中首次出现项的索引号（索引号在 i 或其后且在 j 之前）                 s.count(x)       x 在 s 中出现的总次数           下面对以上操作进行示例演示：          x in s        &gt;&gt;&gt; 1 in [1, 2, 3]   True   &gt;&gt;&gt; 4 in [1, 2, 3]   False                x not in s        &gt;&gt;&gt; 4 not in (1, 2, 3)   True   &gt;&gt;&gt; 'a' not in 'abc'   False                s + t        &gt;&gt;&gt; [1, 2] + [3, 4]   [1, 2, 3, 4]   &gt;&gt;&gt; (5, 6) + (7, 8)   (5, 6, 7, 8)                s * n 或 n * s        &gt;&gt;&gt; [1, 2] * 2   [1, 2, 1, 2]   &gt;&gt;&gt; 3 * 'w'   'www'                s[i]        &gt;&gt;&gt; [1, 2, 3][0]   1   &gt;&gt;&gt; 'abc'[-1]   'c'                s[i:j]        &gt;&gt;&gt; [1, 2, 3][0:2]   [1, 2]   &gt;&gt;&gt; [1, 2, 3][:2]  # i 可以省略，默认值为 0   [1, 2]   &gt;&gt;&gt; [1, 2, 3][1:]  # j 也可以省略，默认值为 len(s)   [2, 3]   &gt;&gt;&gt; [1, 2, 3][:]  # i 和 j 同时省略则相当于对 s 进行了一个拷贝   [1, 2, 3]   &gt;&gt;&gt; [1, 2, 3][2:1]  # 如果 j &lt;= i，则返回一个空列表   []   &gt;&gt;&gt; [1, 2, 3][1:-1]  # i 和 j 也可以是负数，如果是负数则会被转换为 len(s) + i/j   [2]   &gt;&gt;&gt; [1, 2, 3][1:2]  # [1:-1] 就相当于 [1:len(s)+(-1)] = [1:3-1] = [1:2]   [2]   &gt;&gt;&gt; [1, 2, 3][1:5]  # 如果 i 或 j 大于 len(s)，则被转换为 len(s)   [2, 3]                s[i:j:k]        &gt;&gt;&gt; [1, 2, 3][0:3:2]  # 设定步长 k 为 2，默认为 1   [1, 3]   &gt;&gt;&gt; [1, 2, 3][2:0:-1]  # 相当于取 2, 2-1, 2+n*(-1), ...   [3, 2]    # k 为负数时 i 或 j 的默认值会倒转   # k 为正数时，i 和 j 的默认值分别为 0, len(s)   # k 为负数时，i 和 j 的默认值分别为 len(s)-1, 0，且包含第 0 个元素   &gt;&gt;&gt; [1, 2, 3][::-1]     [3, 2, 1]    # k 不能为 0   &gt;&gt;&gt; [1, 2, 3][::0]   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   ValueError: slice step cannot be zero                len(s)        &gt;&gt;&gt; len([1, 2, 3])   3   &gt;&gt;&gt; len('abc')   3                min(s)        &gt;&gt;&gt; min([1, 2, 3])   1   &gt;&gt;&gt; min('abc')   'a'   &gt;&gt;&gt; min([1, 2, 'c'])  # 序列中的元素必须时相同类型的   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   TypeError: unorderable types: str() &lt; int()                max(s)        &gt;&gt;&gt; max([1, 2, 3])   3   &gt;&gt;&gt; max('abc')   'c'   &gt;&gt;&gt; max((1, 2, 'c'))  # 序列中的元素必须时相同类型的   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   TypeError: unorderable types: str() &gt; int()                s.index(x[, i[, j]])        &gt;&gt;&gt; [1, 2, 3].index(1)   0   &gt;&gt;&gt; [1, 2, 3].index(4)  # 未查找到元素报 ValueError   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   ValueError: 4 is not in list                s.count(x)        &gt;&gt;&gt; [1, 2, 1].count(1)   2   &gt;&gt;&gt; [1, 2, 1].count(3)   0           列表（list）  列表属于可变序列（mutable Sequence），列表定义除了用 中括号([]) 外，还可以使用内置函数 list() 把其他序列类型转换为列表：  &gt;&gt;&gt; list('abc')  # 把字符串转换为列表 ['a', 'b', 'c'] &gt;&gt;&gt; list((1, 2, 3))  # 把元组转换为列表 [1, 2, 3]   列表操作  列表除了支持序列类型的通用操作外，还支持以下这些 可变序列独有的操作：                 Operation       Result                       s[i] = x       将 s 的第 i 项替换为 x                 s[i:j] = t       将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容                 del s[i:j]       等同于 s[i:j] = []                 s[i:j:k] = t       将 s[i:j:k] 的元素替换为 t 的元素                 del s[i:j:k]       从列表中移除 s[i:j:k] 的元素                 s.append(x)       将 x 添加到序列的末尾 (等同于 s[len(s):len(s)] = [x])                 s.clear()       从 s 中移除所有项 (等同于 del s[:])                 s.copy()       创建 s 的浅拷贝 (等同于 s[:])                 s.extend(t) 或 s += t       用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t)                 s *= n       使用 s 的内容重复 n 次来对其进行更新                 s.insert(i, x)       在由 i 给出的索引位置将 x 插入 s (等同于 s[i:i] = [x])                 s.pop([i])       提取在 i 位置上的项，并将其从 s 中移除                 s.remove(x)       删除 s 中第一个等于 x 的项目。                 s.reverse()       就地将列表中的元素逆序。           下面对以上操作进行示例演示：          s[i] = x        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums[1] = 0   &gt;&gt;&gt; nums   [1, 0, 3]                s[i:j] = t        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums[1:3] = [0, 0]  # 把第 1 到 3-1 范围的元素替换为 [0, 0]   &gt;&gt;&gt; nums   [1, 0, 0]   &gt;&gt;&gt; nums[1:3] = []  # 把第 1 到 3-1 范围的元素删除   &gt;&gt;&gt; nums   [1]   &gt;&gt;&gt; nums[:] = []  # 清空整个列表   &gt;&gt;&gt; nums   []                del s[i:j]        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; del nums[1:3]   &gt;&gt;&gt; nums   [1]                s[i:j:k] = t        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums[0:3:2] = [5, 6]  # 把第 0, 0+2 两个元素分别替换为 [5, 6] 中的元素   &gt;&gt;&gt; nums   [5, 2, 6]   &gt;&gt;&gt; nums[0:3:2] = [5]  # t 的元素个数必须和 [i:j:k] 切割出的元素个数相等   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   ValueError: attempt to assign sequence of size 1 to extended slice of size 2                del s[i:j:k]        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; del nums[0:3:2]   &gt;&gt;&gt; nums   [2]                s.append(x)        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums.append(4)   &gt;&gt;&gt; nums   [1, 2, 3, 4]                s.clear()        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums.clear()   &gt;&gt;&gt; nums   []                s.copy()        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums_copy = nums.copy()   &gt;&gt;&gt; nums_copy   [1, 2, 3]                s.extend(t) 或 s += t        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums.extend([4, 5])   &gt;&gt;&gt; nums   [1, 2, 3, 4, 5]   &gt;&gt;&gt; nums += [6, 7]   &gt;&gt;&gt; nums   [1, 2, 3, 4, 5, 6, 7]                s *= n        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums *= 2   &gt;&gt;&gt; nums   [1, 2, 3, 1, 2, 3]   &gt;&gt;&gt; nums *= -1  # 如果 n 小于等于 0，则 s 被清空   &gt;&gt;&gt; nums   []                s.insert(i, x)        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums.insert(1, 4)   &gt;&gt;&gt; nums   [1, 4, 2, 3]   &gt;&gt;&gt; nums[1:1] = [5]  # 等同于 nums.insert(1, 5)   &gt;&gt;&gt; nums   [1, 5, 4, 2, 3]                s.pop([i])        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums.pop()  # 参数 i 默认为 -1   3   &gt;&gt;&gt; nums   [1, 2]   &gt;&gt;&gt; nums.pop(0)  # 也可以 pop 指定位置的元素   1   &gt;&gt;&gt; nums   [2]                s.remove(x)        &gt;&gt;&gt; chars = ['a', 'b', 'c']   &gt;&gt;&gt; chars.remove('b')   &gt;&gt;&gt; chars   ['a', 'c']   &gt;&gt;&gt; chars.remove('f')  # 如果 s 中不存在值为 x 的元素，则报 ValueError   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   ValueError: list.remove(x): x not in list                s.reverse()        &gt;&gt;&gt; nums = [1, 2, 3]   &gt;&gt;&gt; nums.reverse()   &gt;&gt;&gt; nums   [3, 2, 1]           列表排序  列表除了支持 序列通用操作 和 可变序列操作 外，列表还实现了一个单独的方法 sort ：          list.sort(key=None, reverse=False)      sort 是一个就地排序方法，默认升序排序，如果 reverse 参数为 True，则是进行降序排序。   key 可以接受一个函数，对待排序的对象进行预处理后再进行排序。        &gt;&gt;&gt; nums = [2, 3, 1]   &gt;&gt;&gt; nums.sort()   &gt;&gt;&gt; nums   [1, 2, 3]   &gt;&gt;&gt; nums.sort(reverse=True)  # 降序排序   &gt;&gt;&gt; nums   [3, 2, 1]    &gt;&gt;&gt; ids = ['lily-02', 'tom-01', 'jack-03']   &gt;&gt;&gt; ids.sort()  # 默认按字母序进行升序排序：j &lt; l &lt; t   &gt;&gt;&gt; ids   ['jack-03', 'lily-02', 'tom-01']   # 只取 - 后两位数字进行排序比较：01 &lt; 02 &lt; 03   &gt;&gt;&gt; ids.sort(key=lambda s: s.split('-')[-1])   &gt;&gt;&gt; ids   ['tom-01', 'lily-02', 'jack-03']           列表推导式  列表推导式提供了一种简洁的方式来创建列表，比如需要创建一个 1~10 的平方数的列表，只需要像这样一行代码即可完成：  &gt;&gt;&gt; [x**2 for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]   列表推导式也同时支持在 for 后面添加 if 语句：  &gt;&gt;&gt; [x for x in range(1, 11) if x%2 == 0]  # 1~10 的偶数 [2, 4, 6, 8, 10]   列表推导式也支持嵌套：  &gt;&gt;&gt; [(x, y) for x in [1, 2] for y in [3, 4]] [(1, 3), (1, 4), (2, 3), (2, 4)]  ## 上面的推导式与以下嵌套循环作用相同 &gt;&gt;&gt; combs = [] &gt;&gt;&gt; for x in [1, 2]: ...     for y in [3, 4]: ...         combs.append((x, y)) ... &gt;&gt;&gt; combs [(1, 3), (1, 4), (2, 3), (2, 4)]   浅拷贝与深拷贝  列表支持嵌套列表或嵌套其他可变对象，对于列表自带的 copy 方法和切片式拷贝，以及 *(repeation)，都只是一个 浅拷贝，下面举例对浅拷贝进行说明：  &gt;&gt;&gt; nested_nums = [1, [2, 3], 4] &gt;&gt;&gt; copy_nested_nums = nested_nums.copy()  # 浅拷贝，等同于 nested_nums[:]  ## 修改原始列表中非嵌套元素，拷贝列表不受影响 &gt;&gt;&gt; nested_nums[0] = 9 &gt;&gt;&gt; nested_nums [9, [2, 3], 4] &gt;&gt;&gt; copy_nested_nums [1, [2, 3], 4]  ## 修改原始列表中嵌套列表的元素，拷贝列表受影响 &gt;&gt;&gt; nested_nums[1][0] = 9 &gt;&gt;&gt; nested_nums [9, [9, 3], 4] &gt;&gt;&gt; copy_nested_nums [1, [9, 3], 4]   如果想要避免上面的浅拷贝的情况，可以使用 copy.deepcopy 函数进行深拷贝：  &gt;&gt;&gt; nested_nums = [1, [2, 3], 4] &gt;&gt;&gt; import copy &gt;&gt;&gt; copy_nested_nums = copy.deepcopy(nested_nums) &gt;&gt;&gt; nested_nums[1][0] = 9 &gt;&gt;&gt; nested_nums [1, [9, 3], 4] &gt;&gt;&gt; copy_nested_nums  # 深拷贝的列表不受影响 [1, [2, 3], 4]   range  range 是一个 内置类型，可以用来创建一个 不可变序列(immutable)，定义如下：  class range(stop) class range(start, stop[, step])  # 在 start 到 stop 范围内（不包含 stop），以步长为 step，产生一个序列。   start, stop, step 均为 int 类型，如果只传入一个参数，这个参数会被当作 stop ：  &gt;&gt;&gt; [i for i in range(3)] [0, 1, 2]   也可以传入 2 个参数，则分别会被当作 start 和 stop ：  &gt;&gt;&gt; [i for i in range(1, 3)] [1, 2]   还可以设定步长（step），步长默认值是 1 ：  &gt;&gt;&gt; [i for i in range(1, 10, 2)] [1, 3, 5, 7, 9]   如果步长 step 为负数，那么应该满足 start &gt;= stop ：  &gt;&gt;&gt; [i for i in range(3, 0, -1)] [3, 2, 1]   和 list 相比，range 类型更节约内存，因为 list 占用内存大小是根据元素的多少而变化，而 range 生成的实例只是记录了一下计算方法，不管范围多大，都占用固定大小的内存，在每一次 for 循环时才实时计算出当前的元素内容：  &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getsizeof(nums) 88 &gt;&gt;&gt; r = range(1, 4) &gt;&gt;&gt; sys.getsizeof(r) 48 &gt;&gt;&gt; nums = [1, 2, 3, 4]  &gt;&gt;&gt; sys.getsizeof(nums)  # 增加一个元素后，大小也增加了 8 96 &gt;&gt;&gt; r = range(1, 5) &gt;&gt;&gt; r range(1, 5) &gt;&gt;&gt; sys.getsizeof(r)  # 扩大范围后，占用大小仍然不变 48   元组（tuple）  元组和列表类似，都是序列，不同的是元组是 不可变序列(immutable Sequence)，元组的定义使用 圆括号，也可以使用内置关键字 tuple，将其他序列转换为元组：  &gt;&gt;&gt; t = (1, 2, 3) &gt;&gt;&gt; t (1, 2, 3) &gt;&gt;&gt; t = 1, 2, 3  # 如果元素个数超过 1 个，也可以不使用圆括号 &gt;&gt;&gt; t (1, 2, 3) ## 只有 1 个元素的元组需要用圆括号括起来，并且在末尾添加一个逗号(,) ## 这样做是为了和数学符号的圆括号进行区分 &gt;&gt;&gt; t = (1,)   &gt;&gt;&gt; t (1,) &gt;&gt;&gt; tuple([1, 2, 3])  # 把列表转换为元组 (1, 2, 3)   元组作为不可变序列，一旦定义后，其中的元素不能被修改：  &gt;&gt;&gt; t = (1, 2, 3) &gt;&gt;&gt; t[0] = 5 Traceback (most recent call last):   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignment   但是元组里的可变类型的内容的是可以被修改的：  &gt;&gt;&gt; t = (1, [2, 3], 4) &gt;&gt;&gt; t[1][0] = 3 &gt;&gt;&gt; t (1, [3, 3], 4)   参考资料     [More on Lists] : https://docs.python.org/3.5/tutorial/datastructures.html#more-on-lists   [Tuples and Sequences] : https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences   [Sequence Types — list, tuple, range] : https://docs.python.org/3.5/library/stdtypes.html#sequence-types-list-tuple-range  "
  },
  
  {
    "title": "Python 入门 - 4 - 字符串",
    "url": "/posts/python-tutorial-4-string/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-07-10 17:39:07 +0800",
    "content": "字符串方法  字符串(str) 在 Python 中是一个 对象(object)，并且包含很多的 方法(method)，这些方法可以给我们操作字符串带来很大的方便，下面列举一些常用的方法及其使用示例：          str.capitalize()      把字符串的首字母变成大写。        &gt;&gt;&gt; 'hello'.capitalize()   'Hello'                str.lower()      把字符串转换为小写。        &gt;&gt;&gt; 'Hello'.lower()   'hello'                str.upper()      把字符串转换为大写。        &gt;&gt;&gt; 'Hello'.upper()   'HELLO'                str.center(width[, fillchar])      返回一个长度为 width，原始字符串居中，两边多余长度使用 fillchar 进行填充的新字符串。        &gt;&gt;&gt; 'abc'.center(10, '=')   '===abc===='   &gt;&gt;&gt; 'abc'.center(10)  # fillchar 默认为空格   '   abc    '   &gt;&gt;&gt; 'abc'.center(3)  # 如果 width 小于等于字符串长度，则返回原始字符串   'abc'                str.count(sub[, start[, end]])      在字符串的 start 到 end 范围内查找子字符串 sub 出现的次数。   start 默认为0，end 默认为字符串长度，即默认查找整个字符串，这2个参数在其他方法中类似，不再重复说明。        &gt;&gt;&gt; 'abcad'.count('a')   2   &gt;&gt;&gt; 'abcad'.count('a', 0, 3)   1   &gt;&gt;&gt; 'abcad'.count('a', 0, 4)   2                str.encode(encoding=”utf-8”, errors=”strict”)      对字符串按照 encoding 进行编码。        &gt;&gt;&gt; '中文'.encode()   b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'                str.startswith(prefix[, start[, end]])      判断字符串在 start 到 end 范围内是否是以 prefix 开头，是返回 True，否则返回 False。   prefix 可以是多个，以 tuple 格式传入。   str.endswith 方法与此方法类似。        &gt;&gt;&gt; 'abc'.startswith('a')   True   &gt;&gt;&gt; 'abc'.startswith('b')   False   &gt;&gt;&gt; 'abc'.startswith(('a', 'b'))  # 是否以 'a' 或 'b' 开头   True                str.find(sub[, start[, end]])      在字符串的 start 到 end 范围内查找子字符串 sub，如果查到到则返回 sub 出现的最小起始索引号，否则返回 -1 。        &gt;&gt;&gt; 'abcdbf'.find('b')   1   &gt;&gt;&gt; 'abcdbf'.find('x')   -1           如果只需要判断是否包含子字符串，可以使用 in 关键字进行判断，无需使用 find 方法。        &gt;&gt;&gt; 'b' in 'abc'   True   &gt;&gt;&gt; 'd' in 'abc'   False                str.index(sub[, start[, end]])      与 str.find 方法类似，不同的是如果没有查找到子字符串 sub ，会抛出 ValueError 异常。        &gt;&gt;&gt; 'abcdbf'.index('b')   1   &gt;&gt;&gt; 'abcdbf'.index('x')   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   ValueError: substring not found   &gt;&gt;&gt;                str.format(*args, **kwargs)      格式化字符串，此方法在下面会进行详细讲解，这里只演示一个简单示例。        &gt;&gt;&gt; \"The sum of 1 + 2 is {0}\".format(1+2)   'The sum of 1 + 2 is 3'                str.join(iterable)      把 iterable 中的字符串元素用 str 进行连接。   iterable 可以是 list、tuple 等可迭代对象，但是里边的元素必须是 str 类型。        &gt;&gt;&gt; '_'.join(['a', 'b', 'c'])   'a_b_c'   &gt;&gt;&gt; '_'.join([1, 2, 3])  # 不能是非 str 类型   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   TypeError: sequence item 0: expected str instance, int found   &gt;&gt;&gt;                str.strip([chars])      去除字符串首尾的在 chars 中出现的字符。   如果 chars 不指定，则默认去除空白字符。        &gt;&gt;&gt; '   spacious   '.strip()   'spacious'   &gt;&gt;&gt; 'www.example.com'.strip('cmowz.')   'example'           str.lstrip([chars]) 方法则只去除左边(首部)的字符。        &gt;&gt;&gt; '   spacious   '.lstrip()   'spacious   '   &gt;&gt;&gt; 'www.example.com'.lstrip('cmowz.')   'example.com'           str.rstrip([chars]) 与 lstrip 类似，只是去除右边(尾部)字符。           str.split(sep=None, maxsplit=-1)      用分隔符 sep 对字符串进行最多 maxsplit 次切割，返回切割后的 list 。   sep 默认为空白字符，即空格、制表符等。   maxsplit 如果不指定或指定为 -1，则会进行最大次数的切割。        # 指定 sep   &gt;&gt;&gt; '1,2,3'.split(',')   ['1', '2', '3']   &gt;&gt;&gt; '1,2,3'.split(',', maxsplit=1)   ['1', '2,3']   &gt;&gt;&gt; '1,2,,3,'.split(',')   ['1', '2', '', '3', '']    # 不指定 sep   &gt;&gt;&gt; '1 2 3'.split()   ['1', '2', '3']   &gt;&gt;&gt; '1 2 3'.split(maxsplit=1)   ['1', '2 3']   &gt;&gt;&gt; '   1   2   3   '.split()   ['1', '2', '3']                str.splitlines([keepends])      把字符串按照行边界符(line boundaries)切割成多行，并以 list 形式返回。   如果 keepends 为True，则返回的每行末尾仍然包含换行符，keepends 默认为False。   符合行边界符(line boundaries)定义的字符如下：                                 Representation           Description                                           \\n           Line Feed                             \\r           Carriage Return                             \\r\\n           Carriage Return + Line Feed                             \\v or \\x0b           Line Tabulation                             \\f or \\x0c           Form Feed                             \\x1c           File Separator                             \\x1d           Group Separator                             \\x1e           Record Separator                             \\x85           Next Line (C1 Control Code)                             \\u2028           Line Separator                             \\u2029           Paragraph Separator                             &gt;&gt;&gt; 'first line \\nsecond line \\r\\nthird line'.splitlines()   ['first line ', 'second line ', 'third line']   &gt;&gt;&gt; 'first line \\nsecond line \\r\\nthird line'.splitlines(True)   ['first line \\n', 'second line \\r\\n', 'third line']           使用 % 格式化字符串  Python 中使用 % 格式化字符串的格式是 format % values ：  &gt;&gt;&gt; 'I am %s' % 'python' 'I am python' &gt;&gt;&gt;   如果 values 是多个值，那么需要使用表示 tuple 的圆括号括起来：  &gt;&gt;&gt; 'This is %s, that is %s' % ('python', 'java') 'This is python, that is java' &gt;&gt;&gt;   values 也可以是字典，如果是字典那么 format 里需要用 映射键(mapping key) 的方式取值：  &gt;&gt;&gt; 'I am %(lang)s' % {'lang': 'python'} 'I am python'   以上示例中的 %s 里的 s 表示转换类型为 str，Python 也支持很多其他类型，以下列出常见的几种：          d/i : 有符号的十进制整数        &gt;&gt;&gt; '1 + 1 = %d' % 2   '1 + 1 = 2'   &gt;&gt;&gt; '1 + 1 = %i' % 2   '1 + 1 = 2'                o : 有符号的八进制整数        &gt;&gt;&gt; 'decimal 9 convert to octal is %o' % 9   'decimal 9 convert to octal is 11'                x/X : 有符号16进制数        &gt;&gt;&gt; 'decimal 17 convert to hex is %x' % 17   'decimal 17 convert to hex is 11'                f/F : 浮点数十进制格式        &gt;&gt;&gt; '%f' % 3.14   '3.140000'                e/E : 浮点数指数格式        &gt;&gt;&gt; '%e' % 31.4   '3.140000e+01'                c : 单个字符        &gt;&gt;&gt; '%c' % 97   'a'   &gt;&gt;&gt; '%c' % 'a'   'a'                r : 字符串（使用 repr() 转换任何 Python 对象）        &gt;&gt;&gt; 'hello %r' % 'world'   \"hello 'world'\"                s : 字符串（使用 str() 转换任何 Python 对象）        &gt;&gt;&gt; 'hello %s' % 'world'   'hello world'                a : 字符串（使用 ascii() 转换任何 Python 对象）        &gt;&gt;&gt; 'hello %a' % 'world'   \"hello 'world'\"           如果需要原样表示 % ，只需双写 % 即可：  &gt;&gt;&gt; '3 %% 2 = %d' % 1 '3 % 2 = 1'   可以指定占位宽度，如果实际内容小于宽度，默认右对齐，左边补空格：  &gt;&gt;&gt; '%3s' % 'a' '  a' &gt;&gt;&gt; '%3d' % 10 ' 10'   对于浮点数，可以使用 .precision 的格式指定指定精度：  &gt;&gt;&gt; '%.3f' % 3.1415 '3.142' &gt;&gt;&gt; '%.3f' % 3.14 '3.140'   可以使用 转换标志(Conversion flags) 对转换行为进行一些控制，支持的转换标志如下：          ’#’ : 替代模式(alternate form)        # 八进制和十进制转换在替代模式下会显示 0o 和 0x/0X 前缀   &gt;&gt;&gt; '%o' % 9   '11'   &gt;&gt;&gt; '%#o' % 9   '0o11'   &gt;&gt;&gt; '%#x' % 17   '0x11'   &gt;&gt;&gt; '%#X' % 17   '0X11'    # 浮点数转换在替代模式下会始终保留一个小数点在末尾，即使精度为0的整数   &gt;&gt;&gt; '%.0f' % 3.0   '3'   &gt;&gt;&gt; '%#.0f' % 3.0   '3.'                ‘0’ : 数值类型转换时多余位置补0        &gt;&gt;&gt; '%03d' % 1   '001'                ’-‘ : 转换值将靠左对齐（会覆盖 ‘0’ 转换）        &gt;&gt;&gt; '%-3d' % 1   '1  '   &gt;&gt;&gt; '%0-3d' % 1  # '-' 转换会覆盖 '0' 转换   '1  '                ’ ‘ : (空格) 正数前面保留一个空格        &gt;&gt;&gt; '% d' % 1   ' 1'   &gt;&gt;&gt; '% d' % -1   '-1'                ’+’ : 数值类型前面显示符号位（会覆盖 “空格” 转换）        &gt;&gt;&gt; '%+d' % 1   '+1'   &gt;&gt;&gt; '%+d' % -1   '-1'           以上这些符号组合使用时需要遵守以下规则和顺序：  %[M][F][W][P][L]T  % : 固定格式。 M : 映射键(mapping key)（可选），由加圆括号的字符序列组成 (例如 (somename))，values 是字典的情况下使用。 F : 转换标志(conversion flags)（可选），用于影响某些转换类型的结果。 W : 最小字段宽度(width)（可选）。 如果指定为 '*' (星号)，则实际宽度会从 values 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。 P : 精度(precision)（可选），以在 '.' (点号) 之后加精度值的形式给出。 如果指定为 '*' (星号)，则实际精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。 L : 长度修饰符(length modifier)（可选）。 T : 转换类型(conversion type)。  注：长度修饰符（h, l 或 L）可以使用，但是会被忽略，因为在 Python3 中只有长整型（L），没有短整型（h），所有 %ld 和 %d 是一样的。   下面是一些组合使用的示例：  ## 十进制浮点数转换类型(f)，带符号位(+)，左对齐(-)，最小宽度5(5)，精度1位(.1) &gt;&gt;&gt; '%+-5.1f' % 3.14 '+3.1 ' ## 十进制整数转换类型(d)，带符号位(+)，最小宽度4(4)，不足位补0(0) &gt;&gt;&gt; '%+04d' % 16 '+016' ## 字符串转换类型(s)，左对齐(-)，最小宽度6(6)，精度2(.2) &gt;&gt;&gt; '%-6.2s' % 'Python' 'Py    '   使用 str.format 格式化字符串  从 Python3 开始官方推荐使用字符串自带的 format 方法对字符串进行格式化，该方法能够完全兼容 % 的形式且更强大，比如像下面这样：  &gt;&gt;&gt; 'hello {}!'.format('world') 'hello world!'   format 的语法定义如下：  replacement_field ::=  \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name        ::=  arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name          ::=  [identifier | integer] attribute_name    ::=  identifier element_index     ::=  integer | index_string index_string      ::=  &lt;any source character except \"]\"&gt; + conversion        ::=  \"r\" | \"s\" | \"a\" format_spec       ::=  &lt;described in the next section&gt;   下面通过举例的方式逐一对 format 语法定义中的字段进行解释：          field_name/arg_name : 参数名（可选），可以是位置（integer）或名称（identifier）。        # arg_name 为空则按顺序依次引用后面的位置参数   &gt;&gt;&gt; '{} {} {}'.format('first', 'second', 'third')   'first second third'    # arg_name 为位置（integer），则按照索引号引用后面的位置参数   &gt;&gt;&gt; '{0} {1} {2}'.format('first', 'second', 'third')   'first second third'   &gt;&gt;&gt; '{2} {1} {0}'.format('first', 'second', 'third')   'third second first'   &gt;&gt;&gt; '{0} {0} {1}'.format('first', 'second')   'first first second'    # 但是空和位置引用不能混用   &gt;&gt;&gt; '{} {1} {2}'.format('first', 'second', 'third')   Traceback (most recent call last):     File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;   ValueError: cannot switch from automatic field numbering to manual field specification    # arg_name 为名称（identifier），则按照名称引用后面的关键字参数   &gt;&gt;&gt; '{f1} {f2} {f3}'.format(f1='first', f2='second', f3='third')   'first second third'    # 空引用和名称引用混用，或者数字引用和名称引用混用是可以的   &gt;&gt;&gt; '{} {f2} {}'.format('first', 'third', f2='second')   'first second third'   &gt;&gt;&gt; '{0} {f2} {1}'.format('first', 'third', f2='second')   'first second third'                field_name/arg_name.attribute_name : 属性名（可选），是对参数的属性进行引用。        &gt;&gt;&gt; c = 3-5j   &gt;&gt;&gt; 'realpart = {0.real}, imagpart = {0.imag}'.format(c)   'realpart = 3.0, imagpart = -5.0'   &gt;&gt;&gt; 'realpart = {cnum.real}, imagpart = {cnum.imag}'.format(cnum=c)   'realpart = 3.0, imagpart = -5.0'                field_name/arg_name[element_index] : 元素索引（可选），可以是数字或名称，通过索引的方式引用参数的元素。        # 数字索引   &gt;&gt;&gt; arr = [1, 2]   &gt;&gt;&gt; 'e1 = {0[0]}, e2 = {0[1]}'.format(arr)   'e1 = 1, e2 = 2'    # 名称索引   &gt;&gt;&gt; d = {'id': 1, 'name': 'tom'}   &gt;&gt;&gt; 'id = {0[id]}, name = {0[name]}'.format(d)   'id = 1, name = tom'                conversion : 转换标志，’!s’ 会对值调用 str()，’!r’ 调用 repr() 而 ‘!a’ 则调用 ascii() 。        &gt;&gt;&gt; 'hello {0!r}'.format('world')   \"hello 'world'\"   &gt;&gt;&gt; 'hello {0!s}'.format('world')   'hello world'   &gt;&gt;&gt; 'hello {0!a}'.format('world')   \"hello 'world'\"           format_spec 的语法定义如下：  format_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type] fill        ::=  &lt;any character&gt; align       ::=  \"&lt;\" | \"&gt;\" | \"=\" | \"^\" sign        ::=  \"+\" | \"-\" | \" \" width       ::=  integer precision   ::=  integer type        ::=  \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\"   下面通过举例的方式逐一对 format_spec 语法定义中的字段进行解释：          width : 最小宽度        # 指定最小宽度为 10 位   &gt;&gt;&gt; '{:10}'.format('Python')   'Python    '                align : 对齐方式，支持 ‘&lt;’, ‘&gt;’, ‘^’ 三种方式。        &gt;&gt;&gt; '{:&lt;30}'.format('left aligned')  # 最小宽度 30，并且左对齐   'left aligned                  '   &gt;&gt;&gt; '{:&gt;30}'.format('right aligned')  # 最小宽度 30，并且又对齐   '                 right aligned'   &gt;&gt;&gt; '{:^30}'.format('centered')  # 最小宽度 30，并且居中对齐   '           centered           '                fill : 填充符        # 最小宽度 30，并且居中对齐，多余部分使用 * 填充   &gt;&gt;&gt; '{:*^30}'.format('centered')   '***********centered***********'                sign : 符号位，仅对数学类型有效，支持 ‘+’, ‘-‘, ‘ ‘ 三种类型。        &gt;&gt;&gt; '{:+}, {:+}'.format(1, -1)  # 始终保留符号位   '+1, -1'   &gt;&gt;&gt; '{:-}, {:-}'.format(1, -1)  # 负数才有符号位   '1, -1'   &gt;&gt;&gt; '{: }, {: }'.format(1, -1)  # 正数前保留一个空格   ' 1, -1'                precision : 精度        &gt;&gt;&gt; '{:.2}'.format(3.14)   '3.1'   &gt;&gt;&gt; '{:.2}'.format('Python')  # 作用在字符串上则会按照进行截断   'Py'                , : 千分位        &gt;&gt;&gt; '{:,}'.format(12345678)   '12,345,678'                type : 转换类型      转换类型大部分与 % 格式化的方式相同，下面只对不一样的类型进行示例说明：        &gt;&gt;&gt; '{:b}'.format(7)  # 二进制类型   '111'   &gt;&gt;&gt; '{:.2%}'.format(23/89)  # 百分比类型   '25.84%'                #/0 : # 和 0 的作用与 % 格式化的方式相同      参考资料     [Strings] : https://docs.python.org/3.5/tutorial/introduction.html#strings   [String Methods] : https://docs.python.org/3.5/library/stdtypes.html#string-methods   [Format String Syntax] : https://docs.python.org/3.5/library/string.html#formatstrings   [printf-style String Formatting] : https://docs.python.org/3.5/library/stdtypes.html#old-string-formatting  "
  },
  
  {
    "title": "Python 入门 - 3 - 数据类型",
    "url": "/posts/python-tutorial-3-variable-type/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-06-12 17:52:02 +0800",
    "content": "数字（int, float）  Python 中的整数和数学上的整数一样，但是跟 Python2 和 C 语言相比不同的是，Python3 中的整数没有 短整型(int) 和 长整型(long) 的区别，即 int 直接相当于 Python2 和 C 语言中的 长整型(long) 类型。  Python 中的 浮点数(float) 则相当于数学上的小数。叫做浮点数是由于在计算机中小数的表示方法有 浮点表示 和 定点表示 的区别，浮点表示即小数点的位置可变，比如 1.23 也可以表示为 0.123e1。关于浮点数可以参考《浮点数的二进制表示》。  四则运算：  ## 加减乘除 &gt;&gt;&gt; 2 + 2 4 &gt;&gt;&gt; 50 - 5*6 20 &gt;&gt;&gt; (50 - 5*6) / 4  # 除法运算结果始终为浮点数 5.0   取余和幂运算：  &gt;&gt;&gt; 17 % 3  # 取余 2 &gt;&gt;&gt; 2 ** 3  # 幂运算 8 &gt;&gt;&gt; pow(2, 3)  # 也可以适用内置函数 pow 进行幂运算 8   地板除法（floor division）：  &gt;&gt;&gt; 11 // 4  # 地板除运算符(//)的结果将会向负无穷的方向取整 2 &gt;&gt;&gt; -11 // 4  # -2.75 向负无穷的方向取整结果为 -3 -3  ## math.floor 方法和 // 运算符结果一样 &gt;&gt;&gt; import math &gt;&gt;&gt; math.floor(2.75) 2 &gt;&gt;&gt; math.floor(-2.75) -3  ## math.ceil 则是向正无穷方向取整 &gt;&gt;&gt; math.ceil(2.75) 3 &gt;&gt;&gt; math.ceil(-2.75) -2   int 和 float 混合运算时的规则：在数值范围表示上 int &lt; float，所以 int 相对于 float 来说是窄类型（narrower），float 相对 int 来说是宽类型，在混合运算或比较时，窄类型会转换为宽类型进行计算，所以最终结果也是宽类型：  ## 窄类型 int 转换为宽类型 float 进行计算 &gt;&gt;&gt; 2 + 2.0 4.0 &gt;&gt;&gt; 2.0 - 1 1.0 &gt;&gt;&gt; 2.0 * 3.0 6.0 &gt;&gt;&gt; 2 ** 3.0 8.0 &gt;&gt;&gt; 17 % 3.0 2.0  ## 窄类型 int 转换为宽类型 float 进行比较 &gt;&gt;&gt; 1 == 1.0 True &gt;&gt;&gt; [1, 2] == [1.0, 2.0] True   字符串（str）  字符串的 单引号 表示形式：  &gt;&gt;&gt; print('I am a string') I am a string &gt;&gt;&gt; print('I\\'m a string')  # 单引号中如果要包含单引号，需要用反斜杠(\\)转义 I'm a string &gt;&gt;&gt; print('I am a \"string\"')  # 单引号中可以包含双引号(\") I am a \"string\"   字符串的 双引号 表示形式：  &gt;&gt;&gt; print(\"I am a string\") I am a string &gt;&gt;&gt; print(\"I am a \\\"string\\\"\")  # 双引号中如果要包含双引号，需要用反斜杠(\\)转义 I am a \"string\" &gt;&gt;&gt; print(\"I'm a string\")  # 双引号中可以包含单引号(') I'm a string   字符串的 三引号 表示形式：  &gt;&gt;&gt; print('''I am a string''')  # 三个单引号形式 I am a string &gt;&gt;&gt; print(\"\"\"I am a string\"\"\")  # 三个双引号形式 I am a string &gt;&gt;&gt; print('''I'm a \"string\"''')  # 三引号中既可以包含单引号，也可以包含双引号 I'm a \"string\"  ## 三引号中可以包含多行 print('''I am first line I am second line''') I am first line I am second line  ## 三引号中可以在行尾添加反斜杠(\\)表示不换行 print('''I am first line, \\ I am still first line''') I am first line, I am still first line   字符串的 raw 表示形式：  &gt;&gt;&gt; print(' first line \\n second line')  # \\n表示换行  first line  second line  ## 添加r前缀的字符串表示把反斜杠(\\)当作普通字符，而不是转义符 &gt;&gt;&gt; print(r' first line \\n still first line')    first line \\n still first line   字符串可以用 + 进行拼接：  &gt;&gt;&gt; print('Py' + 'thon') Python   字符串也可以用 空格 进行拼接：  &gt;&gt;&gt; print('Py' 'thon') Python &gt;&gt;&gt; s = 'thon' &gt;&gt;&gt; print('Py' s)  # 不能用空格连接变量字符串   File \"&lt;stdin&gt;\", line 1     print('Py' s)                ^ SyntaxError: invalid syntax   字符串可以用 * 进行重复：  &gt;&gt;&gt; print('w' * 3) www   字符串可以用列表索引截取：  &gt;&gt;&gt; s = 'Python' &gt;&gt;&gt; s[0] 'P' &gt;&gt;&gt; s[-1] 'n' &gt;&gt;&gt; s[0:2]  # 切片(slice)，切片将在后续章节进一步讲解 'Py'   布尔（bool）  Python 中的布尔值使用 True 和 False 表示(注意区分大小写)，布尔运算符分别为 and、or 和 not ：  ## and 运算符 &gt;&gt;&gt; True and True True &gt;&gt;&gt; True and False False &gt;&gt;&gt; False and False False &gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1 True  ## or 运算符 &gt;&gt;&gt; True or True True &gt;&gt;&gt; True or False True &gt;&gt;&gt; False or False False &gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3 True  ## not 运算符 &gt;&gt;&gt; not True False &gt;&gt;&gt; not False True &gt;&gt;&gt; not 1 &gt; 2 True   Python 中的 bool 类其实是从 int 类继承实现的，True 和 False 分别是 1 和 0 ：  &gt;&gt;&gt; ['a', 'b'][True] 'b' &gt;&gt;&gt; ['a', 'b'][False] 'a'   空（None）  空值(None)在 Python 中是一个特殊值，与 JAVA 中的 null 相同，None 和 0 是不相同的，0 是一个 int类型的，是有值的。  如果一个函数没有 return 语句，那么默认就会返回 None。  参考资料     [Numbers] : https://docs.python.org/3.5/tutorial/introduction.html#numbers   [数据类型和变量] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112  "
  },
  
  {
    "title": "Python 入门 - 2 - 安装和使用",
    "url": "/posts/python-tutorial-2-install-and-usage/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-03-07 20:03:27 +0800",
    "content": "Windows  下载安装包  进入 Python 官网的 windows downloads 页面，以 Python 3.5.1 为例，可以看到除了帮助文件之外一共有 6 个安装包可以下载，操作系统位数分为 32 位(X86)和 64 位(x86-64)，安装包类型分为 embeddable、executable、web-based 三种，所以一共有 2*3 = 6 个安装包可下载。  需要注意的是从 Python 3.5 开始就只支持 Windows Vista 及以上的版本，如果是 Windows XP 则只能选择安装 Python 3.4。如何查看操作系统版本和位数可以参考 微软官方帮助文档。  3 种不同类型的安装包区别如下：    embeddable：嵌入式包，相当于绿色版 Python，短小精干且无需安装，可直接嵌入到其他应用中使用   executable：离线安装包，包含默认安装所需的所有组件，可用于离线安装   web-based：在线安装包，只是一个安装器，在安装过程种需要联网下载安装所需的组件   图形界面安装  下面以 Python 3.5 为例进行说明，双击安装包进入图界面安装：   如果选择 Install Now，会安装到当前用户目录下，也就是说安装后只有当前用户可以使用。 如果选择 Customize installation ，可以选择为所有用户安装，也可以自定义安装路径。  如果同时安装了多个版本，推荐都勾选上 Install launcher for all users，安装好之后可以使用 py 命令指定运行版本，比如同时安装了 3.5 和 3.7，则可以使用 py -3.5 或 py -3.7指定运行版本。更多关于 Python Launcher 的内容可以参考官方文档 Python Launcher for Windows  如果不是多版本并存的系统上，建议都勾选上 Add Python 3.5 to PATH，这样会把 Python 的安装路径自动添加到环境变量 PATH 中，避免在命令行中执行 python 命令时系统不能识别。如果是多版本并存的系统上可以不用勾选，然后都使用 Python Launcher 进行多版本管理。  命令行安装  可能很多同学不知道，Windows 下的 Python 安装包其实也支持命令行的方式安装，这个在用于制作自动安装程序或者批量安装时非常有用。  我们以下载的 64 位的 3.5.1 的安装包为例，下载后的安装包名称为 python-3.5.1-amd64.exe，在命令行(cmd)中切换到安装包所在路径，然后执行 python-3.5.1-amd64.exe /?，可以看到如下图所示的命令行安装帮助：   可以使用 name=value 的方式指定安装参数，比如为所有用户安装 InstallAllUsers=1，还有自动添加安装路径到 PATH 环境变量 PrependPath=1，完整的安装参数请参考官方文档 Installing Without UI。  比如以下安装命令就表示不需要用户干预但是会显示安装过程的自动安装，并且为所有用户安装，并且自动添加安装路径到 PATH 环境变量： python-3.5.1-amd64.exe /passive InstallAllUsers=1 PrependPath=1   Linux  大多数的 Linux 发行版都自带了 Python2，系统自带的 python2 一定不要删除，因为通常会有一些系统自带软件依赖于它，如果要安装 Python3 可以通过下面几种方式。  通过安装源在线安装  如果你的电脑可以连接互联网，或者在一个内部网络上但是有内部安装源，推荐使用这种方式。不同的 Linux 发行版有不同的安装源工具，以 CentOS7 为例，CentOS7 自带的 python 版本是 2.7，CentOS 上的安装源工具是 yum，我们可以通过命令 yum install python3 来安装 Python3，目前 CentOS7 官方 yum 源的 python3 的版本应该是 3.7，安装完成后可通过键入 python3 查看是否安装成功  需要注意的是在 CentOS 上安装好 Python3 后一定不能修改系统默认链接 /usr/bin/python 指向 python3，否则运行 yum 时会得到如下错误：   File \"/usr/bin/yum\", line 30     except KeyboardInterrupt, e:                             ^ SyntaxError: invalid syntax  这是由于 yum 依赖于系统自带的 python2，改成 python3 之后由于语法不兼容，所以会出现错误。所以应该保持链接 /usr/bin/python 始终执行系统自带的 python2。如果在其他 Linux 发行版上也遇到类似问题可以参考这种情况。  使用包管理器离线安装  不同的 Linux 发行版也有不同的包管理方式，安装源在线安装本质上就是自动从源上下载安装包然后使用包管理器进行安装。好处是方便，但是如果电脑不能联网就只能提前下载好安装包，然后使用系统自带的包管理器进行离线安装。  还是以 CentOS7 为例，CentOS 的包管理器是 rpm，比如已经下载好的 rpm 安装包名为 python35-3.5.1-xxx.rpm，那么可以使用命令 rpm -ivh python35-3.5.1-xxx.rpm 进行离线安装。  离线安装包的下载可以通过各 Linux 发行版官网进行下载，也可以通过国内的镜像源网站下载，速度会比国外的快一些，这里列出几个常用的国内源：    清华大学：https://mirrors.tuna.tsinghua.edu.cn/   网易：http://mirrors.163.com/   阿里巴巴：https://developer.aliyun.com/mirror/   使用源码编译安装  Python 官网提供 源码下载，下载解压后可通过 make 三连击 ./configure &amp;&amp; make &amp;&amp; make install 进行编译安装，前提是系统上已经配置好 gcc 等编译安装环境，如果对 Linux 不是很熟悉的用户不推荐使用此方式，因为出现安装问题的解决难度较大。  macOS  macOS 是在 BSD(Berkeley Software Distribution)的基础上发展而来，而 BSD 是一个派生自 Unix 的操作系统，而 Linux 又是一个类 Unix 系统，所以 macOS 安装 Python 的方式也和 Linux 大体上差不多，主要分下面两种方式。  需要注意的是 macOS 同样也自带了 python2，系统自带的一些软件也会依赖于此，所以也一定不能删除。以 macOS 10.15 为例，自带的 python2.7 安装在 /System/Library/Frameworks/Python.framework/Versions/2.7 路径下。  使用 Homebrew 在线安装  Homebrew 是 macOS 上的一种安装源工具，类似于 CentOS 的 yum，直接使用如下命令安装即可： brew install python3   图形界面安装  可去 Python 官网下载 macOS installer，下载后双击进行图形界面安装，安装选项说明大体和 Windows 类似，这里不再赘述。  Python 命令行使用  除了在命令行直接键入 python 进入 Python 交互式命令行的使用方式外，在命令行下使用 Python 通常还有下面三种方式  python -c command  通过这种方式可以快速的执行 python 命令：  python -c \"print('hello, world!')\"   python stript  通过这种方式可以直接执行一个脚本文件：  python mystript.py   python -m module_name  通过这种方式调用一个安装好的 python 模块，比如可以使用 python 自带的 http.server 模块临时启动一个 http 服务器：  python -m http.server   参考资料     [Python 安装] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624   [Python Setup and Usage] ：https://docs.python.org/3.5/using/index.html  "
  },
  
  {
    "title": "Python 入门 - 1 - 简介",
    "url": "/posts/python-tutorial-1-introduction/",
    "categories": "Python 入门",
    "tags": "python",
    "date": "2020-03-04 17:43:50 +0800",
    "content": "Python 简介  Python 是由荷兰人 Guido van Rossum (“龟叔”)于 1989 年圣诞节期间，为了打发时间而编写。Python 这个名字取自作者很喜欢的 BBC 电视剧”Monty Python’s Flying Circus”。  Python 是在另一种编程语言 ABC 的基础上发展而来，ABC 是“龟叔”参与设计的一种教学语言，他认为 ABC 非常优美和强大，但是并没有取得成功，他认为是没有开放造成的，所以 Python 进行了开源。Python 还结合了很多 C 语言的使用习惯，比如 Python 中的 open 函数和 C 语言的 open 函数非常类似，Python 里同样也有文件描述符等概念。  Python 是一种 解释型、面向对象 的语言，相比较而言 C 则是 编译型、面向过程 的语言。  解释型语言使用解释器在运行期间动态的逐条将语句解释为计算机可识别的机器代码，编译型语言需要提前把源代码编译为机器代码，然后运行。  解释型语言相比编译型语言的主要缺点是运行速度慢，但是由于很多的应用不需要追求很高的性能，所以使用解释型语言已经完全满足运行速度的要求。  解释型语言相比编译型语言的主要优点是开发速度快，因为开发过程中可以不用编译就立即运行而得到反馈，另外像 Python 这样的高级语言做了更高程度的抽象和封装，并且把很多常用操作封装为了标准库，所以在代码量上会比 C 语言少很多。而且 Python 可以使用即时编译(JIT)技术提高运行速度  面向对象和面向过程语言的主要区别是面向对象可以定义类(class)，而面向过程语言只能定义函数，Python 既支持面向过程，也支持面向对象。关于面向对象和面向过程的更多区别请点击对应的链接进行深入了解。  Python 应用  近些年来 Python 越来越火，应用也越来越广泛，根据编程语言排行榜 TIOBE 2020 年 2 月最新的数据显示，目前 Python 的流行程度排行第 3，居于 Java 和 C 之后。  很多我们所熟知的网站也是使用 Python 开发，比如国外的 Youtube 、Instgram，国内的知乎、豆瓣，还有像 Google 、Yahoo 这样的大公司内部都在大量的使用 Python。  Python 在人工智能领域也非常流行，很多人工智能框架都选择使用 Python 语言，比如大名鼎鼎的 Google 人工智能框架 TensorFlow 就支持 Python。  另外 Python 在自动化测试方面也是应用广泛，比如开源的自动化测试框架 RobotFramework 就是使用 Python 编写的，很多公司在自己开发自动化测试框架时也大多选择使用 Python，比如华为就是在大量的使用 Python 来进行自动化测试。  由于 Python 简单、易学、易用的特点，所以在非编程相关的工作上也可以使用，比如日常办公中需要在大量的文本文件中搜索并替换某些内容，或者需要批量的整理操作大量文件，这个时候可以使用 Python 快速的编写一些小脚本来提升工作效率。相比 shell 或者 bat 等操作系统专用的脚本，Python 的跨平台特性使得使用 Python 编写的脚本使用更方便。而且目前的大多数 Linux 发行版和 OSX 等系统上都内置了 Python。  可以在 Python 官网 https://www.python.org/about/apps/ 上看到 Python 的很多应用列表。  Python 版本  Python 自诞生以来经历了 2 个主要的大版本，一个是发布于 2000 年的 Python2，另一个是发布于 2008 年的 Python3。Python3 相比 Python2 有了很大的变更，所以 Python2 下编写的代码是不能直接在 Python3 上运行的。而且官方已经于 2020.1.1 停止了对 Python2 的维护，也就是说如果 Python2 出现了重大漏洞也不会再有更新的修复版本发布了，所以建议如果是新写的项目都使用 Python3。  如果由老的 Python2 的应用需要迁移到 Python3，可以参考官方迁移指南：https://docs.python.org/3/howto/pyporting.html 更多关于 Python2 和 Python3 的区别可以参考：http://python-future.org/compatible_idioms.html  Python 解释器  通常我们说 Python 是用 C 语言编写的，是因为官方下载的解释器 CPython 是使用 C 语言编写的，其实除了 CPython 之外还有很多其他的解释器。     以下内容引用自：https://www.liaoxuefeng.com/wiki/1016959663602400/1016966024263840    IPython IPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了 IE。 CPython 用&gt;&gt;&gt;作为提示符，而 IPython 用In [序号]:作为提示符。    PyPy PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。 绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到 PyPy 下执行，就需要了解 PyPy 和 CPython 的不同点。    Jython Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。    IronPython IronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。   Python 编辑器(IDE)  有很多的编辑器支持编写和调试 Python 程序，以下列出几个比较流行的，可以根据个人喜好进行选择：    IDLE ：这个 Python 官方的 IDE，Windows 上安装 Python 后就会有，功能较简单，可以用于学习和测试一些语法。   PyCharm ：这个是由 JetBrains 开发的 Python IDE，功能强大，有专业版和社区版，个人使用可以选择免费的社区版。   VSCode ：这个是微软的 Visual Studio 的精简版，开源且支持大量的插件，通过安装 Python 插件可以用于 Python 开发。   Vim ：如果是 Linux 下也可以使用这 Vim 加一些插件进行 Python 开发。   参考资料     [Python 简介] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959735620448   [Whetting Your Appetite] ：https://docs.python.org/3.5/tutorial/appetite.html   [Python-wikipedia] ：https://zh.wikipedia.org/wiki/Python#cite_note-python_history-3  "
  }
  
]

