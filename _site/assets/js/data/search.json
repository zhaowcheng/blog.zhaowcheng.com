[
  
  {
    "title": "一种让 Linux 上的 C/C++ 程序自带依赖库的打包方式",
    "url": "/posts/a-packaging-method-with-its-own-deps/",
    "categories": "杂七杂八",
    "tags": "linux",
    "date": "2022-09-03 15:34:00 +0800",
    





    "snippet": "Linux 上的 C/C++ 程序编译打包后拿到 同 CPU 架构 的其他 Linux 系统上运行时，通常会由于目标系统上缺少该程序所需的库而无法运行。这个问题在一个连接上互联网的 Linux 系统上可以很容易的通过 yum 或 apt 安装缺少的依赖库来解决，但是如果是在一个无法使用 yum 和 apt 的内网系统上，则非常麻烦。本文介绍一种打包方式，让打包后的程序即使在目标系统上没有该程序所需的库时，也能正常运行。步骤以下为该方式的详细步骤：第一步：编译平台的选择选择一个 libc 版本 小于等于 该程序需要适配的所有系统中 libc 版本最小的系统。比如该程序需要适配 2 个系统，这两个系统的 libc 版本分别为 2.23 和 2.28，则选择一个 libc 版本 小于等于 2.23 的系统作为编译平台。第二步：拷贝依赖库在编译完成后，打包之前，通过 ldd 命令查询该程序中所有 ELF 文件的依赖库，并将查询到的 除 libc 以外的所有依赖库拷贝到该程序的安装目录中（通常是安装目录下的 lib 目录），然后再进行打包。如果打包方式为 rpm，建议在 spec 文件中添加 AutoReqProv: no 选项。第三步(可选)：添加 RPATH在打包之前，给所有该程序中的 ELF 文件添加 RPATH 指向其自带的 lib 目录，让程序在运行时自动优先查找自己的 lib 目录中的库文件，这样程序运行时就不需要目标系统上安装有其依赖库了。当然也可以不添加 RPATH，而是在使用时配置 LD_LIBRARY_PATH 环境变量指向其自带的 lib 目录达到同样的效果。示例下面以 postgresql 为例对该打包方式进行演示：第一步：编译平台的选择选择 CentOS 6 作为编译平台，其 libc 版本为 2.12：[root@el6-x86_64 ~]# ls -l /lib64/libc.so.6lrwxrwxrwx 1 root root 12 Jul  8 13:13 /lib64/libc.so.6 -&amp;gt; libc-2.12.so[root@el6-x86_64 ~]# tar xf postgresql-9.6.24.tar.gz[root@el6-x86_64 ~]# cd postgresql-9.6.24/[root@el6-x86_64 postgresql-9.6.24]# ./configure --prefix=/usr/local/pg9...[root@el6-x86_64 postgresql-9.6.24]# make -j`nproc` &amp;amp;&amp;amp; make install...[root@el6-x86_64 postgresql-9.6.24]# cd /usr/local/pg9[root@el6-x86_64 pg9]# lsbin include lib share[root@el6-x86_64 pg9]# 第二步：拷贝依赖库[root@el6-x86_64 ~]# ./copy_deps.sh /usr/local/pg9/ /usr/local/pg9/lib...Processing /lib64/libc.so.6Processing /lib64/libdl.so.2 Processing /lib64/1ibm.so.6Processing /lib64/libpthread.so.0 Processing /lib64/libreadline.so.6`/lib64/libreadline.so.6&#39; -&amp;gt; `/usr/local/pg9/1ib/libreadline.so.6&#39; Processing /lib64/1ibrt.so.1Processing/lib64/libtinfo.so.5`/lib64/libtinfo.so.5&#39; -&amp;gt; `/usr/local/pg9/1ib/libtinfo.so.5&#39; Processing /lib64/1ibz.so.1`/lib64/libz.so.1&#39; -&amp;gt; `/usr/local/pg9/1ib/libz.so.1&#39; Processing /usr/local/pg9/lib/libecpg.so.6Processing /usr/local/pg9/1ib/libpgtypes.so.3 Processing /usr/local/pg9/lib/libpq.so.5 [root@el6-x86_64 ~]# 以下为 copy_deps.sh 脚本内容：#/bin/bash -e# Copy the deps of all elf files in `ELFDIR` to `LIBDIR`.PROGNAME=$(basename $0)if [[ $# != 2 ]]; then    echo &quot;Usage: $PROGNAME ELFDIR LIBDIR&quot; &amp;gt;&amp;amp;2    exit 1fiELFDIR=$1LIBDIR=$2for elf in `find $ELFDIR -type f -exec file {} + | grep ELF | cut -d: -f1`; do     echo &quot;Analysing $elf&quot;    ldd $elf    for sopath in `ldd $elf | grep -E &#39;.+.so.* =&amp;gt; /.+.so.* \\(θx.+\\)&#39; | awk &#39;{print $3}&#39;`; do         sopaths+=($sopath)    donedonesopaths=(`for i in ${sopaths[*]}; do echo $i; done | sort -u`) for sopath in ${sopaths[*]}; do    echo &quot;Processing $sopath&quot;     soname=`basename $sopath`    if [[ (! -e $LIBDIR/$soname) ]]; then        if [[ `which dpkg 2&amp;gt; /dev/null` ]]; then            owninfo=`dpkg -S $sopath 2&amp;gt; /dev/null ||:`        else            owninfo=`rpm -qf $sopath 2&amp;gt; /dev/null ||:`        fi        if [[ ! $owninfo =~ ^glibc|^libc6 ]]; then             cp -v $sopath $LIBDIR        fi    fidone第三步(可选)：添加 RPATH[root@el6-x86_64 ~]# ./set_relative_rpath.sh /usr/local/pg9/ /usr/local/pg9/libSet the rpath of /usr/local/pg9/lib/libz.so.1 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libecpg_compat.so.3.8 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libreadline.so.6 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libtinfo.so.5 to $ORIGINSet the rpath of /usr/local/pg9/1ib/libecpg.so.6.8 to $ORIGINSet the rpath of/usr/local/pg9/1ib/postgresq1/utf8_and_uhc.so to $ORIGIN/..Set the rpath of/usr/local/pg9/1ib/postgresq1/latin2_and_win1250.so to $ORIGIN/.....Set the rpath of/usr/local/pg9/bin/clusterdb to $ORIGIN/../libSet the rpath of /usr/local/pg9/bin/postgres to $ORIGIN/../1ibSet the rpath of/usr/local/pg9/bin/pg_restore to $ORIGIN/../1ibSet the rpath of/usr/local/pg9/bin/ecpg to $ORIGIN/../lib [root@el6-x86_64 ~]# 以下为 set_relative_rpath.sh 脚本内容：#/bin/bash -e# Set the rpath of all elf files in `ELFDIR` to relative paths to `LIBDIR`.PROGNAME=$(basename $0)if [[ $# != 2 ]]; then    echo &quot;Usage: $PROGNAME ELFDIR LIBDIR&quot; &amp;gt;&amp;amp;2    exit 1fiELFDIR=$1LIBDIR=$2for elf in $(find $ELFDIR -type f -exec file {} + | grep ELF | cut -d: -f1); do    elf_parentdir=$(dirname $elf)    relative_path=$(realpath --relative-to=$elf_parentdir $LIBDIR)    if [[ $relative_path == &#39;.&#39; ]]; then        relative_rpath=&quot;$ORIGIN&quot;    else        relative_rpath=&quot;$ORIGIN/$relative_path&quot;    fi    if [[ $(patchelf --print-rpath $elf) != $relative_rpath ]]; then        echo &quot;Set the rpath of $elf to $relative_rpath&quot;        patchelf --set-rpath $relative_rpath $elf    fi  done第四步：验证将 Centos 6 上的 postgresql 安装目录打包:[root@el6-x86_64 ~]# cd /usr/local/[root@el6-x86_64 local]# tar cf pg9.tar ./pg9/[root@el6-x86_64 local]# lsbin doc etc games include lib lib64 libexec patchelf pg9 pg9.tar pgsql sbin share src ssl[root@el6-x86_64 local]#将打包的 postgresql 放到另外一个 Ubuntu 20 系统上，该系统 libc 版本为 2.31，验证程序是否可正常使用：root@ubt20-x86-64:~# ls -l /lib/x86_64-linux-gnu/libc.so.6lrwxrwxrwx 1 root root 12 Dec 16 2020 /lib/x86_64-linux-gnu/libc.so.6 -&amp;gt; libc-2.31.soroot@ubt20-x86-64:~# tar xf pg9.tarroot@ubt20-x86-64:~# cd pg9/root@ubt20-x86-64:~/pg9# ldd ./bin/psql        linux-vdso.so.1 (0x00097ffe0ace7000)        libpq.so.5 =&amp;gt; /root/pg9/./bin/../lib/libpq.so.5 (0x00007f374e68a000)        libreadline.so.6 =&amp;gt; /root/pg9/./bin/../lib/libreadline.so.6 (0x0000003fd9200000)        libm.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f374e52f000)        libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f374e33d090)        libpthread.so.Q =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f374e31a000)        libtinfo.so.5 =&amp;gt; /root/pg9/./bin/../lib/libtinfo.so.5 (0x0000603fdaa00000)        /lib64/ld-linux-x86-64.so.2 (0x00007f374e8b5000)root@ubt20-x86-64:~/pg9# ./bin/psql -Vpsql (PostgreSQL) 9.6.24root@ubt20-x86-64:~/pg9# "
  },
  
  {
    "title": "Python 入门-12-模块和包",
    "url": "/posts/python-tutorial-12-modules-and-packages/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2022-03-10 15:16:00 +0800",
    





    "snippet": "模块（module）一个包含 Python 代码的 .py 文件就是一个 模块（module），文件名去除 .py 后缀就是 模块名，模块名也可以通过模块的 __name__ 属性获取。一个模块可以被 import 引用，也可以当作脚本直接运行，模块中的 定义 和 语句 只在被 import 或直接运行的时候 执行一次。例如现在有一个名为 fibo.py 的文件，其内容如下：def fib(n):    a, b = 0, 1    while b &amp;lt; n:        print(b, end=&#39; &#39;)        a, b = b, a+b    print()def fib2(n):    result = []    a, b = 0, 1    while b &amp;lt; n:        result.append(b)        a, b = b, a+b    return result# 被当作脚本运行时会进入该 if 分支if __name__ == &quot;__main__&quot;:    import sys    fib(int(sys.argv[1]))导入模块import 方式导入：&amp;gt;&amp;gt;&amp;gt; import fibo&amp;gt;&amp;gt;&amp;gt; fibo.fib(1000)1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&amp;gt;&amp;gt;&amp;gt; fibo.fib2(100)[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&amp;gt;&amp;gt;&amp;gt; fibo.__name__&#39;fibo&#39;from … import 方式导入：&amp;gt;&amp;gt;&amp;gt; from fibo import fib, fib2&amp;gt;&amp;gt;&amp;gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377&amp;gt;&amp;gt;&amp;gt; from fibo import *  # 为避免名称冲突，建议尽量不要使用这种方式&amp;gt;&amp;gt;&amp;gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377以脚本方式运行模块$ python fibo.py 501 1 2 3 5 8 13 21 34内置模块（标准库）Python 解释器内置了很多的模块（即标准库），这些库提供了很多的便利性，并且单独提供了文档对这些库进行说明：https://docs.python.org/3.5/library/index.html模块搜索路径当使用 import 导入模块时，Python 搜索这个模块的路径如下：  内置模块列表  sys.path 列表，其包含如下目录（按顺序）：          包含输入脚本的目录（如果未指定输入脚本直接启动解释器则是当前目录）      PYTHONPATH 环境变量中的目录      其他安装时生成的默认路径（如第三方库安装目录 site-packages）      模块缓存为了提升模块的 加载 速度，Python 在第一次 import 时会在模块文件所在目录下创建 __pycache__ 目录，并将模块编译后的字节码文件（.pyc），以 modname.version.pyc 文件名格式缓存在该目录下。例如一个模块文件名为 mymod.py，使用 CPython 3.5 在第一次加载后，会在该文件所在目录下生成路径为 __pycache__/mymod.cpython-35.pyc 的模块缓存文件，那么在下次加载该模块时，如果模块源文件（.py）没有修改（通过 .pyc 文件和对应 .py 文件的修改日期对比进行判断），则直接加载缓存的模块字节文件，如果有修改则重新生成缓存文件。如果是在命令行以脚本方式直接执行模块文件，则不会生成缓存文件。缓存模块字节文件还可以在源文件不存在的时候直接加载使用，例如删除 mymod.py 后把 mymod.cpython-35.pyc 从 __pycache__ 中拷贝到上级目录（即原 mymod.py 所在目录），并且去掉文件名中 version 字段（即改名为 mymod.pyc），然后即可直接 import mymod 并使用。这种方式可以方便进行不带源文件分发使用，Python 还提供了 compileall 标准库来进行批量编译源文件后分发使用。需要注意的是缓存模块文件仅仅提升了 加载 速度，执行速度还是和源文件执行的方式一样的。查看模块属性可以使用内置函数 dir() 查看模块中定义的所有名称：&amp;gt;&amp;gt;&amp;gt; import builtins&amp;gt;&amp;gt;&amp;gt; dir(builtins)  [&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;, &#39;BlockingIOError&#39;, &#39;BrokenPipeError&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;, &#39;ChildProcessError&#39;, &#39;ConnectionAbortedError&#39;, &#39;ConnectionError&#39;, &#39;ConnectionRefusedError&#39;, &#39;ConnectionResetError&#39;, &#39;DeprecationWarning&#39;, &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;, &#39;FileExistsError&#39;, &#39;FileNotFoundError&#39;, &#39;FloatingPointError&#39;, &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;, &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;InterruptedError&#39;, &#39;IsADirectoryError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;, &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotADirectoryError&#39;, &#39;NotImplemented&#39;, &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;, &#39;PendingDeprecationWarning&#39;, &#39;PermissionError&#39;, &#39;ProcessLookupError&#39;, &#39;ReferenceError&#39;, &#39;ResourceWarning&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;, &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;, &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;TimeoutError&#39;, &#39;True&#39;, &#39;TypeError&#39;, &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;, &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;, &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;_&#39;, &#39;__build_class__&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;, &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;exit&#39;, &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;, &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;, &#39;quit&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;, &#39;zip&#39;]包（package）包的目录结构Python 中当一个目录包含一个 __init__.py 文件（可以是空文件，也可以定义名称）时，这个目录就会被当作一个 包（package），包内可以包含模块文件，也可以包含 子包，不同包内的模块名可以相同而互不冲突，这种机制可以方便对模块分类管理，例如一个处理音频文件的包目录结构如下：sound/                          Top-level package      __init__.py               Initialize the sound package      formats/                  Subpackage for file format conversions              __init__.py              wavread.py              wavwrite.py              aiffread.py              aiffwrite.py              auread.py              auwrite.py              ...      effects/                  Subpackage for sound effects              __init__.py              echo.py              surround.py              reverse.py              ...      filters/                  Subpackage for filters              __init__.py              equalizer.py              vocoder.py              karaoke.py              ...包的导入方式包的用户可以从包中导入单个模块，例如:import sound.effects.echo这会加载子模块 sound.effects.echo 。但引用它时必须使用它的全名。sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)导入子模块的另一种方法是from sound.effects import echo这也会加载子模块 echo ，并使其在没有包前缀的情况下可用，因此可以按如下方式使用:echo.echofilter(input, output, delay=0.7, atten=4)另一种形式是直接导入所需的函数或变量:from sound.effects.echo import echofilter同样，这也会加载子模块 echo，但这会使其函数 echofilter() 直接可用:echofilter(input, output, delay=0.7, atten=4)请注意，当使用 from package import item 时，item 可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 import 语句首先测试是否在包中定义了item，如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。相反，当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包，最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。包的 __all__ 属性包的 __init__.py 文件中可以定义一个名为 __all__ 的列表，用来列出 from package import * 时导入的模块，假如 sound/effects/__init__.py 文件中包含如下定义：__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]那么在使用 from sound.effects import * 语句时只会导入 echo、surround 和 reverse 三个子模块。如果没有定义 __all__，当使用 from sound.effects import * 语句时，实际上只导入了 effects 子包。兄弟包的导入方式在包中可以使用绝对路径导入兄弟包的模块，比如在上面的 sound 示例包中，在模块 sound.filters.vocoder 中导入 sound.effects.echo 模块的命令如下：from sound.effects import echo也可以使用相对路径导入兄弟包的模块，比如在 sound.effects.surround 模块使用相对路径导入其他模块：from . import echofrom .. import formatsfrom ..filters import equalizer请注意，相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是 __main__ ，因此用作 Python 应用程序主模块的模块必须始终使用绝对导入。引用资料  [Modules] : https://docs.python.org/3.5/tutorial/modules.html"
  },
  
  {
    "title": "Python 入门-11-类",
    "url": "/posts/python-tutorial-11-classes/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2022-02-24 11:05:00 +0800",
    





    "snippet": "Python 类源自于 C++ 和 Modula-3 这两种语言的类机制的结合。Python 中一切皆 对象（Object），类里边又引入了 3 种对象：类对象（Class）、实例对象（Instance） 和 方法对象（Method）作用域和命名空间作用域（scope） 指的是 Python 代码中的一个文本区域，分为以下几类：  模块  类  函数命名空间（namespace） 是一个名字到对象的映射，一个作用域对应会有一个命名空间来保存该作用域中的 名称（name），Python 中按照以下顺序去查找一个名称：  最内部作用域的命名空间（包含局部名称）  最内部作用域与最近的作用域之间的 中间作用域 的命名空间（包含非全局名称 nonlocal）  当前模块的命名空间（包含全局名称 global）  内置名称模块（builtins）的命名空间命名空间是动态创建的，不同时刻创建的命名空间具有不同的生存期：  包含内置名称的命名空间（builtins）是在 Python 解释器启动时创建的，会持续到解释器退出；  模块的全局命名空间在模块被读入时创建，也会持续到解释器退出（）；  函数的本地命名空间在函数被调用时创建，当函数返回或者抛出异常时被删除（递归调用的函数每次都有自己的本地命名空间）；以下是一个作用域和命名空间的示例：def scope_test():    def do_local():        spam = &quot;local spam&quot;    def do_nonlocal():        nonlocal spam        spam = &quot;nonlocal spam&quot;    def do_global():        global spam        spam = &quot;global spam&quot;    spam = &quot;test spam&quot;    do_local()    print(&quot;After local assignment:&quot;, spam)    do_nonlocal()    print(&quot;After nonlocal assignment:&quot;, spam)    do_global()    print(&quot;After global assignment:&quot;, spam)scope_test()print(&quot;In global scope:&quot;, spam)# 其输出内容是：&#39;&#39;&#39;After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam&#39;&#39;&#39;类定义语法格式类定义语法格式如下：class ClassName:    &amp;lt;statement-1&amp;gt;    .    .    .    &amp;lt;statement-N&amp;gt;通常类定义内的语句都是 函数定义，但也可以是其他语句（如属性定义等）。在进入类定义时，将创建一个 命名空间，用于保存类中的名称。当（从结尾处）正常离开类定义时，将创建一个 类对象。类对象支持两种操作：属性引用 和 实例化。class MyClass:    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;    i = 12345    def f(self):        return &#39;hello world&#39;例如以上示例中定义的 MyClass 类，那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。类的 实例化 使用函数表示法：# 创建类的新 实例 并将此对象分配给局部变量 xx = MyClass()初始化方法类中可以定义一个 __init__() 方法，用于自定义类的初始化操作：class MyClass:    def __init__(self):        self.data = []__init__() 方法定义时还可以有额外的参数：&amp;gt;&amp;gt;&amp;gt; class Complex:...     def __init__(self, realpart, imagpart):...         self.r = realpart...         self.i = imagpart...&amp;gt;&amp;gt;&amp;gt; x = Complex(3.0, -4.5)&amp;gt;&amp;gt;&amp;gt; x.r, x.i(3.0, -4.5)self 参数类中定义的方法的第一个参数固定被当作类初始化后的 实例本身，通常写作 self，可在方法中使用该变量引用其他 实例属性：class Complex:    def __init__(self, realpart, imagpart):        self.r = realpart        self.i = imagpart    def get_realpart(self):        return self.r    def get_imagpart(self):        return self.i    # 也可以不定义参数，只是这样就不能在该方法中访问实例属性 r 和 i 了    def get_nothing():        return None访问限制如果类中定义的 属性（包括变量和方法） 是以 双下划线（__） 开头，并且以 最多一个下划线结尾，那么即表示该属性是 私有的（Private），不能从外部访问：&amp;gt;&amp;gt;&amp;gt; class Student(object):...     def __init__(self, name, score):...         self.__name = name...         self.__score = score... &amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 59)&amp;gt;&amp;gt;&amp;gt; bart.__nameTraceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;实际上 Python 并没有机制严格的限制对私有属性的访问，只是简单的对私有属性进行了 改名（加上了下划线开头的类名前缀） 而已：&amp;gt;&amp;gt;&amp;gt; class Student(object):...     def __init__(self, name, score):...         self.__name = name...         self.__score = score... &amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 59)&amp;gt;&amp;gt;  # 虽然通过下面这种方式可以访问私有属性，但强烈不建议这样做&amp;gt;&amp;gt;&amp;gt; bart._Student__name&#39;Bart Simpson&#39; 双下划线开头 并且 双下划线结尾 的名称是 Python 类的一些特殊属性，比如 __name__ 表示类名，__doc__ 表示类注释，还有用于初始化实例的 __init__() 方法等，所以建议也不要自定义这样的属性：&amp;gt;&amp;gt;&amp;gt; class MyClass(object):...     &quot;&quot;&quot;my class&quot;&quot;&quot;...     pass...&amp;gt;&amp;gt;&amp;gt; MyClass.__name__&#39;MyClass&#39;&amp;gt;&amp;gt;&amp;gt; MyClass.__doc__&#39;my class&#39;&amp;gt;&amp;gt;&amp;gt;单下划线 开头的属性也可以直接访问，但是约定俗成的规范是这样的属性表示 保护属性，即能在子类中访问，但不建议从外部访问。数据属性 会覆盖掉同名的 方法属性，为了避免这种情况发生，建议数据属性使用名词，方法属性使用动词。类与实例类是抽象模板，实例是根据类创建出来的具体的对象，每个实例都拥有相同的方法，但各自的数据可能不同。&amp;gt;&amp;gt;&amp;gt; class Student(object):...     def __init__(self, name):...         self.name = name...&amp;gt;&amp;gt;&amp;gt; student1 = Student(&#39;tom&#39;)&amp;gt;&amp;gt;&amp;gt; student2 = Student(&#39;jack&#39;)&amp;gt;&amp;gt;&amp;gt; student1.name&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; student2.name&#39;jack&#39;&amp;gt;&amp;gt;&amp;gt;在类中直接定义的属性为 类属性，而绑定到实例上的属性是 实例属性，类属性是所有实例 共有 的，实例属性是每个实例 独有 的。&amp;gt;&amp;gt;&amp;gt; class Student(object):...     # 类属性...     clsname = &#39;Student&#39;...     def __init__(self, instname):...         # 实例属性...         self.instname = instname...&amp;gt;&amp;gt;&amp;gt; student1 = Student(&#39;tom&#39;)&amp;gt;&amp;gt;&amp;gt; student2 = Student(&#39;jack&#39;)&amp;gt;&amp;gt;&amp;gt; student1.clsname&#39;Student&#39;&amp;gt;&amp;gt;&amp;gt; student1.instname&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; student2.clsname&#39;Student&#39;&amp;gt;&amp;gt;&amp;gt; student2.instname&#39;jack&#39;&amp;gt;&amp;gt;&amp;gt;类继承单继承单继承的语法格式如下：class DerivedClassName(BaseClassName):    &amp;lt;statement-1&amp;gt;    .    .    .    &amp;lt;statement-N&amp;gt;其中 BaseClassName 叫做 DerivedClassName 的 基类，也可叫做 父类 或 超类，DerivedClassName 则叫做 BaseClassName 的 子类。通过继承的方式，子类可以拥有父类的所有属性（包括数据属性和方法属性），当引用类的属性时，搜索顺序是先搜索子类，再搜索父类，然后是父类的父类，依次往上，所以子类如果定义了和父类同名的属性，就相当于覆盖了父类的同名属性。多重继承多种继承的语法格式如下：class DerivedClassName(Base1, Base2, Base3):    &amp;lt;statement-1&amp;gt;    .    .    .    &amp;lt;statement-N&amp;gt;子类 DerivedClassName 同时从父类 Base1、Base2 和 Base3 继承，这种情况下搜索一个属性的顺序是 深度优先、从左至右、同一个类只搜索一次，比如以上示例中先搜索 DerivedClassName，然后搜索 Base1，然后搜索 Base1 的父类一直搜索到顶，然后再搜索 Base2 依次到顶，依此类推。关于更详细的搜索顺序见：https://www.python.org/download/releases/2.3/mro/获取对象信息type()使用 type() 函数可以判断一个对象的类型：&amp;gt;&amp;gt;&amp;gt; type(123)&amp;lt;class &#39;int&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(&#39;hello&#39;)&amp;lt;class &#39;str&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(True)&amp;lt;class &#39;bool&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(int)  # 类的类型都是 type&amp;lt;class &#39;type&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(str)&amp;lt;class &#39;type&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type(bool)&amp;lt;class &#39;type&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;types 模块中定义了各种类型，可以方便直观的用于类型判断和比较：&amp;gt;&amp;gt;&amp;gt; import types&amp;gt;&amp;gt;&amp;gt; def fn():...     pass...&amp;gt;&amp;gt;&amp;gt; type(fn)==types.FunctionTypeTrue&amp;gt;&amp;gt;&amp;gt; type(abs)==types.BuiltinFunctionTypeTrue&amp;gt;&amp;gt;&amp;gt; type(lambda x: x)==types.LambdaTypeTrue&amp;gt;&amp;gt;&amp;gt; type((x for x in range(10)))==types.GeneratorTypeTrueisinstance()isinstance() 函数可以判断一个实例是否为某个 类或其子类 的实例：&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;a&#39;, str)True&amp;gt;&amp;gt;&amp;gt; isinstance(123, int)True&amp;gt;&amp;gt;&amp;gt; isinstance(b&#39;a&#39;, bytes)True&amp;gt;&amp;gt;&amp;gt; isinstance([1, 2, 3], (list, tuple))  # 判断是否某些类型中的一种True&amp;gt;&amp;gt;&amp;gt; isinstance((1, 2, 3), (list, tuple))True&amp;gt;&amp;gt;&amp;gt; isinstance(True, int)  # bool 是 int 的子类Trueissubclass()issubclass() 函数可以判断某个类是否是另一个类的子类：&amp;gt;&amp;gt;&amp;gt; issubclass(bool, int)  # bool 是 int 的子类True&amp;gt;&amp;gt;&amp;gt; issubclass(str, int)Falsedir()dir() 函数可以获取一个对象的所有 属性 和 方法:&amp;gt;&amp;gt;&amp;gt; dir(&#39;hello&#39;)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]getattr(), setattr(), hasattr()使用 getattr(), setattr(), hasattr() 这三个函数可以操作对象的属性：&amp;gt;&amp;gt;&amp;gt; class MyObject(object):...     def __init__(self):...         self.x = 9...     def power(self):...         return self.x * self.x...&amp;gt;&amp;gt;&amp;gt; obj = MyObject()&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？True&amp;gt;&amp;gt;&amp;gt; obj.x9&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？False&amp;gt;&amp;gt;&amp;gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？True&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;19&amp;gt;&amp;gt;&amp;gt; obj.y # 获取属性&#39;y&#39;19类的一些特殊属性下面只简单介绍一些特殊属性，完整的特性属性详见：https://docs.python.org/3/reference/datamodel.html#special-method-names__iter__()如果一个类想被用于 for ... in 循环，类似 list 或 tuple 那样，就必须实现一个 __iter__() 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 __next__() 方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环。我们以斐波那契数列为例，写一个 Fib 类，可以作用于 for 循环：class Fib(object):    def __init__(self):        self.a, self.b = 0, 1 # 初始化两个计数器a，b    def __iter__(self):        return self # 实例本身就是迭代对象，故返回自己    def __next__(self):        self.a, self.b = self.b, self.a + self.b # 计算下一个值        if self.a &amp;gt; 100000: # 退出循环的条件            raise StopIteration()        return self.a # 返回下一个值现在，试试把 Fib 实例作用于 for 循环：&amp;gt;&amp;gt;&amp;gt; for n in Fib():...     print(n)...11235...4636875025__len__如果想要让对象适用于 len() 函数，即像 list 或 tuple 那样，可以自定义一个 __len__() 方法：&amp;gt;&amp;gt;&amp;gt; class MyList(object):...     def __init__(self, datas):...         self.datas = datas...     def __len__(self):...         return len(self.datas)...&amp;gt;&amp;gt;&amp;gt; mylist = MyList([1, 2, 3])&amp;gt;&amp;gt;&amp;gt; len(mylist)3引用资料  [Classes] : https://docs.python.org/3.5/tutorial/classes.html  [Special method names] : https://docs.python.org/3/reference/datamodel.html#special-method-names  [面向对象编程] : https://www.liaoxuefeng.com/wiki/1016959663602400/1017495723838528  [面向对象高级编程] : https://www.liaoxuefeng.com/wiki/1016959663602400/1017501628721248"
  },
  
  {
    "title": "Python 入门-10-异常",
    "url": "/posts/python-tutorial-10-exceptions/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2022-02-11 14:12:00 +0800",
    





    "snippet": "异常简介异常（Exception） 即程序执行过程中产生的预期以外的错误，例如有一个脚本 test.py，其内容如下：#!/bin/python3print(&#39;2&#39; + 2)当执行该脚本时会产生如下异常：[root@localhost ~] python3 test.py Traceback (most recent call last):  File &quot;test.py&quot;, line 3, in &amp;lt;module&amp;gt;    print(&#39;2&#39; + 2)TypeError: can only concatenate str (not &quot;int&quot;) to str上面打印的内容称为 异常栈，以 File 开头的那一行指明了产生异常的位置（即 test.py 的第 3 行），接下来一行即产生异常的语句（即 print(‘2’ + 2)），最后一行为异常类型以及异常消息，通过查看异常栈可以准确定位到产生异常的代码位置并进行修复。异常处理tryPython 中使用 try 语句进行异常处理，其语法定义如下：try_stmt  ::=  try1_stmt | try2_stmttry1_stmt ::=  &quot;try&quot; &quot;:&quot; suite               (&quot;except&quot; [expression [&quot;as&quot; identifier]] &quot;:&quot; suite)+               [&quot;else&quot; &quot;:&quot; suite]               [&quot;finally&quot; &quot;:&quot; suite]try2_stmt ::=  &quot;try&quot; &quot;:&quot; suite               &quot;finally&quot; &quot;:&quot; suite以下是一个简单的示例，该示例会一直等到用户输入一个整数为止，如果输入的不是整数，就会进入到 except 子句中执行 print 打印错误提示：&amp;gt;&amp;gt;&amp;gt; while True:...     try:...         x = int(input(&quot;Please enter a number: &quot;))...         break...     except ValueError:...         print(&quot;Oops!  That was no valid number.  Try again...&quot;)...exceptexcept 后面的异常类型可以是多个，使用圆括号括起来，表示捕获其中任一异常类型：except (RuntimeError, TypeError, NameError):except 后面也可以不接异常类型，表示捕获任意异常：except:    print(&quot;Some error occurred.&quot;)except 后面还可以接一个 as 子句来保存异常实例，以便后续进行处理：except OSError as err:    print(&quot;OS error: {0}&quot;.format(err))try 后面也可以同时接多个 except 子句，当发生异常时会按照顺序从上往下匹配，如果其中某个 except 子句匹配上了，后面的 except 子句就会跳过:import systry:    f = open(&#39;myfile.txt&#39;)    s = f.readline()    i = int(s.strip())except OSError as err:    print(&quot;OS error: {0}&quot;.format(err))except ValueError:    print(&quot;Could not convert data to an integer.&quot;)except:    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])    raise当产生的异常属于某个 except 子句后面的异常类的子类时，也会被捕获，比如以下示例中由于 C 和 D 都是 B 的子类，所以最终打印结果将是 B B B：class B(Exception):    passclass C(B):    passclass D(C):    passfor cls in [B, C, D]:    try:        raise cls()    except B:        print(&quot;B&quot;)    except C:        print(&quot;C&quot;)    except D:        print(&quot;D&quot;)else在 except 子句后面还可以接一个 else 子句（如果有多个 except，else 必须放在所有 except 后面），当没有异常发生时，才会进入到 else 子句：try:    print(&#39;hello, world&#39;)except:    print(&#39;error&#39;)else:    print(&#39;no error&#39;)finally在 try 语句的最后（即 except 和 else 后面）还可以接一个 finally 子句，无论是否发生异常，最终都会进入 finally 子句，所以通常可以在 finally 子句中进行一些清理工作：try:    print(&#39;hello, world&#39;)except:    print(&#39;error&#39;)else:    print(&#39;no error&#39;)finally:    print(&#39;finished&#39;)抛出异常raise 语句可以主动抛出异常：&amp;gt;&amp;gt;&amp;gt; raise NameError(&#39;HiThere&#39;)Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;NameError: HiThereraise 后面可以是一个异常类或者一个异常实例，如果接的是一个异常类则相当于无参数的异常类实例：raise ValueError  # 相当于 &#39;raise ValueError()&#39;在 except 子句中还可以使用不接任何参数的 raise 语句，这样表示直接将 except 捕获的异常再次原样抛出：&amp;gt;&amp;gt;&amp;gt; try:...     raise NameError(&#39;HiThere&#39;)... except NameError:...     print(&#39;An exception flew by!&#39;)...     raise...An exception flew by!Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in &amp;lt;module&amp;gt;NameError: HiThere自定义异常Python 提供了很多了内置异常类，其继承关系如下：BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception      +-- StopIteration      +-- StopAsyncIteration      +-- ArithmeticError      |    +-- FloatingPointError      |    +-- OverflowError      |    +-- ZeroDivisionError      +-- AssertionError      +-- AttributeError      +-- BufferError      +-- EOFError      +-- ImportError      +-- LookupError      |    +-- IndexError      |    +-- KeyError      +-- MemoryError      +-- NameError      |    +-- UnboundLocalError      +-- OSError      |    +-- BlockingIOError      |    +-- ChildProcessError      |    +-- ConnectionError      |    |    +-- BrokenPipeError      |    |    +-- ConnectionAbortedError      |    |    +-- ConnectionRefusedError      |    |    +-- ConnectionResetError      |    +-- FileExistsError      |    +-- FileNotFoundError      |    +-- InterruptedError      |    +-- IsADirectoryError      |    +-- NotADirectoryError      |    +-- PermissionError      |    +-- ProcessLookupError      |    +-- TimeoutError      +-- ReferenceError      +-- RuntimeError      |    +-- NotImplementedError      |    +-- RecursionError      +-- SyntaxError      |    +-- IndentationError      |         +-- TabError      +-- SystemError      +-- TypeError      +-- ValueError      |    +-- UnicodeError      |         +-- UnicodeDecodeError      |         +-- UnicodeEncodeError      |         +-- UnicodeTranslateError      +-- Warning           +-- DeprecationWarning           +-- PendingDeprecationWarning           +-- RuntimeWarning           +-- SyntaxWarning           +-- UserWarning           +-- FutureWarning           +-- ImportWarning           +-- UnicodeWarning           +-- BytesWarning           +-- ResourceWarning但是用户也可以自定义异常类，自定义异常类必须直接或间接的继承自 Exception，通常一个异常类里边什么都不做，或者最多定义几个属性用于保存异常相关的信息：class Error(Exception):    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;    passclass InputError(Error):    &quot;&quot;&quot;Exception raised for errors in the input.    Attributes:        expression -- input expression in which the error occurred        message -- explanation of the error    &quot;&quot;&quot;    def __init__(self, expression, message):        self.expression = expression        self.message = messageclass TransitionError(Error):    &quot;&quot;&quot;Raised when an operation attempts a state transition that&#39;s not    allowed.    Attributes:        previous -- state at beginning of transition        next -- attempted new state        message -- explanation of why the specific transition is not allowed    &quot;&quot;&quot;    def __init__(self, previous, next, message):        self.previous = previous        self.next = next        self.message = message引用资料  [Errors and Exceptions] : https://docs.python.org/3.5/tutorial/errors.html  [Exception hierarchy] : https://docs.python.org/3.5/library/exceptions.html#bltin-exceptions"
  },
  
  {
    "title": "Python 入门-9-输入输出",
    "url": "/posts/python-tutorial-9-input-and-output/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2021-02-24 20:44:30 +0800",
    





    "snippet": "终端的输入输出inputPython 提供了一个 input 函数供终端的输入使用，当程序执行到 input 处时会暂停并等待用户输入，用户输入完成并敲击回车后才会继续执行后续的代码。input 的返回值就是读取到的用户输入内容，还可以在调用 input 时传入一个字符串参数作为等待输入的提示信息显示。## 用 var 保存用户输入内容&amp;gt;&amp;gt;&amp;gt; var = input()&#39;hello, world&#39;&amp;gt;&amp;gt;&amp;gt; var&#39;hello, world&#39;&amp;gt;&amp;gt;&amp;gt; ## 等待输入时显示提示信息&amp;gt;&amp;gt;&amp;gt; name = input(&#39;Please input your name:&#39;)Please input your name:&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; name&#39;tom&#39;&amp;gt;&amp;gt;&amp;gt; printPython 提供一个 print 函数，可用于向终端打印内容，print 函数的定义如下：print(*objects, sep=&#39; &#39;, end=&#39;\\n&#39;, file=sys.stdout, flush=False)根据定义：print 会把任意多个 object 使用 str() 方法转换为字符串，并且在多个 object 之间使用 sep 进行分割，并且在最后增加 end，sep 和 end 必须是字符串，然后将这些内容输出到 file 参数所指定的对象，file 参数指定的对象必须要有 write(string) 方法，默认 file 参数为 sys.stdout，即当前终端。## 向终端输出两个字符 a 和 b&amp;gt;&amp;gt;&amp;gt; print(&#39;a&#39;, &#39;b&#39;)a b## 向终端输出 a 和 b，并且将 a 和 b 使用 - 进行分割&amp;gt;&amp;gt;&amp;gt; print(&#39;a&#39;, &#39;b&#39;, sep=&#39;-&#39;)a-b## 向终端输出 a 和 b，并且在最后输出两个换行(\\n)&amp;gt;&amp;gt;&amp;gt; print(&#39;a&#39;, &#39;b&#39;, end=&#39;\\n\\n&#39;)a b&amp;gt;&amp;gt;&amp;gt;需要注意的是 print 函数的 sep、end、file 和 flush 参数必须使用关键字参数的方式传入(即使用 name=value 的形式)，否则会被当作待打印的 object 对象。文件的输入输出文件的输入输出即为文件的读写，Python 中文件的读写分别使用 read 和 write 函数，但是在进行文件读写前必须使用 open 函数打开文件。openopen 函数定义如下：open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)下面分别对其各参数进行说明：      file    可以是表示 文件路径（相对路径或绝对路径）的字符串（string）或者字节类型（bytes）。  也可以是表示 文件描述符 的数字（Integer），如果是文件描述符，那么默认情况下当 open 返回的文件对象被关闭时，文件描述符也会同时被关闭，除非调用 open 时传入 closefd 参数为 False。        mode    由固定的字符组成的表示文件打开模式的字符串，所有可选字符模式如下：                            字符          含义                                      r          读模式                          w          写模式，如果文件已存在则清空文件内容                          x          写模式，如果文件已存在则报错                          a          追加写模式，如果文件已存在则从文件末尾开始写入                          b          二进制模式                          t          文本模式                          +          更新模式（可读可写）                      以上字符又可以按照如下规则进行组合：      (r|w|x|a)[b|t][+]    共 3 部分组成，圆括号表示必选参数，方括号表示可选参数  第一部分为必选参数，从 r、w、x、a 中任选一个  第二部分为可选参数，从 b 和 t 中任选一个，默认为 t  第三部分也为可选参数，只有一个可选项 +        根据组合规则，最终完整的模式及含义如下：                            模式          含义                                      r          只读模式，进行写操作会报错                          w          只写模式，如果文件不存在则创建新文件，如果已存在则清空文件内容，进行读操作会报错                          x          只写模式，如果文件不存在则创建新文件，如果已存在则报错，进行读操作会报错                          a          追加写模式，如果文件不存在则创建新文件，如果已存在则从文件末尾开始写                          r+          读写模式，相当于对 r 模式增加了写操作                          w+          读写模式，相当于对 w 模式增加了读操作                          x+          读写模式，相当于对 x 模式增加了读操作                          a+          读写模式，相当于对 a 模式增加了读操作                          rb          与 r 模式相比，不同点在于以二进制模式打开文件                          wb          与 w 模式相比，不同点在于以二进制模式打开文件                          xb          与 x 模式相比，不同点在于以二进制模式打开文件                          ab          与 a 模式相比，不同点在于以二进制模式打开文件                          rb+          与 r+ 模式相比，不同点在于以二进制模式打开文件                          wb+          与 w+ 模式相比，不同点在于以二进制模式打开文件                          xb+          与 x+ 模式相比，不同点在于以二进制模式打开文件                          ab+          与 a+ 模式相比，不同点在于以二进制模式打开文件                          rt          与 r 模式相同                          wt          与 w 模式相同                          xt          与 x 模式相同                          at          与 a 模式相同                          rt+          与 r+ 模式相同                          wt+          与 w+ 模式相同                          xt+          与 x+ 模式相同                          at+          与 a+ 模式相同                          buffering    缓存策略，可选值即含义如下：                            值          含义                                      -1          二进制模式: 自动检测存储设备的块大小（即 io.DEFAULT_BUFFER_SIZE，通常是 4096 或 8192，单位字节），并以此作为缓存大小。 交互式文本模式: 即 isatty() 为 True 的文件对象，该情况下将缓存 一行。  其他文本模式: 与二进制模式相同。                          0          不使用缓存，仅适用于二进制模式                          1          缓存 一行，仅适用于文本模式                          &amp;gt;1          以该值（单位字节）作为固定大小进行缓存                          encoding    文件编码和解码格式，仅适用于文本模式，完整的可选编码格式列表见 standard-encodings        errors    当编码或者解码文件内容出现错误时的处理方式，仅适用于文本模式，常用的处理方式如下                            值          含义                                      strict          当出现编码错误时报 ValueError，默认值                          ignore          忽略错误                      完整的处理方式见 error-handlers        newline    该参数控制读和写的换行符，仅适用于文本模式，可选值及其作用如下：                            值          读操作时          写操作时                                      None          ‘\\n’、’\\r’ 和 ‘\\r\\n’ 都会被当作换行符，并且统一转换为 ‘\\n’          ‘\\n’ 会被转换为当前系统默认换行符，即 os.linesep                          ’’          ‘\\n’、’\\r’ 和 ‘\\r\\n’ 都会被当作换行符，但是均保持原样，不做转换          对换行符保持原样，不做转换                          ‘\\n’          只有 ‘\\n’ 会被当作换行符，但是不会做转换          对换行符保持原样，不做转换                          ‘\\r’          只有 ‘\\r’ 会被当作换行符，但是不会做转换          ‘\\n’ 会被转换为 ‘\\r’                          ‘\\r\\n’          只有 ‘\\r\\n’ 会被当作换行符，但是不会做转换          ‘\\n’ 会被转换为 ‘\\r\\n’                    ioopen 方法返回的所有对象都定义在 io 模块中，其类图如下：classDiagram    IOBase &amp;lt;|-- RawIOBase    RawIOBase &amp;lt;|-- FileIO    IOBase &amp;lt;|-- BufferedIOBase    BufferedIOBase &amp;lt;|-- BufferedReader    BufferedIOBase &amp;lt;|-- BufferedWriter    BufferedIOBase &amp;lt;|-- BufferedRWPair    BufferedIOBase &amp;lt;|-- BufferedRandom    BufferedIOBase &amp;lt;|-- BytesIO    IOBase &amp;lt;|-- TextIOBase    TextIOBase &amp;lt;|-- TextIOWrapper    TextIOBase &amp;lt;|-- StringIO    class IOBase{        +closed        +close()        +fileno()        +flush()        +isatty()        +readable()        +readline(size=-1)        +readlines(hint=-1)        +seek(offset[, whence])        +seekable()        +tell()        +truncate(size=None)        +writable()        +writelines(lines)    }    class RawIOBase{        +read(size=-1)        +readall()        +readinto(b)        +write(b)    }    class FileIO{        +mode        +name    }    class BufferedIOBase{        +raw        +detach()        +read(size=-1)        +read1(size=-1)        +readinto(b)        +readinto1(b)        +write(b)    }    class BufferedReader{        +peek([size])        +read([size])        +read1(size)    }    class BufferedWriter{        +flush()        +write(b)    }    class BytesIO{        +getbuffer()        +getvalue()        +read1()        +readinto1()    }    class TextIOBase{        +encoding        +errors        +newlines        +buffer        +detach()        +read(size)        +readline(size=-1)        +seek(offset[, whence])        +tell()        +write(s)    }    class TextIOWrapper{        +line_buffering    }    class StringIO{        +getvalue()    }open 方法在不同模式和缓存策略下返回的文件对象类型如下：            模式      buffering == 0      buffering != 0                  r      N/A      TextIOWrapper              w      N/A      TextIOWrapper              x      N/A      TextIOWrapper              a      N/A      TextIOWrapper              r+      N/A      TextIOWrapper              w+      N/A      TextIOWrapper              x+      N/A      TextIOWrapper              a+      N/A      TextIOWrapper              rb      FileIO      BufferedReader              wb      FileIO      BufferedWriter              xb      FileIO      BufferedWriter              ab      FileIO      BufferedWriter              rb+      FileIO      BufferedRandom              wb+      FileIO      BufferedRandom              xb+      FileIO      BufferedRandom              ab+      FileIO      BufferedRandom              rt      与 r 模式相同      与 r 模式相同              wt      与 w 模式相同      与 w 模式相同              xt      与 x 模式相同      与 x 模式相同              at      与 a 模式相同      与 a 模式相同              rt+      与 r+ 模式相同      与 r+ 模式相同              wt+      与 w+ 模式相同      与 w+ 模式相同              xt+      与 x+ 模式相同      与 x+ 模式相同              at+      与 a+ 模式相同      与 a+ 模式相同      文件读写示例通常文件读写的流程是先使用 open() 打开文件，然后进行读写操作，最后使用 close() 方法关闭文件：&amp;gt;&amp;gt;&amp;gt; f = open(&#39;testfile&#39;, &#39;r+&#39;)&amp;gt;&amp;gt;&amp;gt; f.read()&#39;hello&#39;&amp;gt;&amp;gt;&amp;gt; f.write(&#39;world&#39;)5&amp;gt;&amp;gt;&amp;gt; f.seek(0)0&amp;gt;&amp;gt;&amp;gt; f.read()&#39;helloworld&#39;&amp;gt;&amp;gt;&amp;gt; f.close()但是更推荐的方法是使用 with 子句来进行文件读写操作，这样在 with 结束后会自动关闭文件，避免因忘记关闭而占用文件的情况：&amp;gt;&amp;gt;&amp;gt; data = &#39;&#39;&amp;gt;&amp;gt;&amp;gt; with open(&#39;testfile&#39;) as f:...     data = f.read()...&amp;gt;&amp;gt;&amp;gt; f.closedTrue&amp;gt;&amp;gt;&amp;gt; data&#39;hello&#39;引用资料  [Input and Output] : https://docs.python.org/3.5/tutorial/inputoutput.html  [input] : https://docs.python.org/3.5/library/functions.html#input  [print] : https://docs.python.org/3.5/library/functions.html#print  [open] : https://docs.python.org/3.5/library/functions.html#open  [io] : https://docs.python.org/3.5/library/io.html#i-o-base-classes"
  },
  
  {
    "title": "Python 入门-8-函数定义",
    "url": "/posts/python-tutorial-8-function-definition/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-11-24 10:45:50 +0800",
    





    "snippet": "函数定义先看一个简单的函数定义的例子，以 def 语句开头，定义一个名为 add 的函数，接收两个参数 a 和 b，然后返回这两个参数的 和：&amp;gt;&amp;gt;&amp;gt; def add(a, b):...     return a + b...&amp;gt;&amp;gt;&amp;gt; add(1, 2)3&amp;gt;&amp;gt;&amp;gt;在 Python 中，一个定义好的函数可以把函数名赋值给其他变量，然后通过其他变量也可以调用该函数：&amp;gt;&amp;gt;&amp;gt; def add(a, b):...     return a + b...&amp;gt;&amp;gt;&amp;gt; plus = add&amp;gt;&amp;gt;&amp;gt; plus(1, 2)3&amp;gt;&amp;gt;&amp;gt;如果定义的函数体中没有明确使用 return 语句返回值，那么默认返回值是 None：&amp;gt;&amp;gt;&amp;gt; def nothing():...     pass...&amp;gt;&amp;gt;&amp;gt; r = nothing()&amp;gt;&amp;gt;&amp;gt; r is NoneTrue&amp;gt;&amp;gt;&amp;gt;函数参数参数默认值定义函数时可以指定参数的默认值，调用函数时可以不给默认参数传值，不传值则会使用默认值：## 定义一个有两个参数有默认值的函数&amp;gt;&amp;gt;&amp;gt; def introduce(name, age=18, city=&#39;beijing&#39;):...     print(&#39;My name is %s, I am %d years old and I am from %s&#39; % (name, age, city))...&amp;gt;&amp;gt;&amp;gt; introduce(&#39;tom&#39;)  # age 和 city 都使用默认值My name is tom, I am 18 years old and I am from beijing&amp;gt;&amp;gt;&amp;gt; introduce(&#39;liubei&#39;, city=&#39;chengdu&#39;)  # city 不使用默认值My name is liubei, I am 18 years old and I am from chengdu&amp;gt;&amp;gt;&amp;gt; introduce(&#39;sanmao&#39;, 30, &#39;chongqin&#39; )  # age 和 city 都不使用默认值My name is sanmao, I am 30 years old and I am from chongqin&amp;gt;&amp;gt;&amp;gt;需要注意的是如果参数默认值使用变量的话，那在函数定义时值就已经确定了，即使后面再改变变量的值不会影响参数的默认值：&amp;gt;&amp;gt;&amp;gt; i = 5&amp;gt;&amp;gt;&amp;gt; def f(arg=i):...     print(arg)...&amp;gt;&amp;gt;&amp;gt; f()5&amp;gt;&amp;gt;&amp;gt; i = 6&amp;gt;&amp;gt;&amp;gt; f()  # i 已经变为 6，但是 arg 参数的默认值仍然是 55&amp;gt;&amp;gt;&amp;gt;如果参数默认值是一个可变类型的话，可能会有一些意想不到的结果：&amp;gt;&amp;gt;&amp;gt; def f(a, L=[]):...     L.append(a)...     return L...&amp;gt;&amp;gt;&amp;gt; print(f(1))[1]&amp;gt;&amp;gt;&amp;gt; print(f(2))[1, 2]&amp;gt;&amp;gt;&amp;gt; print(f(3))  # 因为 L 是对一个列表的引用，多次调用都是操作的同一个列表[1, 2, 3]&amp;gt;&amp;gt;&amp;gt;## 如果想要避免上面的情况，应该像下面这样写&amp;gt;&amp;gt;&amp;gt; def f(a, L=None):...     if L is None:...         L = []...     L.append(a)...     return L...&amp;gt;&amp;gt;&amp;gt; print(f(1))[1]&amp;gt;&amp;gt;&amp;gt; print(f(2))[2]&amp;gt;&amp;gt;&amp;gt; print(f(3))[3]&amp;gt;&amp;gt;&amp;gt;*args 和 **kwargs有两种比较特殊的形式 *args 和 **kwargs 在函数定义和其他情况下使用时有着不同的作用，在函数定义时使用，相当于定义了个数不确定的参数：## 此函数的 nums 相当于是一个序列&amp;gt;&amp;gt;&amp;gt; def sum(*nums):...     s = 0...     for i in nums:...         s += i...     return s...## 调用时可以传入任意多个位置参数（按位置传入的参数即为位置参数）&amp;gt;&amp;gt;&amp;gt; sum(1) 1&amp;gt;&amp;gt;&amp;gt; sum(1, 2)3&amp;gt;&amp;gt;&amp;gt; sum(1, 2, 3)6&amp;gt;&amp;gt;&amp;gt; sum() 0&amp;gt;&amp;gt;&amp;gt;## 此函数的 kwargs 相当于一个字典&amp;gt;&amp;gt;&amp;gt; def fun(**kwargs):...     for k, v in kwargs.items():...         print(&#39;%s: %s&#39; % (k, v))...## 调用时可以传入任意多个关键字参数（以 name=value 形式传入的参数即为关键字参数）&amp;gt;&amp;gt;&amp;gt; fun(name=&#39;tom&#39;, age=18, city=&#39;beijing&#39;)name: tomage: 18city: beijing&amp;gt;&amp;gt;&amp;gt; fun()&amp;gt;&amp;gt;&amp;gt;当 *args 和 **kwargs 在其他地方使用时，其作用相当于对一个序列和字典进行 解包 操作：&amp;gt;&amp;gt;&amp;gt; def add(a, b):...     return a + b...&amp;gt;&amp;gt;&amp;gt; nums = [1, 2]&amp;gt;&amp;gt;&amp;gt; add(*nums)  # 函数调用时在 nums 前面加 * 相当于解包 nums3&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; def introduce(name, age):...     print(&#39;My name is %s, I am %d years old.&#39; % (name, age))...&amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 18}&amp;gt;&amp;gt;&amp;gt; introduce(**d)  # 函数调用时在字典 d 前面加 ** 相当于解包 dMy name is tom, I am 18 years old.&amp;gt;&amp;gt;&amp;gt;匿名函数（lambda）Python 中运行使用 lambda 语句定义一个匿名函数，通常用在只需要一行代码即可完成定义的函数：## 以下使用 lambda 定义一个匿名函数，函数有两个参数 a 和 b，函数体返回 a + b&amp;gt;&amp;gt;&amp;gt; add = lambda a, b: a + b&amp;gt;&amp;gt;&amp;gt; add(1, 2)3&amp;gt;&amp;gt;&amp;gt;函数文档字符串（docstr）定义函数时可以在文档字符串中对函数进行简介或详细说明，同时文档字符串还可以方便其他文档生成工具自动生成代码的函数说明文档。文档字符串在函数定义 def 语句的下一行开始写，以三个双引号（&quot;&quot;&quot;）进行包裹，可以是一行或多行：## 只有一行文档字符串进行简要介绍def add(a, b):    &quot;&quot;&quot;This is an add function.&quot;&quot;&quot;    return a + b## 多行文档字符串对函数进行详细说明def add(a, b):    &quot;&quot;&quot;This is an add function.    :param a: number a    :type a: int    :param b: number b    :type b: int    :return: The sum of a and b.    &quot;&quot;&quot;    return a + b函数注解（Function Annotations）从 Python3 开始支持定义函数时使用 注解 方式说明参数和返回值类型：## 使用注解说明参数 a, b 和返回值类型都是 int&amp;gt;&amp;gt;&amp;gt; def add(a: int, b: int) -&amp;gt; int:...     return a + b...&amp;gt;&amp;gt;&amp;gt; add(1, 2)3&amp;gt;&amp;gt;&amp;gt;更多关于函数注解说明可以参考 PEP 484引用资料  [Defining Functions] : https://docs.python.org/3.5/tutorial/controlflow.html#defining-functions  [More on Defining Functions] : https://docs.python.org/3.5/tutorial/controlflow.html#more-on-defining-functions  [Function definitions] : https://docs.python.org/3.5/reference/compound_stmts.html#function-definitions  [PEP 484] : https://www.python.org/dev/peps/pep-0484/"
  },
  
  {
    "title": "Python 入门-7-流程控制",
    "url": "/posts/python-tutorial-7-flow-control/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-10-18 15:58:25 +0800",
    





    "snippet": "ifif 是条件控制语句，其语法定义如下：if_stmt ::=  &quot;if&quot; expression &quot;:&quot; suite             ( &quot;elif&quot; expression &quot;:&quot; suite )*             [&quot;else&quot; &quot;:&quot; suite]if 是固定格式，当 if 后面的 expression 为 真 时执行其后面的 suite，然后可以在后面接 0 或任意多个 elif 语句，最后一条 else 语句为 可选。&amp;gt;&amp;gt;&amp;gt; x = 8&amp;gt;&amp;gt;&amp;gt; if x &amp;lt; 0:...     print(&#39;negative&#39;)... elif x == 0:...     print(&#39;zero&#39;)... else:...     print(&#39;positive&#39;)... positive&amp;gt;&amp;gt;&amp;gt; Python 中没有像 C 语言的 switch...case 这样的结构，因为使用 elif 就能达到这样的效果。真值计算对于 if 语句后面的表达式 expression 的计算结果，除了以下几种情况为 假 之外，其他情况均为 真：  None  False  数字类型零：0, 0.0, 0j  空序列：&#39;&#39;, (), []  空字典：{}  如果是用户自定义类，然后实现了 __bool__ 或 __len__ 方法，并且其返回结果为 False 或者 0，那么也被当作 假## None&amp;gt;&amp;gt;&amp;gt; if None:...     print(&#39;should not print&#39;)... else:...     print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt; ## 整数0&amp;gt;&amp;gt;&amp;gt; if 0:...     print(&#39;should not print&#39;)... else:...     print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt;## 空字符串&amp;gt;&amp;gt;&amp;gt; if &#39;&#39;:...     print(&#39;should not print&#39;)... else:...     print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt; ## 空字典&amp;gt;&amp;gt;&amp;gt; if {}:...     print(&#39;should not print&#39;)... else:...     print(&#39;should print&#39;)... should print&amp;gt;&amp;gt;&amp;gt; 布尔运算符有时在 if 后面的 expression 中会是一个由 布尔运算符 连接多个部分所组成的表达式，比如：&amp;gt;&amp;gt;&amp;gt; p = &#39;/home/user1/&#39;&amp;gt;&amp;gt;&amp;gt; if p.startswith(&#39;/&#39;) and p.endswith(&#39;/&#39;):...     print(&#39;The absolute path of a directory&#39;)... The absolute path of a directory&amp;gt;&amp;gt;&amp;gt; 对于包含 布尔运算符 的表达式的真假值判断遵循以下规范：            操作符      结果                  x or y      如果 x 为假，则结果为 y，否则为 x              x and y      如果 x 为假，则结果为 x，否则为 y              not x      如果 x 为假，则结果为 True，否则为 False      (1) or 是一个 短路运算符，只有当 x 为 假 时才会计算 y。(2) and 也是一个 短路运算符，只有当 x 为 真 时才会计算 y。(3) 这 3 个布尔运算符的优先级关系为：not &amp;gt; and &amp;gt; or&amp;gt;&amp;gt;&amp;gt; 1 or 21&amp;gt;&amp;gt;&amp;gt; 0 or 22&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; 1 and 22&amp;gt;&amp;gt;&amp;gt; 0 and 10比较运算符比较运算符也常用于 if 后面的 expression 表达式，比较运算符总是返回 bool 类型的结果，即 True 或 Flase，所有比较运算符如下：            运算符      说明                  &amp;lt;      小于              &amp;lt;=      小于等于              &amp;gt;      大于              &amp;gt;=      大于等于              ==      等于              !=      不等于              is      判断是否是某个对象              is not      判断是否不是某个对象      forfor 语句的定义如下：for_stmt ::=  &quot;for&quot; target_list &quot;in&quot; expression_list &quot;:&quot; suite              [&quot;else&quot; &quot;:&quot; suite]Python 中的 for 循环只有 for...in 的形式，它遍历序列 expression_list，每次遍历取出的元素赋值给 target_list，第一个 suite 是循环体，然后还可以使用一个 else 子句，else 只有在 for 循环正常结束之后才会执行，如果在 for 循环中被 break 打断了，则会跳过 else 子句。## 遍历一个 list&amp;gt;&amp;gt;&amp;gt; for c in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]:...     print(c)... abc&amp;gt;&amp;gt;&amp;gt; ## 如果想要类似 C 语言中的 for 循环，可以使用 range## 关于 range 的详细说明可参考前面《列表与元组》章节&amp;gt;&amp;gt;&amp;gt; for i in range(5):...     print(i)... 01234&amp;gt;&amp;gt;&amp;gt; ## 如果使用了 else 子句，那么会在循环正常结束后再执行 else 子句&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; for i in (1, 2, 3):...     sum += i... else:...     print(&#39;sum = %d&#39; % sum)... sum = 6&amp;gt;&amp;gt;&amp;gt; ## 如果 for 循环体中使用了 break，那么则不会执行 else 子句&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; for i in (1, 2, 3):...     sum += i...     if i == 2:...         break... else:...     print(&#39;sum = %d&#39; % sum)... &amp;gt;&amp;gt;&amp;gt; print(sum)3&amp;gt;&amp;gt;&amp;gt; 如果需要在 for 循环时同时取序列中元素的下标和值，可以使用 enumerate 函数：&amp;gt;&amp;gt;&amp;gt; for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):...     print(i, v)...0 tic1 tac2 toe如果需要在 for 循环遍历一个序列的同时修改该序列，建议是对该序列做一个拷贝然后再遍历该拷贝，如果不用拷贝的方式，直接在遍历该序列的同时修改该序列，可能会出现一些不可意料的情况：## 想要去除 nums 中的偶数&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 4, 3]&amp;gt;&amp;gt;&amp;gt; for n in nums:...     if n % 2 == 0:...         nums.remove(n)... &amp;gt;&amp;gt;&amp;gt; nums## python 在循环时内部会有一个计数器记录当前循环下标(从 0 开始)，并且每次自动加 1## 所以当循环到元素 2 时，记录的当前下标为 1，然后判断 2 为偶数并移除了它，然后后面## 的元素依次往前挪一位，当进入下一次循环时自动取下标为 2 的元素，则取到了元素 3，这## 样就把元素 4 给漏掉了。[1, 4, 3]&amp;gt;&amp;gt;&amp;gt; ## 这种情况一般建议拷贝一份序列后再对其进行遍历&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 4, 3]&amp;gt;&amp;gt;&amp;gt; for n in nums.copy():...     if n % 2 == 0:...         nums.remove(n)... &amp;gt;&amp;gt;&amp;gt; nums[1, 3]&amp;gt;&amp;gt;&amp;gt;## 还可以使用切片方式 nums[:] 创建一个拷贝，比 copy 的方式更简洁&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 4, 3]&amp;gt;&amp;gt;&amp;gt; for n in nums[:]:...     if n % 2 == 0:...         nums.remove(n)... &amp;gt;&amp;gt;&amp;gt; nums[1, 3]&amp;gt;&amp;gt;&amp;gt; 使用 for 循环对字典遍历时默认遍历其 key，但是也可以使用字典的 .items() 方法同时遍历其 key 和 value，或者使用字典的 .values() 方法只遍历其 value：## 遍历字典的 key&amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 18}&amp;gt;&amp;gt;&amp;gt; for k in d:...     print(k)... nameage&amp;gt;&amp;gt;&amp;gt; ## 同时遍历 key 和 value&amp;gt;&amp;gt;&amp;gt; for k, v in d.items():...     print(k, v)... name tomage 18&amp;gt;&amp;gt;&amp;gt; ## 只遍历 value&amp;gt;&amp;gt;&amp;gt; for v in d.values():...     print(v)... tom18&amp;gt;&amp;gt;&amp;gt; 如果需要使用 for 循环同时遍历多个长度相同的序列时可以使用 zip 函数：## 同时遍历 2 个序列&amp;gt;&amp;gt;&amp;gt; keys = [&#39;name&#39;, &#39;age&#39;]&amp;gt;&amp;gt;&amp;gt; values = [&#39;tom&#39;, 18]&amp;gt;&amp;gt;&amp;gt; for k, v in zip(keys, values):...     print(k, v)... name tomage 18&amp;gt;&amp;gt;&amp;gt; ## 同时遍历 3 个序列&amp;gt;&amp;gt;&amp;gt; for i, j, k in zip([1, 2], [3, 4], [5, 6]):...     print(i, j, k)... 1 3 52 4 6&amp;gt;&amp;gt;&amp;gt; 如果需要使用 for 循环反向遍历一个序列时，可以使用 reversed 函数：&amp;gt;&amp;gt;&amp;gt; for i in reversed([1, 2, 3]):...     print(i)... 321&amp;gt;&amp;gt;&amp;gt; whilewhile 语句的定义如下：while_stmt ::=  &quot;while&quot; expression &quot;:&quot; suite                [&quot;else&quot; &quot;:&quot; suite]当表达式 expression 为 真 时执行 suite，后边还可以跟一个可选的 else 子句，当表达式 expression 为 假 时执行 else 子句中的 suite，如果在第一个 suite 中执行了 break，则退出循环，并且不会执行 else 子句。## 使用 while 循环计算 1 ~ 10 的和&amp;gt;&amp;gt;&amp;gt; i = 1&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:...     sum += i...     i += 1... &amp;gt;&amp;gt;&amp;gt; sum55&amp;gt;&amp;gt;&amp;gt; ## else 子句在 while 的 expression 为假时执行&amp;gt;&amp;gt;&amp;gt; i = 1&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:...     sum += i...     i += 1... else:...     print(&#39;loops over&#39;)... loops over&amp;gt;&amp;gt;&amp;gt; sum55## while 的循环体中执行了 break，所以子句 else 被跳过不执行&amp;gt;&amp;gt;&amp;gt; i = 1&amp;gt;&amp;gt;&amp;gt; sum = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:...     sum += i...     i += 1...     if i == 9:...         break... else:...     print(&#39;loop over&#39;)... &amp;gt;&amp;gt;&amp;gt; sum36&amp;gt;&amp;gt;&amp;gt; breakbreak 语句用于 for 或者 while 循环体中，执行后直接退出循环，并且不会执行循环的 else 子句，具体示例请见上面的 for 和 while 小节内容，这里不再重复举例。continuecontinue 语句用在 for 或者 while 循环体中，跳过本次循环中后续的内容，然后进入下一次循环，它不会结束整个循环，并且不影响循环的 else 子句。## 使用 continue 跳过 for 循环中偶数的打印步骤，并且不会影响到 else 子句&amp;gt;&amp;gt;&amp;gt; for i in range(1, 11):...     if i % 2 == 0:...         continue...     print(i)... else:...     print(&#39;loops over&#39;)... 13579loops over&amp;gt;&amp;gt;&amp;gt; ## 使用 continue 跳过 while 循环中偶数的打印步骤，并且不会影响到 else 子句&amp;gt;&amp;gt;&amp;gt; i = 0&amp;gt;&amp;gt;&amp;gt; while i &amp;lt;= 10:...     i += 1...     if i % 2 == 0:...         continue...     print(i)... else:...     print(&#39;loops over&#39;)... 1357911loops over&amp;gt;&amp;gt;&amp;gt; passpass 语句不做任何事情，通常用于一些在语法上需要写内容，但是实际没有内容可写的情况下进行占位。## 自定义异常类class MyException(Exception):    pass## 先定好函数名，函数体还需进一步思考后编写def myfun():    pass引用资料  [More Control Flow Tools] : https://docs.python.org/3.5/tutorial/controlflow.html  [Truth Value Testing] : https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing  [Boolean Operations] : https://docs.python.org/3.5/library/stdtypes.html#boolean-operations-and-or-not  [Comparisons] : https://docs.python.org/3.5/library/stdtypes.html#comparisons  [The if statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-if-statement  [The while statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-while-statement  [The for statement] : https://docs.python.org/3.5/reference/compound_stmts.html#the-for-statement"
  },
  
  {
    "title": "Python 入门-6-字典与集合",
    "url": "/posts/python-tutorial-6-dict-and-set/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-08-06 10:31:58 +0800",
    





    "snippet": "字典（dict）字典通过 键值对(key: value) 的方式，把 key 映射到 value。key 必须是 可 hash 的(hashable)，由于 Python 中所有内置的 不可变类型(immutable) 都是可 hash 的，所以都可用作字典的 key，比如 字符串(str)、数字(int, float) 和 只包含不可变类型元素的元组(tuple)，如果元组直接或间接的包含了 可变类型 的元素，也不能作为字典的 key。value 则可以是任意类型。字典中元素是无序的，并不会按照插入的顺序排列，可能会是任意的顺序，如果想要有序的字典，可以使用 collections.OrderedDict。但是从 Python 3.7 开始，字典默认是按照插入顺序排序的了。字典创建创建一个字典可以通过以下 3 种方式：      大括号 {} 方式：      &amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;lilei&#39;, &#39;age&#39;: 18}  &amp;gt;&amp;gt;&amp;gt; d  {&#39;age&#39;: 18, &#39;name&#39;: &#39;lilei&#39;}            dict 关键字方式：    dict 的定义如下：      class dict(**kwarg)  class dict(mapping, **kwarg)  class dict(iterable, **kwarg)        根据定义 dict 接受如下形式的参数进行初始化：      &amp;gt;&amp;gt;&amp;gt; dict(one=1, two=2)   # 关键字参数形式(**kwargs)  {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; dict({&#39;one&#39;: 1, &#39;two&#39;: 2})  # 字典形式(mapping)  {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; dict([(&#39;one&#39;, 1), [&#39;two&#39;, 2]])  # 可迭代类型中内嵌2个元素的可迭代类型(iterable)  {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; dict({&#39;one&#39;: 1}, two=2)  # 字典+关键字参数形式(mapping + **kwargs)  {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; dict([(&#39;one&#39;, 1)], two=2)  # 可迭代类型+关键字参数形式(iterable + **kwargs)  {&#39;one&#39;: 1, &#39;two&#39;: 2}            字典推导式(dict comprehension)：      &amp;gt;&amp;gt;&amp;gt; {x: x**2 for x in (2, 4, 6)}  {2: 4, 4: 16, 6: 36}      字典操作      len(d)    返回字典 d 的长度，即包含多少个键值对      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; len(d)  2            d[key]    返回 key 对应的 value，如果 key 不存在，则抛出 KeyError 异常      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d[&#39;one&#39;]  1  &amp;gt;&amp;gt;&amp;gt; d[&#39;three&#39;]  Traceback (most recent call last):      File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  KeyError: &#39;three&#39;            d[key] = value    设置 key 对应的 value，如果 key 不存在则自动添加      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d[&#39;two&#39;] = 2.0  &amp;gt;&amp;gt;&amp;gt; d[&#39;three&#39;] = 3  &amp;gt;&amp;gt;&amp;gt; d  {&#39;one&#39;: 1, &#39;two&#39;: 2.0, &#39;three&#39;: 3}            del d[key]    删除 key 对应的项，如果 key 不存在则抛出 KeyError 异常      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; del d[&#39;two&#39;]  &amp;gt;&amp;gt;&amp;gt; d  {&#39;one&#39;: 1}            pop(key[, default])    删除 key 对应的项并且返回对应的 value，如果 key 不存在并且传入了 default 参数，那么返回 default，否则抛出 KeyError 异常      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d.pop(&#39;two&#39;)  2  &amp;gt;&amp;gt;&amp;gt; d.pop(&#39;three&#39;, 0)  # 不存在 key 为 &#39;three&#39; 的项则返回 0  0  &amp;gt;&amp;gt;&amp;gt; d  {&#39;one&#39;: 1}            popitem()    任意删除并返回一个项，由于字典是无序的，所以删除的项是不确定的      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d.popitem()  (&#39;one&#39;, 1)  &amp;gt;&amp;gt;&amp;gt; d  {&#39;two&#39;: 2}        从 Python 3.7 开始字典是有序的（按照插入顺序排序），所以 popitem() 会按照 LIFO 规则删除，即相当于删除最后一个项        key in d    如果 key 存在于字典 d 中，则返回 True，否则返回 False      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; &#39;one&#39; in d  True  &amp;gt;&amp;gt;&amp;gt; &#39;three&#39; in d  False            key not in d    如果 key 不存在于字典 d 中，则返回 True，否则返回 False      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; &#39;one&#39; not in d  False  &amp;gt;&amp;gt;&amp;gt; &#39;three&#39; not in d  True            iter(d)    返回一个包含字典 d 的所有 key 的迭代器（iterator）      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; for k in iter(d):  ...     print(k)  ...  one  two            clear()    清空字典      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d.clear()  &amp;gt;&amp;gt;&amp;gt; d  {}            copy()    返回字典的 浅拷贝，关于 浅拷贝 与 深拷贝 可以参考 《列表与元组》 章节      &amp;gt;&amp;gt;&amp;gt; d1 = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d2 = d1.copy()  &amp;gt;&amp;gt;&amp;gt; d2  {&#39;one&#39;: 1, &#39;two&#39;: 2}            classmethod fromkeys(seq[, value])    返回一个新的字典，字典的 keys 来自参数 seq，并且所有 key 的 value 为参数 value，value 参数默认值为 None。  这是一个 类方法，用于以其他形式创建字典。      &amp;gt;&amp;gt;&amp;gt; dict.fromkeys([&#39;three&#39;, &#39;four&#39;])  {&#39;four&#39;: None, &#39;three&#39;: None}  &amp;gt;&amp;gt;&amp;gt; dict.fromkeys([&#39;three&#39;, &#39;four&#39;], 0)  # 初始值为 0  {&#39;four&#39;: 0, &#39;three&#39;: 0}  &amp;gt;&amp;gt;&amp;gt;            get(key[, default])    返回 key 对应的 value，如果 key 不存在则返回 default，default 默认为 None      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d.get(&#39;one&#39;)  1  &amp;gt;&amp;gt;&amp;gt; d.get(&#39;three&#39;, 0)  # 不存在则返回 0  0            items()    返回一个包含所有项的 字典视图(view)，每一项是一个 2 个元素的 tuple，分别为 key 和 value      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; for k, v in d.items():  ...     print(&#39;%s = %s&#39; % (k, v))  ...  one = 1  two = 2            keys()    返回一个包含所有 key 的 字典视图(view)      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; for k in d.keys():  ...     print(k)  ...  one  two            values()    返回一个包含所有 value 的 字典视图(view)      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; for v in d.values():  ...     print(v)  ...  1  2            setdefault(key[, default])    如果 key 存在于字典中，则返回其对应的 value，否则插入 key ，并且将其 value 设置为 default，default 默认为 None      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d.setdefault(&#39;two&#39;)  2  &amp;gt;&amp;gt;&amp;gt; d.setdefault(&#39;three&#39;, 3)  3  &amp;gt;&amp;gt;&amp;gt; d  {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}            update([other])    更新字典中的项，可接受参数类型与 dict 关键字一样      &amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}  &amp;gt;&amp;gt;&amp;gt; d.update({&#39;two&#39;: 2.0, &#39;three&#39;: 3})  # mapping 形式  &amp;gt;&amp;gt;&amp;gt; d  {&#39;one&#39;: 1, &#39;two&#39;: 2.0, &#39;three&#39;: 3}  &amp;gt;&amp;gt;&amp;gt; d.update([(&#39;three&#39;, 3.0), (&#39;four&#39;, 4)])  # iterable 形式  &amp;gt;&amp;gt;&amp;gt; d  {&#39;one&#39;: 1, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;four&#39;: 4}  &amp;gt;&amp;gt;&amp;gt; d.update(five=5, six=6)  # **kwargs 形式  &amp;gt;&amp;gt;&amp;gt; d  {&#39;four&#39;: 4, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;six&#39;: 6, &#39;one&#39;: 1, &#39;five&#39;: 5}  &amp;gt;&amp;gt;&amp;gt; d.update({&#39;six&#39;: 6.0}, seven=7)  # mapping + **kwargs 形式  &amp;gt;&amp;gt;&amp;gt; d  {&#39;four&#39;: 4, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;six&#39;: 6.0, &#39;one&#39;: 1, &#39;seven&#39;: 7, &#39;five&#39;: 5}  &amp;gt;&amp;gt;&amp;gt; d.update([(&#39;one&#39;, 1.0), (&#39;four&#39;, 4.0)], five=5.0, seven=7.0)  # iterable + **kwargs 形式  &amp;gt;&amp;gt;&amp;gt; d  {&#39;four&#39;: 4.0, &#39;two&#39;: 2.0, &#39;three&#39;: 3.0, &#39;six&#39;: 6.0, &#39;one&#39;: 1.0, &#39;seven&#39;: 7.0, &#39;five&#39;: 5.0}      字典视图上面提到的 d.keys()、d.values() 和 d.items() 等方法返回的都是一个 视图类型(view object)，通过这些视图可以访问字典 d 的 keys、values 或 items，并且视图会随着字典的变化而自动更新。&amp;gt;&amp;gt;&amp;gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2}&amp;gt;&amp;gt;&amp;gt; keys = d.keys()&amp;gt;&amp;gt;&amp;gt; values = d.values()&amp;gt;&amp;gt;&amp;gt; items = d.items()&amp;gt;&amp;gt;&amp;gt; keysdict_keys([&#39;one&#39;, &#39;two&#39;])&amp;gt;&amp;gt;&amp;gt; valuesdict_values([1, 2])&amp;gt;&amp;gt;&amp;gt; itemsdict_items([(&#39;one&#39;, 1), (&#39;two&#39;, 2)])## 视图随着字典变化而动态更新&amp;gt;&amp;gt;&amp;gt; d.update(three=3)&amp;gt;&amp;gt;&amp;gt; keysdict_keys([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;])&amp;gt;&amp;gt;&amp;gt; valuesdict_values([1, 2, 3])&amp;gt;&amp;gt;&amp;gt; itemsdict_items([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])## 可以对视图进行迭代(iteration)&amp;gt;&amp;gt;&amp;gt; for k in keys:...     print(k)...onetwothree字典比较字典只支持 == 比较操作符，当且仅当所有项都相等时才相等。对于 &amp;lt;、&amp;gt;、&amp;lt;= 和 &amp;gt;= 比较操作符都不支持，如果使用会抛 TypeError 错误。集合（set）集合(set) 是一些 无序(unordered)、无重复(no duplicate) 并且 可hash(hashable) 元素的组合。通常用于 是否包含某个成员的检测、去除重复元素 等操作。同时也支持数学上的集合运算，比如 交集(intersection)、并集(union)、差集(difference) 和 对称差集(symmetric difference)。Python 内置两种类型集合，set 和 frozenset，set 是可变类型(mutable)，frozenset 是不可变类型(immutable)。集合创建集合创建可以通过以下 3 种方式：      大括号 {} 方式：      &amp;gt;&amp;gt;&amp;gt; s = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;}  &amp;gt;&amp;gt;&amp;gt; s  {&#39;c&#39;, &#39;b&#39;, &#39;a&#39;}  # 相等元素只保留第一个            set 或 frozenset 关键字方式：    set 和 frozenset 的定义如下：      class set([iterable])  class frozenset([iterable])        根据以上定义可以通过下面的方式创建集合：      &amp;gt;&amp;gt;&amp;gt; s = set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])  &amp;gt;&amp;gt;&amp;gt; fs = frozenset([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])  &amp;gt;&amp;gt;&amp;gt; s  {&#39;c&#39;, &#39;b&#39;, &#39;a&#39;}  &amp;gt;&amp;gt;&amp;gt; fs  frozenset({&#39;c&#39;, &#39;b&#39;, &#39;a&#39;})  &amp;gt;&amp;gt;&amp;gt; s.add(&#39;d&#39;)  # set 是可变类型  &amp;gt;&amp;gt;&amp;gt; s  {&#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;}  &amp;gt;&amp;gt;&amp;gt; fs.add(&#39;d&#39;)  # frozenset 是不可变类型  Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39;  &amp;gt;&amp;gt;&amp;gt;            集合推导式(set comprehension):      &amp;gt;&amp;gt;&amp;gt; {x for x in range(1, 11)}  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}      集合中的元素必须是 可hash的(hashable)## str、numeric 和 tuple 类型都是可hash的&amp;gt;&amp;gt;&amp;gt; {&#39;one&#39;, 2, (3, 4)}{&#39;one&#39;, 2, (3, 4)}## list 是 unhashable 类型&amp;gt;&amp;gt;&amp;gt; {1, [2]}Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: unhashable type: &#39;list&#39;## 间接包含 unhashable 类型也不行&amp;gt;&amp;gt;&amp;gt; {1, (2, [3])}Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: unhashable type: &#39;list&#39;如果要创建空集合，必须使用 set 或 frozenset 关键字，不能使用大括号，因为 {} 创建的是一个空字典。&amp;gt;&amp;gt;&amp;gt; s = set()&amp;gt;&amp;gt;&amp;gt; sset()&amp;gt;&amp;gt;&amp;gt; fs = frozenset()&amp;gt;&amp;gt;&amp;gt; fsfrozenset()&amp;gt;&amp;gt;&amp;gt; d = {}&amp;gt;&amp;gt;&amp;gt; d{}&amp;gt;&amp;gt;&amp;gt; type(d)&amp;lt;class &#39;dict&#39;&amp;gt;集合操作以下是 set 和 frozenset 都支持的操作：      len(s)    返回结合中元素的个数      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; len(s)  2            x in s    判断 x 是否被包含于集合 s 中      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; 1 in s  True  &amp;gt;&amp;gt;&amp;gt; 3 in s  False            x not in s    判断 x 是否不被包含于集合 s 中      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; 1 not in s  False  &amp;gt;&amp;gt;&amp;gt; 3 not in s  True            isdisjoint(other)    判断当前集合是否与其他集合 other 没有交集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.isdisjoint({3, 4})  True  &amp;gt;&amp;gt;&amp;gt; s.isdisjoint({2, 3})  False            issubset(other)set &amp;lt;= other    判断当前集合是否为其他集合 other 的 子集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {1, 2, 3}  &amp;gt;&amp;gt;&amp;gt; s.issubset(other)  True  &amp;gt;&amp;gt;&amp;gt; s &amp;lt;= other  True  &amp;gt;&amp;gt;&amp;gt; other = {1, 4, 3}  &amp;gt;&amp;gt;&amp;gt; s.issubset(other)  False  &amp;gt;&amp;gt;&amp;gt; s &amp;lt;= other  False            set &amp;lt; other    判断当前集合是否为其他集合 other 的 真子集      &amp;gt;&amp;gt;&amp;gt; {1, 2} &amp;lt; {1, 2, 3}  True  &amp;gt;&amp;gt;&amp;gt; {1, 2} &amp;lt; {1, 2}  False            issuperset(other)set &amp;gt;= other    判断当前集合是否为其他集合 other 的 超集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2, 3}  &amp;gt;&amp;gt;&amp;gt; other = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.issuperset(other)  True  &amp;gt;&amp;gt;&amp;gt; s &amp;gt;= other  True            set &amp;gt; other    判断当前集合是否其他集合 other 的 真超集      &amp;gt;&amp;gt;&amp;gt; {1, 2, 3} &amp;gt; {1, 2}  True  &amp;gt;&amp;gt;&amp;gt; {1, 2} &amp;gt; {1, 2}  False            union(*others)set | other | …    当前集合与其他一个或多个集合求 并集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.union(other)  {1, 2, 3}  &amp;gt;&amp;gt;&amp;gt; s | other  {1, 2, 3}            intersection(*others)set &amp;amp; other &amp;amp; …    当前集合与其他一个或多个集合求 交集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.intersection(other)  {2}  &amp;gt;&amp;gt;&amp;gt; s &amp;amp; other  {2}            difference(*others)set - other - …    当前集合与其他一个或多个集合求 差集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.difference(other)  {1}  &amp;gt;&amp;gt;&amp;gt; s - other  {1}            symmetric_difference(other)set ^ other    当前集合与其他集合 other 求 对称差集      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s ^ other  {1, 3}  &amp;gt;&amp;gt;&amp;gt; s.symmetric_difference(other)  {1, 3}            copy()    返回当前集合的一个 浅拷贝      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.copy()  {1, 2}      需要注意的是以上的 比较方法 union()、intersection()、difference()、symmetric_difference()、issubset() 和 issuperset()，接受的参数除了集合类型外，还可以是 可迭代类型(iterable)。相比之下，对应的 比较运算符 则只能接受集合类型参数。&amp;gt;&amp;gt;&amp;gt; {1, 2}.union([3, 4])  # union 方法可以接受 iterable 类型{1, 2, 3, 4}&amp;gt;&amp;gt;&amp;gt; {1, 2} | [3, 4]  # | 运算符不能接受 iterable 类型Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: unsupported operand type(s) for |: &#39;set&#39; and &#39;list&#39;以下是只有 set 支持的操作：      update(*others)set |= other | …    将当前集合与其他一个或多个集合求 并集 然后更新到当前集合      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.update(other)  &amp;gt;&amp;gt;&amp;gt; s  {1, 2, 3}  &amp;gt;&amp;gt;&amp;gt; s |= {3, 4}  &amp;gt;&amp;gt;&amp;gt; s  {1, 2, 3, 4}            intersection_update(*others)set &amp;amp;= other &amp;amp; …    将当前集合与其他一个或多个集合求 交集 然后更新到当前集合      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.intersection_update(other)  &amp;gt;&amp;gt;&amp;gt; s  {2}  &amp;gt;&amp;gt;&amp;gt; s &amp;amp;= {3, 4}  &amp;gt;&amp;gt;&amp;gt; s  set()            difference_update(*others)set -= other | …    将当前集合与其他一个或多个集合求 差集 然后更新到当前集合      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.difference_update(other)  &amp;gt;&amp;gt;&amp;gt; s  {1}  &amp;gt;&amp;gt;&amp;gt; s -= {3, 4}  &amp;gt;&amp;gt;&amp;gt; s  {1}            symmetric_difference_update(other)set ^= other    将当前集合与其他集合 other 求 对称差集 然后更新到当前集合      &amp;gt;&amp;gt;&amp;gt; other = {2, 3}  &amp;gt;&amp;gt;&amp;gt; s.symmetric_difference_update(other)  &amp;gt;&amp;gt;&amp;gt; s  {1, 3}  &amp;gt;&amp;gt;&amp;gt; s ^= {3, 4}  &amp;gt;&amp;gt;&amp;gt; s  {1, 4}            add(elem)    添加一个元素 elem 到当前集合      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.add(3)  &amp;gt;&amp;gt;&amp;gt; s  {1, 2, 3}            remove(elem)    从当前集合删除元素 elem ，如果 elem 不存在则抛 KeyError 异常      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.remove(2)  &amp;gt;&amp;gt;&amp;gt; s  {1}  &amp;gt;&amp;gt;&amp;gt; s.remove(2)  Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  KeyError: 2            discard(elem)    从当前集合删除元素 elem ，如果 elem 不存在也不抛异常      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.discard(2)  &amp;gt;&amp;gt;&amp;gt; s  {1}  &amp;gt;&amp;gt;&amp;gt; s.discard(2)  &amp;gt;&amp;gt;&amp;gt; s  {1}            pop()    从当前集合任意删除一个元素并返回，由于集合是无序的，所以删除哪个元素不确定，如果当前集合为空，则抛 KeyError 异常      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.pop()  1  &amp;gt;&amp;gt;&amp;gt; s.pop()  2  &amp;gt;&amp;gt;&amp;gt; s.pop()  Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  KeyError: &#39;pop from an empty set&#39;            clear()    清空当前集合      &amp;gt;&amp;gt;&amp;gt; s = {1, 2}  &amp;gt;&amp;gt;&amp;gt; s.clear()  &amp;gt;&amp;gt;&amp;gt; s  set()      同样的以上的 update()、intersection_update()、difference_update() 和 symmetric_difference_update() 也接受可迭代类型参数，但是对应的 运算符 则只能接受集合类型参数。immutable 与 hashablePython 中不可变类型 immutable 都是 hashable 类型的，但是 hashable 类型并不一定都是 immutable 的，因为默认所有 自定义类的实例 都是 hashable 类型的，其 hash 值通常就是 id() 函数的计算结果，由于用户自定义类不一定是不可变类型的，所以 hashable 类型不一定都是 immutable 类型。关于 hashable 可参考：https://docs.python.org/3.5/glossary.html#term-hashable关于 immutable 可参考：https://docs.python.org/3.5/glossary.html#term-immutable引用资料  [Sets] : https://docs.python.org/3.5/tutorial/datastructures.html#sets  [Dictionaries] : https://docs.python.org/3.5/tutorial/datastructures.html#dictionaries  [Set Types — set, frozenset] : https://docs.python.org/3.5/library/stdtypes.html#set-types-set-frozenset  [Mapping Types — dict] : https://docs.python.org/3.5/library/stdtypes.html#mapping-types-dict"
  },
  
  {
    "title": "Python 入门-5-列表与元组",
    "url": "/posts/python-tutorial-5-list-and-tuple/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-07-15 15:16:00 +0800",
    





    "snippet": "序列（Sequence）在前面已经介绍过的 字符串(str)，以及接下来要学习的 列表(list) 和 元组(tuple) 都属于 序列(Sequence) 类型。序列又分为 可变序列(mutable) 和 不可变序列(immutable)，可变指的是可修改序列的元素，列表属于可变序列，字符串和元组都属于不可变序列。## 列表使用中括号表示&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]&amp;gt;&amp;gt;&amp;gt; type(nums)&amp;lt;class &#39;list&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; nums[1] = 0  # 列表是可变序列&amp;gt;&amp;gt;&amp;gt; nums[1, 0, 3]## 元组使用圆括号表示&amp;gt;&amp;gt;&amp;gt; seqs = (4, 5, 6)&amp;gt;&amp;gt;&amp;gt; type(seqs)&amp;lt;class &#39;tuple&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt; seqs[1] = 0  # 元组是不可变序列Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: &#39;tuple&#39; object does not support item assignment&amp;gt;&amp;gt;&amp;gt; seqs(4, 5, 6)序列操作序列类型支持的一些通用操作（即可变和不可变序列均支持）如下表：            Operation      Result                  x in s      如果 s 中的某项等于 x 则结果为 True，否则为 False              x not in s      如果 s 中的某项等于 x 则结果为 False，否则为 True              s + t      s 与 t 相拼接              s * n 或 n * s      相当于 s 与自身进行 n 次拼接              s[i]      s 的第 i 项，起始为 0              s[i:j]      s 从 i 到 j 的切片              s[i:j:k]      s 从 i 到 j 步长为 k 的切片              len(s)      s 的长度              min(s)      s 的最小项              max(s)      s 的最大项              s.index(x[, i[, j]])      x 在 s 中首次出现项的索引号（索引号在 i 或其后且在 j 之前）              s.count(x)      x 在 s 中出现的总次数      下面对以上操作进行示例演示：      x in s      &amp;gt;&amp;gt;&amp;gt; 1 in [1, 2, 3]  True  &amp;gt;&amp;gt;&amp;gt; 4 in [1, 2, 3]  False            x not in s      &amp;gt;&amp;gt;&amp;gt; 4 not in (1, 2, 3)  True  &amp;gt;&amp;gt;&amp;gt; &#39;a&#39; not in &#39;abc&#39;  False            s + t      &amp;gt;&amp;gt;&amp;gt; [1, 2] + [3, 4]  [1, 2, 3, 4]  &amp;gt;&amp;gt;&amp;gt; (5, 6) + (7, 8)  (5, 6, 7, 8)            s * n 或 n * s      &amp;gt;&amp;gt;&amp;gt; [1, 2] * 2  [1, 2, 1, 2]  &amp;gt;&amp;gt;&amp;gt; 3 * &#39;w&#39;  &#39;www&#39;            s[i]      &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][0]  1  &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;[-1]  &#39;c&#39;            s[i:j]      &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][0:2]  [1, 2]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][:2]  # i 可以省略，默认值为 0  [1, 2]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:]  # j 也可以省略，默认值为 len(s)  [2, 3]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][:]  # i 和 j 同时省略则相当于对 s 进行了一个拷贝  [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][2:1]  # 如果 j &amp;lt;= i，则返回一个空列表  []  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:-1]  # i 和 j 也可以是负数，如果是负数则会被转换为 len(s) + i/j  [2]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:2]  # [1:-1] 就相当于 [1:len(s)+(-1)] = [1:3-1] = [1:2]  [2]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][1:5]  # 如果 i 或 j 大于 len(s)，则被转换为 len(s)  [2, 3]            s[i:j:k]      &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][0:3:2]  # 设定步长 k 为 2，默认为 1  [1, 3]  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][2:0:-1]  # 相当于取 2, 2-1, 2+n*(-1), ...  [3, 2]  # k 为负数时 i 或 j 的默认值会倒转  # k 为正数时，i 和 j 的默认值分别为 0, len(s)  # k 为负数时，i 和 j 的默认值分别为 len(s)-1, 0，且包含第 0 个元素  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][::-1]    [3, 2, 1]  # k 不能为 0  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3][::0]  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  ValueError: slice step cannot be zero            len(s)      &amp;gt;&amp;gt;&amp;gt; len([1, 2, 3])  3  &amp;gt;&amp;gt;&amp;gt; len(&#39;abc&#39;)  3            min(s)      &amp;gt;&amp;gt;&amp;gt; min([1, 2, 3])  1  &amp;gt;&amp;gt;&amp;gt; min(&#39;abc&#39;)  &#39;a&#39;  &amp;gt;&amp;gt;&amp;gt; min([1, 2, &#39;c&#39;])  # 序列中的元素必须时相同类型的  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  TypeError: unorderable types: str() &amp;lt; int()            max(s)      &amp;gt;&amp;gt;&amp;gt; max([1, 2, 3])  3  &amp;gt;&amp;gt;&amp;gt; max(&#39;abc&#39;)  &#39;c&#39;  &amp;gt;&amp;gt;&amp;gt; max((1, 2, &#39;c&#39;))  # 序列中的元素必须时相同类型的  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  TypeError: unorderable types: str() &amp;gt; int()            s.index(x[, i[, j]])      &amp;gt;&amp;gt;&amp;gt; [1, 2, 3].index(1)  0  &amp;gt;&amp;gt;&amp;gt; [1, 2, 3].index(4)  # 未查找到元素报 ValueError  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  ValueError: 4 is not in list            s.count(x)      &amp;gt;&amp;gt;&amp;gt; [1, 2, 1].count(1)  2  &amp;gt;&amp;gt;&amp;gt; [1, 2, 1].count(3)  0      列表（list）列表属于可变序列（mutable Sequence），列表定义除了用 中括号([]) 外，还可以使用内置函数 list() 把其他序列类型转换为列表：&amp;gt;&amp;gt;&amp;gt; list(&#39;abc&#39;)  # 把字符串转换为列表[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&amp;gt;&amp;gt;&amp;gt; list((1, 2, 3))  # 把元组转换为列表[1, 2, 3]列表操作列表除了支持序列类型的通用操作外，还支持以下这些 可变序列独有的操作：            Operation      Result                  s[i] = x      将 s 的第 i 项替换为 x              s[i:j] = t      将 s 从 i 到 j 的切片替换为可迭代对象 t 的内容              del s[i:j]      等同于 s[i:j] = []              s[i:j:k] = t      将 s[i:j:k] 的元素替换为 t 的元素              del s[i:j:k]      从列表中移除 s[i:j:k] 的元素              s.append(x)      将 x 添加到序列的末尾 (等同于 s[len(s):len(s)] = [x])              s.clear()      从 s 中移除所有项 (等同于 del s[:])              s.copy()      创建 s 的浅拷贝 (等同于 s[:])              s.extend(t) 或 s += t      用 t 的内容扩展 s (基本上等同于 s[len(s):len(s)] = t)              s *= n      使用 s 的内容重复 n 次来对其进行更新              s.insert(i, x)      在由 i 给出的索引位置将 x 插入 s (等同于 s[i:i] = [x])              s.pop([i])      提取在 i 位置上的项，并将其从 s 中移除              s.remove(x)      删除 s 中第一个等于 x 的项目。              s.reverse()      就地将列表中的元素逆序。      下面对以上操作进行示例演示：      s[i] = x      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums[1] = 0  &amp;gt;&amp;gt;&amp;gt; nums  [1, 0, 3]            s[i:j] = t      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums[1:3] = [0, 0]  # 把第 1 到 3-1 范围的元素替换为 [0, 0]  &amp;gt;&amp;gt;&amp;gt; nums  [1, 0, 0]  &amp;gt;&amp;gt;&amp;gt; nums[1:3] = []  # 把第 1 到 3-1 范围的元素删除  &amp;gt;&amp;gt;&amp;gt; nums  [1]  &amp;gt;&amp;gt;&amp;gt; nums[:] = []  # 清空整个列表  &amp;gt;&amp;gt;&amp;gt; nums  []            del s[i:j]      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; del nums[1:3]  &amp;gt;&amp;gt;&amp;gt; nums  [1]            s[i:j:k] = t      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums[0:3:2] = [5, 6]  # 把第 0, 0+2 两个元素分别替换为 [5, 6] 中的元素  &amp;gt;&amp;gt;&amp;gt; nums  [5, 2, 6]  &amp;gt;&amp;gt;&amp;gt; nums[0:3:2] = [5]  # t 的元素个数必须和 [i:j:k] 切割出的元素个数相等  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  ValueError: attempt to assign sequence of size 1 to extended slice of size 2            del s[i:j:k]      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; del nums[0:3:2]  &amp;gt;&amp;gt;&amp;gt; nums  [2]            s.append(x)      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.append(4)  &amp;gt;&amp;gt;&amp;gt; nums  [1, 2, 3, 4]            s.clear()      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.clear()  &amp;gt;&amp;gt;&amp;gt; nums  []            s.copy()      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums_copy = nums.copy()  &amp;gt;&amp;gt;&amp;gt; nums_copy  [1, 2, 3]            s.extend(t) 或 s += t      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.extend([4, 5])  &amp;gt;&amp;gt;&amp;gt; nums  [1, 2, 3, 4, 5]  &amp;gt;&amp;gt;&amp;gt; nums += [6, 7]  &amp;gt;&amp;gt;&amp;gt; nums  [1, 2, 3, 4, 5, 6, 7]            s *= n      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums *= 2  &amp;gt;&amp;gt;&amp;gt; nums  [1, 2, 3, 1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums *= -1  # 如果 n 小于等于 0，则 s 被清空  &amp;gt;&amp;gt;&amp;gt; nums  []            s.insert(i, x)      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.insert(1, 4)  &amp;gt;&amp;gt;&amp;gt; nums  [1, 4, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums[1:1] = [5]  # 等同于 nums.insert(1, 5)  &amp;gt;&amp;gt;&amp;gt; nums  [1, 5, 4, 2, 3]            s.pop([i])      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.pop()  # 参数 i 默认为 -1  3  &amp;gt;&amp;gt;&amp;gt; nums  [1, 2]  &amp;gt;&amp;gt;&amp;gt; nums.pop(0)  # 也可以 pop 指定位置的元素  1  &amp;gt;&amp;gt;&amp;gt; nums  [2]            s.remove(x)      &amp;gt;&amp;gt;&amp;gt; chars = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  &amp;gt;&amp;gt;&amp;gt; chars.remove(&#39;b&#39;)  &amp;gt;&amp;gt;&amp;gt; chars  [&#39;a&#39;, &#39;c&#39;]  &amp;gt;&amp;gt;&amp;gt; chars.remove(&#39;f&#39;)  # 如果 s 中不存在值为 x 的元素，则报 ValueError  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  ValueError: list.remove(x): x not in list            s.reverse()      &amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.reverse()  &amp;gt;&amp;gt;&amp;gt; nums  [3, 2, 1]      列表排序列表除了支持 序列通用操作 和 可变序列操作 外，列表还实现了一个单独的方法 sort ：      list.sort(key=None, reverse=False)    sort 是一个就地排序方法，默认升序排序，如果 reverse 参数为 True，则是进行降序排序。  key 可以接受一个函数，对待排序的对象进行预处理后再进行排序。      &amp;gt;&amp;gt;&amp;gt; nums = [2, 3, 1]  &amp;gt;&amp;gt;&amp;gt; nums.sort()  &amp;gt;&amp;gt;&amp;gt; nums  [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; nums.sort(reverse=True)  # 降序排序  &amp;gt;&amp;gt;&amp;gt; nums  [3, 2, 1]  &amp;gt;&amp;gt;&amp;gt; ids = [&#39;lily-02&#39;, &#39;tom-01&#39;, &#39;jack-03&#39;]  &amp;gt;&amp;gt;&amp;gt; ids.sort()  # 默认按字母序进行升序排序：j &amp;lt; l &amp;lt; t  &amp;gt;&amp;gt;&amp;gt; ids  [&#39;jack-03&#39;, &#39;lily-02&#39;, &#39;tom-01&#39;]  # 只取 - 后两位数字进行排序比较：01 &amp;lt; 02 &amp;lt; 03  &amp;gt;&amp;gt;&amp;gt; ids.sort(key=lambda s: s.split(&#39;-&#39;)[-1])  &amp;gt;&amp;gt;&amp;gt; ids  [&#39;tom-01&#39;, &#39;lily-02&#39;, &#39;jack-03&#39;]      列表推导式列表推导式提供了一种简洁的方式来创建列表，比如需要创建一个 1~10 的平方数的列表，只需要像这样一行代码即可完成：&amp;gt;&amp;gt;&amp;gt; [x**2 for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]列表推导式也同时支持在 for 后面添加 if 语句：&amp;gt;&amp;gt;&amp;gt; [x for x in range(1, 11) if x%2 == 0]  # 1~10 的偶数[2, 4, 6, 8, 10]列表推导式也支持嵌套：&amp;gt;&amp;gt;&amp;gt; [(x, y) for x in [1, 2] for y in [3, 4]][(1, 3), (1, 4), (2, 3), (2, 4)]## 上面的推导式与以下嵌套循环作用相同&amp;gt;&amp;gt;&amp;gt; combs = []&amp;gt;&amp;gt;&amp;gt; for x in [1, 2]:...     for y in [3, 4]:...         combs.append((x, y))...&amp;gt;&amp;gt;&amp;gt; combs[(1, 3), (1, 4), (2, 3), (2, 4)]浅拷贝与深拷贝列表支持嵌套列表或嵌套其他可变对象，对于列表自带的 copy 方法和切片式拷贝，以及 *(repeation)，都只是一个 浅拷贝，下面举例对浅拷贝进行说明：&amp;gt;&amp;gt;&amp;gt; nested_nums = [1, [2, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums = nested_nums.copy()  # 浅拷贝，等同于 nested_nums[:]## 修改原始列表中非嵌套元素，拷贝列表不受影响&amp;gt;&amp;gt;&amp;gt; nested_nums[0] = 9&amp;gt;&amp;gt;&amp;gt; nested_nums[9, [2, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums[1, [2, 3], 4]## 修改原始列表中嵌套列表的元素，拷贝列表受影响&amp;gt;&amp;gt;&amp;gt; nested_nums[1][0] = 9&amp;gt;&amp;gt;&amp;gt; nested_nums[9, [9, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums[1, [9, 3], 4]如果想要避免上面的浅拷贝的情况，可以使用 copy.deepcopy 函数进行深拷贝：&amp;gt;&amp;gt;&amp;gt; nested_nums = [1, [2, 3], 4]&amp;gt;&amp;gt;&amp;gt; import copy&amp;gt;&amp;gt;&amp;gt; copy_nested_nums = copy.deepcopy(nested_nums)&amp;gt;&amp;gt;&amp;gt; nested_nums[1][0] = 9&amp;gt;&amp;gt;&amp;gt; nested_nums[1, [9, 3], 4]&amp;gt;&amp;gt;&amp;gt; copy_nested_nums  # 深拷贝的列表不受影响[1, [2, 3], 4]rangerange 是一个 内置类型，可以用来创建一个 不可变序列(immutable)，定义如下：class range(stop)class range(start, stop[, step])# 在 start 到 stop 范围内（不包含 stop），以步长为 step，产生一个序列。start, stop, step 均为 int 类型，如果只传入一个参数，这个参数会被当作 stop ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(3)][0, 1, 2]也可以传入 2 个参数，则分别会被当作 start 和 stop ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(1, 3)][1, 2]还可以设定步长（step），步长默认值是 1 ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(1, 10, 2)][1, 3, 5, 7, 9]如果步长 step 为负数，那么应该满足 start &amp;gt;= stop ：&amp;gt;&amp;gt;&amp;gt; [i for i in range(3, 0, -1)][3, 2, 1]和 list 相比，range 类型更节约内存，因为 list 占用内存大小是根据元素的多少而变化，而 range 生成的实例只是记录了一下计算方法，不管范围多大，都占用固定大小的内存，在每一次 for 循环时才实时计算出当前的元素内容：&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]&amp;gt;&amp;gt;&amp;gt; import sys&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(nums)88&amp;gt;&amp;gt;&amp;gt; r = range(1, 4)&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(r)48&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3, 4] &amp;gt;&amp;gt;&amp;gt; sys.getsizeof(nums)  # 增加一个元素后，大小也增加了 896&amp;gt;&amp;gt;&amp;gt; r = range(1, 5)&amp;gt;&amp;gt;&amp;gt; rrange(1, 5)&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(r)  # 扩大范围后，占用大小仍然不变48元组（tuple）元组和列表类似，都是序列，不同的是元组是 不可变序列(immutable Sequence)，元组的定义使用 圆括号，也可以使用内置关键字 tuple，将其他序列转换为元组：&amp;gt;&amp;gt;&amp;gt; t = (1, 2, 3)&amp;gt;&amp;gt;&amp;gt; t(1, 2, 3)&amp;gt;&amp;gt;&amp;gt; t = 1, 2, 3  # 如果元素个数超过 1 个，也可以不使用圆括号&amp;gt;&amp;gt;&amp;gt; t(1, 2, 3)## 只有 1 个元素的元组需要用圆括号括起来，并且在末尾添加一个逗号(,)## 这样做是为了和数学符号的圆括号进行区分&amp;gt;&amp;gt;&amp;gt; t = (1,)  &amp;gt;&amp;gt;&amp;gt; t(1,)&amp;gt;&amp;gt;&amp;gt; tuple([1, 2, 3])  # 把列表转换为元组(1, 2, 3)元组作为不可变序列，一旦定义后，其中的元素不能被修改：&amp;gt;&amp;gt;&amp;gt; t = (1, 2, 3)&amp;gt;&amp;gt;&amp;gt; t[0] = 5Traceback (most recent call last):  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;TypeError: &#39;tuple&#39; object does not support item assignment但是元组里的可变类型的内容的是可以被修改的：&amp;gt;&amp;gt;&amp;gt; t = (1, [2, 3], 4)&amp;gt;&amp;gt;&amp;gt; t[1][0] = 3&amp;gt;&amp;gt;&amp;gt; t(1, [3, 3], 4)引用资料  [More on Lists] : https://docs.python.org/3.5/tutorial/datastructures.html#more-on-lists  [Tuples and Sequences] : https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences  [Sequence Types — list, tuple, range] : https://docs.python.org/3.5/library/stdtypes.html#sequence-types-list-tuple-range"
  },
  
  {
    "title": "Python 入门-4-字符串",
    "url": "/posts/python-tutorial-4-string/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-07-10 17:39:07 +0800",
    





    "snippet": "字符串方法字符串(str) 在 Python 中是一个 对象(object)，并且包含很多的 方法(method)，这些方法可以给我们操作字符串带来很大的方便，下面列举一些常用的方法及其使用示例：      str.capitalize()    把字符串的首字母变成大写。      &amp;gt;&amp;gt;&amp;gt; &#39;hello&#39;.capitalize()  &#39;Hello&#39;            str.lower()    把字符串转换为小写。      &amp;gt;&amp;gt;&amp;gt; &#39;Hello&#39;.lower()  &#39;hello&#39;            str.upper()    把字符串转换为大写。      &amp;gt;&amp;gt;&amp;gt; &#39;Hello&#39;.upper()  &#39;HELLO&#39;            str.center(width[, fillchar])    返回一个长度为 width，原始字符串居中，两边多余长度使用 fillchar 进行填充的新字符串。      &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.center(10, &#39;=&#39;)  &#39;===abc====&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.center(10)  # fillchar 默认为空格  &#39;   abc    &#39;  &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.center(3)  # 如果 width 小于等于字符串长度，则返回原始字符串  &#39;abc&#39;            str.count(sub[, start[, end]])    在字符串的 start 到 end 范围内查找子字符串 sub 出现的次数。  start 默认为0，end 默认为字符串长度，即默认查找整个字符串，这2个参数在其他方法中类似，不再重复说明。      &amp;gt;&amp;gt;&amp;gt; &#39;abcad&#39;.count(&#39;a&#39;)  2  &amp;gt;&amp;gt;&amp;gt; &#39;abcad&#39;.count(&#39;a&#39;, 0, 3)  1  &amp;gt;&amp;gt;&amp;gt; &#39;abcad&#39;.count(&#39;a&#39;, 0, 4)  2            str.encode(encoding=”utf-8”, errors=”strict”)    对字符串按照 encoding 进行编码。      &amp;gt;&amp;gt;&amp;gt; &#39;中文&#39;.encode()  b&#39;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#39;            str.startswith(prefix[, start[, end]])    判断字符串在 start 到 end 范围内是否是以 prefix 开头，是返回 True，否则返回 False。  prefix 可以是多个，以 tuple 格式传入。  str.endswith 方法与此方法类似。      &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.startswith(&#39;a&#39;)  True  &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.startswith(&#39;b&#39;)  False  &amp;gt;&amp;gt;&amp;gt; &#39;abc&#39;.startswith((&#39;a&#39;, &#39;b&#39;))  # 是否以 &#39;a&#39; 或 &#39;b&#39; 开头  True            str.find(sub[, start[, end]])    在字符串的 start 到 end 范围内查找子字符串 sub，如果查到到则返回 sub 出现的最小起始索引号，否则返回 -1 。      &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.find(&#39;b&#39;)  1  &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.find(&#39;x&#39;)  -1        如果只需要判断是否包含子字符串，可以使用 in 关键字进行判断，无需使用 find 方法。      &amp;gt;&amp;gt;&amp;gt; &#39;b&#39; in &#39;abc&#39;  True  &amp;gt;&amp;gt;&amp;gt; &#39;d&#39; in &#39;abc&#39;  False            str.index(sub[, start[, end]])    与 str.find 方法类似，不同的是如果没有查找到子字符串 sub ，会抛出 ValueError 异常。      &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.index(&#39;b&#39;)  1  &amp;gt;&amp;gt;&amp;gt; &#39;abcdbf&#39;.index(&#39;x&#39;)  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  ValueError: substring not found  &amp;gt;&amp;gt;&amp;gt;            str.format(*args, **kwargs)    格式化字符串，此方法在下面会进行详细讲解，这里只演示一个简单示例。      &amp;gt;&amp;gt;&amp;gt; &quot;The sum of 1 + 2 is {0}&quot;.format(1+2)  &#39;The sum of 1 + 2 is 3&#39;            str.join(iterable)    把 iterable 中的字符串元素用 str 进行连接。  iterable 可以是 list、tuple 等可迭代对象，但是里边的元素必须是 str 类型。      &amp;gt;&amp;gt;&amp;gt; &#39;_&#39;.join([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])  &#39;a_b_c&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;_&#39;.join([1, 2, 3])  # 不能是非 str 类型  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  TypeError: sequence item 0: expected str instance, int found  &amp;gt;&amp;gt;&amp;gt;            str.strip([chars])    去除字符串首尾的在 chars 中出现的字符。  如果 chars 不指定，则默认去除空白字符。      &amp;gt;&amp;gt;&amp;gt; &#39;   spacious   &#39;.strip()  &#39;spacious&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;www.example.com&#39;.strip(&#39;cmowz.&#39;)  &#39;example&#39;        str.lstrip([chars]) 方法则只去除左边(首部)的字符。      &amp;gt;&amp;gt;&amp;gt; &#39;   spacious   &#39;.lstrip()  &#39;spacious   &#39;  &amp;gt;&amp;gt;&amp;gt; &#39;www.example.com&#39;.lstrip(&#39;cmowz.&#39;)  &#39;example.com&#39;        str.rstrip([chars]) 与 lstrip 类似，只是去除右边(尾部)字符。        str.split(sep=None, maxsplit=-1)    用分隔符 sep 对字符串进行最多 maxsplit 次切割，返回切割后的 list 。  sep 默认为空白字符，即空格、制表符等。  maxsplit 如果不指定或指定为 -1，则会进行最大次数的切割。      # 指定 sep  &amp;gt;&amp;gt;&amp;gt; &#39;1,2,3&#39;.split(&#39;,&#39;)  [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]  &amp;gt;&amp;gt;&amp;gt; &#39;1,2,3&#39;.split(&#39;,&#39;, maxsplit=1)  [&#39;1&#39;, &#39;2,3&#39;]  &amp;gt;&amp;gt;&amp;gt; &#39;1,2,,3,&#39;.split(&#39;,&#39;)  [&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]  # 不指定 sep  &amp;gt;&amp;gt;&amp;gt; &#39;1 2 3&#39;.split()  [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]  &amp;gt;&amp;gt;&amp;gt; &#39;1 2 3&#39;.split(maxsplit=1)  [&#39;1&#39;, &#39;2 3&#39;]  &amp;gt;&amp;gt;&amp;gt; &#39;   1   2   3   &#39;.split()  [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]            str.splitlines([keepends])    把字符串按照行边界符(line boundaries)切割成多行，并以 list 形式返回。  如果 keepends 为True，则返回的每行末尾仍然包含换行符，keepends 默认为False。  符合行边界符(line boundaries)定义的字符如下：                            Representation          Description                                      \\n          Line Feed                          \\r          Carriage Return                          \\r\\n          Carriage Return + Line Feed                          \\v or \\x0b          Line Tabulation                          \\f or \\x0c          Form Feed                          \\x1c          File Separator                          \\x1d          Group Separator                          \\x1e          Record Separator                          \\x85          Next Line (C1 Control Code)                          \\u2028          Line Separator                          \\u2029          Paragraph Separator                        &amp;gt;&amp;gt;&amp;gt; &#39;first line \\nsecond line \\r\\nthird line&#39;.splitlines()  [&#39;first line &#39;, &#39;second line &#39;, &#39;third line&#39;]  &amp;gt;&amp;gt;&amp;gt; &#39;first line \\nsecond line \\r\\nthird line&#39;.splitlines(True)  [&#39;first line \\n&#39;, &#39;second line \\r\\n&#39;, &#39;third line&#39;]      使用 % 格式化字符串Python 中使用 % 格式化字符串的格式是 format % values ：&amp;gt;&amp;gt;&amp;gt; &#39;I am %s&#39; % &#39;python&#39;&#39;I am python&#39;&amp;gt;&amp;gt;&amp;gt;如果 values 是多个值，那么需要使用表示 tuple 的圆括号括起来：&amp;gt;&amp;gt;&amp;gt; &#39;This is %s, that is %s&#39; % (&#39;python&#39;, &#39;java&#39;)&#39;This is python, that is java&#39;&amp;gt;&amp;gt;&amp;gt;values 也可以是字典，如果是字典那么 format 里需要用 映射键(mapping key) 的方式取值：&amp;gt;&amp;gt;&amp;gt; &#39;I am %(lang)s&#39; % {&#39;lang&#39;: &#39;python&#39;}&#39;I am python&#39;以上示例中的 %s 里的 s 表示转换类型为 str，Python 也支持很多其他类型，以下列出常见的几种：      d/i : 有符号的十进制整数      &amp;gt;&amp;gt;&amp;gt; &#39;1 + 1 = %d&#39; % 2  &#39;1 + 1 = 2&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;1 + 1 = %i&#39; % 2  &#39;1 + 1 = 2&#39;            o : 有符号的八进制整数      &amp;gt;&amp;gt;&amp;gt; &#39;decimal 9 convert to octal is %o&#39; % 9  &#39;decimal 9 convert to octal is 11&#39;            x/X : 有符号16进制数      &amp;gt;&amp;gt;&amp;gt; &#39;decimal 17 convert to hex is %x&#39; % 17  &#39;decimal 17 convert to hex is 11&#39;            f/F : 浮点数十进制格式      &amp;gt;&amp;gt;&amp;gt; &#39;%f&#39; % 3.14  &#39;3.140000&#39;            e/E : 浮点数指数格式      &amp;gt;&amp;gt;&amp;gt; &#39;%e&#39; % 31.4  &#39;3.140000e+01&#39;            c : 单个字符      &amp;gt;&amp;gt;&amp;gt; &#39;%c&#39; % 97  &#39;a&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%c&#39; % &#39;a&#39;  &#39;a&#39;            r : 字符串（使用 repr() 转换任何 Python 对象）      &amp;gt;&amp;gt;&amp;gt; &#39;hello %r&#39; % &#39;world&#39;  &quot;hello &#39;world&#39;&quot;            s : 字符串（使用 str() 转换任何 Python 对象）      &amp;gt;&amp;gt;&amp;gt; &#39;hello %s&#39; % &#39;world&#39;  &#39;hello world&#39;            a : 字符串（使用 ascii() 转换任何 Python 对象）      &amp;gt;&amp;gt;&amp;gt; &#39;hello %a&#39; % &#39;world&#39;  &quot;hello &#39;world&#39;&quot;      如果需要原样表示 % ，只需双写 % 即可：&amp;gt;&amp;gt;&amp;gt; &#39;3 %% 2 = %d&#39; % 1&#39;3 % 2 = 1&#39;可以指定占位宽度，如果实际内容小于宽度，默认右对齐，左边补空格：&amp;gt;&amp;gt;&amp;gt; &#39;%3s&#39; % &#39;a&#39;&#39;  a&#39;&amp;gt;&amp;gt;&amp;gt; &#39;%3d&#39; % 10&#39; 10&#39;对于浮点数，可以使用 .precision 的格式指定指定精度：&amp;gt;&amp;gt;&amp;gt; &#39;%.3f&#39; % 3.1415&#39;3.142&#39;&amp;gt;&amp;gt;&amp;gt; &#39;%.3f&#39; % 3.14&#39;3.140&#39;可以使用 转换标志(Conversion flags) 对转换行为进行一些控制，支持的转换标志如下：      ’#’ : 替代模式(alternate form)      # 八进制和十进制转换在替代模式下会显示 0o 和 0x/0X 前缀  &amp;gt;&amp;gt;&amp;gt; &#39;%o&#39; % 9  &#39;11&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%#o&#39; % 9  &#39;0o11&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%#x&#39; % 17  &#39;0x11&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%#X&#39; % 17  &#39;0X11&#39;  # 浮点数转换在替代模式下会始终保留一个小数点在末尾，即使精度为0的整数  &amp;gt;&amp;gt;&amp;gt; &#39;%.0f&#39; % 3.0  &#39;3&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%#.0f&#39; % 3.0  &#39;3.&#39;            ‘0’ : 数值类型转换时多余位置补0      &amp;gt;&amp;gt;&amp;gt; &#39;%03d&#39; % 1  &#39;001&#39;            ’-‘ : 转换值将靠左对齐（会覆盖 ‘0’ 转换）      &amp;gt;&amp;gt;&amp;gt; &#39;%-3d&#39; % 1  &#39;1  &#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%0-3d&#39; % 1  # &#39;-&#39; 转换会覆盖 &#39;0&#39; 转换  &#39;1  &#39;            ’ ‘ : (空格) 正数前面保留一个空格      &amp;gt;&amp;gt;&amp;gt; &#39;% d&#39; % 1  &#39; 1&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;% d&#39; % -1  &#39;-1&#39;            ’+’ : 数值类型前面显示符号位（会覆盖 “空格” 转换）      &amp;gt;&amp;gt;&amp;gt; &#39;%+d&#39; % 1  &#39;+1&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;%+d&#39; % -1  &#39;-1&#39;      以上这些符号组合使用时需要遵守以下规则和顺序：%[M][F][W][P][L]T% : 固定格式。M : 映射键(mapping key)（可选），由加圆括号的字符序列组成 (例如 (somename))，values 是字典的情况下使用。F : 转换标志(conversion flags)（可选），用于影响某些转换类型的结果。W : 最小字段宽度(width)（可选）。 如果指定为 &#39;*&#39; (星号)，则实际宽度会从 values 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。P : 精度(precision)（可选），以在 &#39;.&#39; (点号) 之后加精度值的形式给出。 如果指定为 &#39;*&#39; (星号)，则实际精度会从 values 元组的下一元素中读取，要转换的对象则为精度之后的元素。L : 长度修饰符(length modifier)（可选）。T : 转换类型(conversion type)。注：长度修饰符（h, l 或 L）可以使用，但是会被忽略，因为在 Python3 中只有长整型（L），没有短整型（h），所有 %ld 和 %d 是一样的。下面是一些组合使用的示例：## 十进制浮点数转换类型(f)，带符号位(+)，左对齐(-)，最小宽度5(5)，精度1位(.1)&amp;gt;&amp;gt;&amp;gt; &#39;%+-5.1f&#39; % 3.14&#39;+3.1 &#39;## 十进制整数转换类型(d)，带符号位(+)，最小宽度4(4)，不足位补0(0)&amp;gt;&amp;gt;&amp;gt; &#39;%+04d&#39; % 16&#39;+016&#39;## 字符串转换类型(s)，左对齐(-)，最小宽度6(6)，精度2(.2)&amp;gt;&amp;gt;&amp;gt; &#39;%-6.2s&#39; % &#39;Python&#39;&#39;Py    &#39;使用 str.format 格式化字符串从 Python3 开始官方推荐使用字符串自带的 format 方法对字符串进行格式化，该方法能够完全兼容 % 的形式且更强大，比如像下面这样：&amp;gt;&amp;gt;&amp;gt; &#39;hello {}!&#39;.format(&#39;world&#39;)&#39;hello world!&#39;format 的语法定义如下：replacement_field ::=  &quot;{&quot; [field_name] [&quot;!&quot; conversion] [&quot;:&quot; format_spec] &quot;}&quot;field_name        ::=  arg_name (&quot;.&quot; attribute_name | &quot;[&quot; element_index &quot;]&quot;)*arg_name          ::=  [identifier | integer]attribute_name    ::=  identifierelement_index     ::=  integer | index_stringindex_string      ::=  &amp;lt;any source character except &quot;]&quot;&amp;gt; +conversion        ::=  &quot;r&quot; | &quot;s&quot; | &quot;a&quot;format_spec       ::=  &amp;lt;described in the next section&amp;gt;下面通过举例的方式逐一对 format 语法定义中的字段进行解释：      field_name/arg_name : 参数名（可选），可以是位置（integer）或名称（identifier）。      # arg_name 为空则按顺序依次引用后面的位置参数  &amp;gt;&amp;gt;&amp;gt; &#39;{} {} {}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;)  &#39;first second third&#39;  # arg_name 为位置（integer），则按照索引号引用后面的位置参数  &amp;gt;&amp;gt;&amp;gt; &#39;{0} {1} {2}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;)  &#39;first second third&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{2} {1} {0}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;)  &#39;third second first&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{0} {0} {1}&#39;.format(&#39;first&#39;, &#39;second&#39;)  &#39;first first second&#39;  # 但是空和位置引用不能混用  &amp;gt;&amp;gt;&amp;gt; &#39;{} {1} {2}&#39;.format(&#39;first&#39;, &#39;second&#39;, &#39;third&#39;)  Traceback (most recent call last):    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;  ValueError: cannot switch from automatic field numbering to manual field specification  # arg_name 为名称（identifier），则按照名称引用后面的关键字参数  &amp;gt;&amp;gt;&amp;gt; &#39;{f1} {f2} {f3}&#39;.format(f1=&#39;first&#39;, f2=&#39;second&#39;, f3=&#39;third&#39;)  &#39;first second third&#39;  # 空引用和名称引用混用，或者数字引用和名称引用混用是可以的  &amp;gt;&amp;gt;&amp;gt; &#39;{} {f2} {}&#39;.format(&#39;first&#39;, &#39;third&#39;, f2=&#39;second&#39;)  &#39;first second third&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{0} {f2} {1}&#39;.format(&#39;first&#39;, &#39;third&#39;, f2=&#39;second&#39;)  &#39;first second third&#39;            field_name/arg_name.attribute_name : 属性名（可选），是对参数的属性进行引用。      &amp;gt;&amp;gt;&amp;gt; c = 3-5j  &amp;gt;&amp;gt;&amp;gt; &#39;realpart = {0.real}, imagpart = {0.imag}&#39;.format(c)  &#39;realpart = 3.0, imagpart = -5.0&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;realpart = {cnum.real}, imagpart = {cnum.imag}&#39;.format(cnum=c)  &#39;realpart = 3.0, imagpart = -5.0&#39;            field_name/arg_name[element_index] : 元素索引（可选），可以是数字或名称，通过索引的方式引用参数的元素。      # 数字索引  &amp;gt;&amp;gt;&amp;gt; arr = [1, 2]  &amp;gt;&amp;gt;&amp;gt; &#39;e1 = {0[0]}, e2 = {0[1]}&#39;.format(arr)  &#39;e1 = 1, e2 = 2&#39;  # 名称索引  &amp;gt;&amp;gt;&amp;gt; d = {&#39;id&#39;: 1, &#39;name&#39;: &#39;tom&#39;}  &amp;gt;&amp;gt;&amp;gt; &#39;id = {0[id]}, name = {0[name]}&#39;.format(d)  &#39;id = 1, name = tom&#39;            conversion : 转换标志，’!s’ 会对值调用 str()，’!r’ 调用 repr() 而 ‘!a’ 则调用 ascii() 。      &amp;gt;&amp;gt;&amp;gt; &#39;hello {0!r}&#39;.format(&#39;world&#39;)  &quot;hello &#39;world&#39;&quot;  &amp;gt;&amp;gt;&amp;gt; &#39;hello {0!s}&#39;.format(&#39;world&#39;)  &#39;hello world&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;hello {0!a}&#39;.format(&#39;world&#39;)  &quot;hello &#39;world&#39;&quot;      format_spec 的语法定义如下：format_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type]fill        ::=  &amp;lt;any character&amp;gt;align       ::=  &quot;&amp;lt;&quot; | &quot;&amp;gt;&quot; | &quot;=&quot; | &quot;^&quot;sign        ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;width       ::=  integerprecision   ::=  integertype        ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;下面通过举例的方式逐一对 format_spec 语法定义中的字段进行解释：      width : 最小宽度      # 指定最小宽度为 10 位  &amp;gt;&amp;gt;&amp;gt; &#39;{:10}&#39;.format(&#39;Python&#39;)  &#39;Python    &#39;            align : 对齐方式，支持 ‘&amp;lt;’, ‘&amp;gt;’, ‘^’ 三种方式。      &amp;gt;&amp;gt;&amp;gt; &#39;{:&amp;lt;30}&#39;.format(&#39;left aligned&#39;)  # 最小宽度 30，并且左对齐  &#39;left aligned                  &#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{:&amp;gt;30}&#39;.format(&#39;right aligned&#39;)  # 最小宽度 30，并且又对齐  &#39;                 right aligned&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{:^30}&#39;.format(&#39;centered&#39;)  # 最小宽度 30，并且居中对齐  &#39;           centered           &#39;            fill : 填充符      # 最小宽度 30，并且居中对齐，多余部分使用 * 填充  &amp;gt;&amp;gt;&amp;gt; &#39;{:*^30}&#39;.format(&#39;centered&#39;)  &#39;***********centered***********&#39;            sign : 符号位，仅对数学类型有效，支持 ‘+’, ‘-‘, ‘ ‘ 三种类型。      &amp;gt;&amp;gt;&amp;gt; &#39;{:+}, {:+}&#39;.format(1, -1)  # 始终保留符号位  &#39;+1, -1&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{:-}, {:-}&#39;.format(1, -1)  # 负数才有符号位  &#39;1, -1&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{: }, {: }&#39;.format(1, -1)  # 正数前保留一个空格  &#39; 1, -1&#39;            precision : 精度      &amp;gt;&amp;gt;&amp;gt; &#39;{:.2}&#39;.format(3.14)  &#39;3.1&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{:.2}&#39;.format(&#39;Python&#39;)  # 作用在字符串上则会按照进行截断  &#39;Py&#39;            , : 千分位      &amp;gt;&amp;gt;&amp;gt; &#39;{:,}&#39;.format(12345678)  &#39;12,345,678&#39;            type : 转换类型    转换类型大部分与 % 格式化的方式相同，下面只对不一样的类型进行示例说明：      &amp;gt;&amp;gt;&amp;gt; &#39;{:b}&#39;.format(7)  # 二进制类型  &#39;111&#39;  &amp;gt;&amp;gt;&amp;gt; &#39;{:.2%}&#39;.format(23/89)  # 百分比类型  &#39;25.84%&#39;            #/0 : # 和 0 的作用与 % 格式化的方式相同  引用资料  [Strings] : https://docs.python.org/3.5/tutorial/introduction.html#strings  [String Methods] : https://docs.python.org/3.5/library/stdtypes.html#string-methods  [Format String Syntax] : https://docs.python.org/3.5/library/string.html#formatstrings  [printf-style String Formatting] : https://docs.python.org/3.5/library/stdtypes.html#old-string-formatting"
  },
  
  {
    "title": "Python 入门-3-数据类型",
    "url": "/posts/python-tutorial-3-variable-type/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-06-12 17:52:02 +0800",
    





    "snippet": "数字（int, float）Python 中的整数和数学上的整数一样，但是跟 Python2 和 C 语言相比不同的是，Python3 中的整数没有 短整型(int) 和 长整型(long) 的区别，即 int 直接相当于 Python2 和 C 语言中的 长整型(long) 类型。Python 中的 浮点数(float) 则相当于数学上的小数。叫做浮点数是由于在计算机中小数的表示方法有 浮点表示 和 定点表示 的区别，浮点表示即小数点的位置可变，比如 1.23 也可以表示为 0.123e1。关于浮点数可以参考《浮点数的二进制表示》。四则运算：## 加减乘除&amp;gt;&amp;gt;&amp;gt; 2 + 24&amp;gt;&amp;gt;&amp;gt; 50 - 5*620&amp;gt;&amp;gt;&amp;gt; (50 - 5*6) / 4  # 除法运算结果始终为浮点数5.0取余和幂运算：&amp;gt;&amp;gt;&amp;gt; 17 % 3  # 取余2&amp;gt;&amp;gt;&amp;gt; 2 ** 3  # 幂运算8&amp;gt;&amp;gt;&amp;gt; pow(2, 3)  # 也可以适用内置函数 pow 进行幂运算8地板除法（floor division）：&amp;gt;&amp;gt;&amp;gt; 11 // 4  # 地板除运算符(//)的结果将会向负无穷的方向取整2&amp;gt;&amp;gt;&amp;gt; -11 // 4  # -2.75 向负无穷的方向取整结果为 -3-3## math.floor 方法和 // 运算符结果一样&amp;gt;&amp;gt;&amp;gt; import math&amp;gt;&amp;gt;&amp;gt; math.floor(2.75)2&amp;gt;&amp;gt;&amp;gt; math.floor(-2.75)-3## math.ceil 则是向正无穷方向取整&amp;gt;&amp;gt;&amp;gt; math.ceil(2.75)3&amp;gt;&amp;gt;&amp;gt; math.ceil(-2.75)-2int 和 float 混合运算时的规则：在数值范围表示上 int &amp;lt; float，所以 int 相对于 float 来说是窄类型（narrower），float 相对 int 来说是宽类型，在混合运算或比较时，窄类型会转换为宽类型进行计算，所以最终结果也是宽类型：## 窄类型 int 转换为宽类型 float 进行计算&amp;gt;&amp;gt;&amp;gt; 2 + 2.04.0&amp;gt;&amp;gt;&amp;gt; 2.0 - 11.0&amp;gt;&amp;gt;&amp;gt; 2.0 * 3.06.0&amp;gt;&amp;gt;&amp;gt; 2 ** 3.08.0&amp;gt;&amp;gt;&amp;gt; 17 % 3.02.0## 窄类型 int 转换为宽类型 float 进行比较&amp;gt;&amp;gt;&amp;gt; 1 == 1.0True&amp;gt;&amp;gt;&amp;gt; [1, 2] == [1.0, 2.0]True字符串（str）字符串的 单引号 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&#39;I am a string&#39;)I am a string&amp;gt;&amp;gt;&amp;gt; print(&#39;I\\&#39;m a string&#39;)  # 单引号中如果要包含单引号，需要用反斜杠(\\)转义I&#39;m a string&amp;gt;&amp;gt;&amp;gt; print(&#39;I am a &quot;string&quot;&#39;)  # 单引号中可以包含双引号(&quot;)I am a &quot;string&quot;字符串的 双引号 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&quot;I am a string&quot;)I am a string&amp;gt;&amp;gt;&amp;gt; print(&quot;I am a \\&quot;string\\&quot;&quot;)  # 双引号中如果要包含双引号，需要用反斜杠(\\)转义I am a &quot;string&quot;&amp;gt;&amp;gt;&amp;gt; print(&quot;I&#39;m a string&quot;)  # 双引号中可以包含单引号(&#39;)I&#39;m a string字符串的 三引号 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&#39;&#39;&#39;I am a string&#39;&#39;&#39;)  # 三个单引号形式I am a string&amp;gt;&amp;gt;&amp;gt; print(&quot;&quot;&quot;I am a string&quot;&quot;&quot;)  # 三个双引号形式I am a string&amp;gt;&amp;gt;&amp;gt; print(&#39;&#39;&#39;I&#39;m a &quot;string&quot;&#39;&#39;&#39;)  # 三引号中既可以包含单引号，也可以包含双引号I&#39;m a &quot;string&quot;## 三引号中可以包含多行print(&#39;&#39;&#39;I am first lineI am second line&#39;&#39;&#39;)I am first lineI am second line## 三引号中可以在行尾添加反斜杠(\\)表示不换行print(&#39;&#39;&#39;I am first line, \\I am still first line&#39;&#39;&#39;)I am first line, I am still first line字符串的 raw 表示形式：&amp;gt;&amp;gt;&amp;gt; print(&#39; first line \\n second line&#39;)  # \\n表示换行 first line second line## 添加r前缀的字符串表示把反斜杠(\\)当作普通字符，而不是转义符&amp;gt;&amp;gt;&amp;gt; print(r&#39; first line \\n still first line&#39;)   first line \\n still first line字符串可以用 + 进行拼接：&amp;gt;&amp;gt;&amp;gt; print(&#39;Py&#39; + &#39;thon&#39;)Python字符串也可以用 空格 进行拼接：&amp;gt;&amp;gt;&amp;gt; print(&#39;Py&#39; &#39;thon&#39;)Python&amp;gt;&amp;gt;&amp;gt; s = &#39;thon&#39;&amp;gt;&amp;gt;&amp;gt; print(&#39;Py&#39; s)  # 不能用空格连接变量字符串  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1    print(&#39;Py&#39; s)               ^SyntaxError: invalid syntax字符串可以用 * 进行重复：&amp;gt;&amp;gt;&amp;gt; print(&#39;w&#39; * 3)www字符串可以用列表索引截取：&amp;gt;&amp;gt;&amp;gt; s = &#39;Python&#39;&amp;gt;&amp;gt;&amp;gt; s[0]&#39;P&#39;&amp;gt;&amp;gt;&amp;gt; s[-1]&#39;n&#39;&amp;gt;&amp;gt;&amp;gt; s[0:2]  # 切片(slice)，切片将在后续章节进一步讲解&#39;Py&#39;布尔（bool）Python 中的布尔值使用 True 和 False 表示(注意区分大小写)，布尔运算符分别为 and、or 和 not ：## and 运算符&amp;gt;&amp;gt;&amp;gt; True and TrueTrue&amp;gt;&amp;gt;&amp;gt; True and FalseFalse&amp;gt;&amp;gt;&amp;gt; False and FalseFalse&amp;gt;&amp;gt;&amp;gt; 5 &amp;gt; 3 and 3 &amp;gt; 1True## or 运算符&amp;gt;&amp;gt;&amp;gt; True or TrueTrue&amp;gt;&amp;gt;&amp;gt; True or FalseTrue&amp;gt;&amp;gt;&amp;gt; False or FalseFalse&amp;gt;&amp;gt;&amp;gt; 5 &amp;gt; 3 or 1 &amp;gt; 3True## not 运算符&amp;gt;&amp;gt;&amp;gt; not TrueFalse&amp;gt;&amp;gt;&amp;gt; not FalseTrue&amp;gt;&amp;gt;&amp;gt; not 1 &amp;gt; 2TruePython 中的 bool 类其实是从 int 类继承实现的，True 和 False 分别是 1 和 0 ：&amp;gt;&amp;gt;&amp;gt; [&#39;a&#39;, &#39;b&#39;][True]&#39;b&#39;&amp;gt;&amp;gt;&amp;gt; [&#39;a&#39;, &#39;b&#39;][False]&#39;a&#39;空（None）空值(None)在 Python 中是一个特殊值，与 JAVA 中的 null 相同，None 和 0 是不相同的，0 是一个 int类型的，是有值的。如果一个函数没有 return 语句，那么默认就会返回 None。引用资料  [Numbers] : https://docs.python.org/3.5/tutorial/introduction.html#numbers  [数据类型和变量] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112"
  },
  
  {
    "title": "Python 入门-2-安装和使用",
    "url": "/posts/python-tutorial-2-install-and-usage/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-03-07 20:03:27 +0800",
    





    "snippet": "Windows下载安装包进入Python官网的 windows downloads 页面，以Python 3.5.1为例，可以看到除了帮助文件之外一共有6个安装包可以下载，操作系统位数分为32位(X86)和64位(x86-64)，安装包类型分为embeddable、executable、web-based三种，所以一共有 2*3 = 6 个安装包可下载。需要注意的是从Python 3.5开始就只支持Windows Vista及以上的版本，如果是Windows XP则只能选择安装Python 3.4。如何查看操作系统版本和位数可以参考 微软官方帮助文档。3种不同类型的安装包区别如下：  embeddable：嵌入式包，相当于绿色版Python，短小精干且无需安装，可直接嵌入到其他应用中使用  executable：离线安装包，包含默认安装所需的所有组件，可用于离线安装  web-based：在线安装包，只是一个安装器，在安装过程种需要联网下载安装所需的组件图形界面安装下面以Python 3.5为例进行说明，双击安装包进入图界面安装：如果选择 Install Now，会安装到当前用户目录下，也就是说安装后只有当前用户可以使用。如果选择 Customize installation ，可以选择为所有用户安装，也可以自定义安装路径。如果同时安装了多个版本，推荐都勾选上 Install launcher for all users，安装好之后可以使用py命令指定运行版本，比如同时安装了3.5和3.7，则可以使用 py -3.5 或 py -3.7指定运行版本。更多关于 Python Launcher 的内容可以参考官方文档 Python Launcher for Windows如果不是多版本并存的系统上，建议都勾选上 Add Python 3.5 to PATH，这样会把Python的安装路径自动添加到环境变量 PATH 中，避免在命令行中执行 python 命令时系统不能识别。如果是多版本并存的系统上可以不用勾选，然后都使用 Python Launcher 进行多版本管理。命令行安装可能很多同学不知道，Windows下的Python安装包其实也支持命令行的方式安装，这个在用于制作自动安装程序或者批量安装时非常有用。我们以下载的64位的3.5.1的安装包为例，下载后的安装包名称为 python-3.5.1-amd64.exe，在命令行(cmd)中切换到安装包所在路径，然后执行 python-3.5.1-amd64.exe /?，可以看到如下图所示的命令行安装帮助：可以使用 name=value 的方式指定安装参数，比如为所有用户安装 InstallAllUsers=1，还有自动添加安装路径到PATH环境变量 PrependPath=1，完整的安装参数请参考官方文档 Installing Without UI。比如以下安装命令就表示不需要用户干预但是会显示安装过程的自动安装，并且为所有用户安装，并且自动添加安装路径到PATH环境变量：python-3.5.1-amd64.exe /passive InstallAllUsers=1 PrependPath=1Linux大多数的Linux发行版都自带了Python2，系统自带的python2一定不要删除，因为通常会有一些系统自带软件依赖于它，如果要安装Python3可以通过下面几种方式。通过安装源在线安装如果你的电脑可以连接互联网，或者在一个内部网络上但是有内部安装源，推荐使用这种方式。不同的Linux发行版有不同的安装源工具，以CentOS7为例，CentOS7自带的python版本是2.7，CentOS上的安装源工具是yum，我们可以通过命令 yum install python3 来安装Python3，目前CentOS7官方yum源的python3的版本应该是3.7，安装完成后可通过键入 python3 查看是否安装成功需要注意的是在CentOS上安装好Python3后一定不能修改系统默认链接 /usr/bin/python 指向python3，否则运行yum时会得到如下错误：  File &quot;/usr/bin/yum&quot;, line 30    except KeyboardInterrupt, e:                            ^SyntaxError: invalid syntax这是由于yum依赖于系统自带的python2，改成python3之后由于语法不兼容，所以会出现错误。所以应该保持链接 /usr/bin/python 始终执行系统自带的python2。如果在其他Linux发行版上也遇到类似问题可以参考这种情况。使用包管理器离线安装不同的Linux发行版也有不同的包管理方式，安装源在线安装本质上就是自动从源上下载安装包然后使用包管理器进行安装。好处是方便，但是如果电脑不能联网就只能提前下载好安装包，然后使用系统自带的包管理器进行离线安装。还是以CentOS7为例，CentOS的包管理器是 rpm，比如已经下载好的rpm安装包名为 python35-3.5.1-xxx.rpm，那么可以使用命令 rpm -ivh python35-3.5.1-xxx.rpm 进行离线安装。离线安装包的下载可以通过各Linux发行版官网进行下载，也可以通过国内的镜像源网站下载，速度会比国外的快一些，这里列出几个常用的国内源：  清华大学：https://mirrors.tuna.tsinghua.edu.cn/  网易：http://mirrors.163.com/  阿里巴巴：https://developer.aliyun.com/mirror/使用源码编译安装Python官网提供 源码下载，下载解压后可通过make三连击 ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install 进行编译安装，前提是系统上已经配置好gcc等编译安装环境，如果对Linux不是很熟悉的用户不推荐使用此方式，因为出现安装问题的解决难度较大。macOSmacOS是在BSD(Berkeley Software Distribution)的基础上发展而来，而BSD是一个派生自Unix的操作系统，而Linux又是一个类Unix系统，所以macOS安装Python的方式也和Linux大体上差不多，主要分下面两种方式。需要注意的是macOS同样也自带了python2，系统自带的一些软件也会依赖于此，所以也一定不能删除。以macOS 10.15为例，自带的python2.7安装在 /System/Library/Frameworks/Python.framework/Versions/2.7 路径下。使用Homebrew在线安装Homebrew是macOS上的一种安装源工具，类似于CentOS的yum，直接使用如下命令安装即可：brew install python3图形界面安装可去Python官网下载 macOS installer，下载后双击进行图形界面安装，安装选项说明大体和Windows类似，这里不再赘述。Python命令行使用除了在命令行直接键入 python 进入Python交互式命令行的使用方式外，在命令行下使用Python通常还有下面三种方式python -c command通过这种方式可以快速的执行python命令：python -c &quot;print(&#39;hello, world!&#39;)&quot;python stript通过这种方式可以直接执行一个脚本文件：python mystript.pypython -m module_name通过这种方式调用一个安装好的python模块，比如可以使用python自带的http.server模块临时启动一个http服务器：python -m http.server引用资料  [Python安装] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624  [Python Setup and Usage] ：https://docs.python.org/3.5/using/index.html"
  },
  
  {
    "title": "Python 入门-1-简介",
    "url": "/posts/python-tutorial-1-introduction/",
    "categories": "Python 入门",
    "tags": "",
    "date": "2020-03-04 17:43:50 +0800",
    





    "snippet": "课程说明在 廖雪峰Python3教程 和 Python3.5官方文档 的基础上选取部分内容进行适当讲解，只是进行一个简单入门介绍，所以每个小节最后附上讲解内容对应章节的链接，以供深入学习。Python简介Python是由荷兰人Guido van Rossum (“龟叔”)于1989年圣诞节期间，为了打发时间而编写。Python这个名字取自作者很喜欢的BBC电视剧”Monty Python’s Flying Circus”。Python是在另一种编程语言 ABC 的基础上发展而来，ABC是“龟叔”参与设计的一种教学语言，他认为ABC非常优美和强大，但是并没有取得成功，他认为是没有开放造成的，所以Python进行了开源。Python还结合了很多C语言的使用习惯，比如Python中的open函数和C语言的open函数非常类似，Python里同样也有文件描述符等概念。Python是一种 解释型、面向对象 的语言，相比较而言C则是 编译型、面向过程 的语言。解释型语言使用解释器在运行期间动态的逐条将语句解释为计算机可识别的机器代码，编译型语言需要提前把源代码编译为机器代码，然后运行。解释型语言相比编译型语言的主要缺点是运行速度慢，但是由于很多的应用不需要追求很高的性能，所以使用解释型语言已经完全满足运行速度的要求。解释型语言相比编译型语言的主要优点是开发速度快，因为开发过程中可以不用编译就立即运行而得到反馈，另外像Python这样的高级语言做了更高程度的抽象和封装，并且把很多常用操作封装为了标准库，所以在代码量上会比C语言少很多。而且Python可以使用即时编译(JIT)技术提高运行速度面向对象和面向过程语言的主要区别是面向对象可以定义类(class)，而面向过程语言只能定义函数，Python既支持面向过程，也支持面向对象。关于面向对象和面向过程的更多区别请点击对应的链接进行深入了解。Python应用近些年来Python越来越火，应用也越来越广泛，根据编程语言排行榜 TIOBE 2020年2月最新的数据显示，目前Python的流行程度排行第3，居于Java和C之后。很多我们所熟知的网站也是使用Python开发，比如国外的Youtube、Instgram，国内的知乎、豆瓣，还有像Google、Yahoo这样的大公司内部都在大量的使用Python。Python在人工智能领域也非常流行，很多人工智能框架都选择使用Python语言，比如大名鼎鼎的Google人工智能框架TensorFlow就支持Python。另外Python在自动化测试方面也是应用广泛，比如开源的自动化测试框架RobotFramework就是使用Python编写的，很多公司在自己开发自动化测试框架时也大多选择使用Python，比如华为就是在大量的使用Python来进行自动化测试。由于Python简单、易学、易用的特点，所以在非编程相关的工作上也可以使用，比如日常办公中需要在大量的文本文件中搜索并替换某些内容，或者需要批量的整理操作大量文件，这个时候可以使用Python快速的编写一些小脚本来提升工作效率。相比shell或者bat等操作系统专用的脚本，Python的跨平台特性使得使用Python编写的脚本使用更方便。而且目前的大多数Linux发行版和OSX等系统上都内置了Python。可以在Python官网 https://www.python.org/about/apps/ 上看到Python的很多应用列表。Python版本Python自诞生以来经历了2个主要的大版本，一个是发布于2000年的Python2，另一个是发布于2008年的Python3。Python3相比Python2有了很大的变更，所以Python2下编写的代码是不能直接在Python3上运行的。而且官方已经于2020.1.1停止了对Python2的维护，也就是说如果Python2出现了重大漏洞也不会再有更新的修复版本发布了，所以建议如果是新写的项目都使用Python3。如果由老的Python2的应用需要迁移到Python3，可以参考官方迁移指南：https://docs.python.org/3/howto/pyporting.html更多关于Python2和Python3的区别可以参考：http://python-future.org/compatible_idioms.htmlPython解释器通常我们说Python是用C语言编写的，是因为官方下载的解释器CPython是使用C语言编写的，其实除了CPython之外还有很多其他的解释器。  以下内容引用自：https://www.liaoxuefeng.com/wiki/1016959663602400/1016966024263840  IPythonIPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。CPython用&amp;gt;&amp;gt;&amp;gt;作为提示符，而IPython用In [序号]:作为提示符。  PyPyPyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。  JythonJython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。  IronPythonIronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。Python编辑器(IDE)有很多的编辑器支持编写和调试Python程序，以下列出几个比较流行的，可以根据个人喜好进行选择：  IDLE：这个Python官方的IDE，Windows上安装Python后就会有，功能较简单，可以用于学习和测试一些语法。  PyCharm：这个是由JetBrains开发的Python IDE，功能强大，有专业版和社区版，个人使用可以选择免费的社区版。  VSCode：这个是微软的Visual Studio的精简版，开源且支持大量的插件，通过安装Python插件可以用于Python开发。  Vim：如果是Linux下也可以使用这Vim加一些插件进行Python开发。引用资料  [Python简介] ：https://www.liaoxuefeng.com/wiki/1016959663602400/1016959735620448  [Whetting Your Appetite] ：https://docs.python.org/3.5/tutorial/appetite.html  [Python-wikipedia] ：https://zh.wikipedia.org/wiki/Python#cite_note-python_history-3"
  }
  
]

